/******************************************************************************
 * Copyright (c) 2000-2018 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 ******************************************************************************///  File:     EPTF_CLL_LGenBase_ConfigFunctions.ttcn
//  Rev:      <RnXnn>
//  Prodnr:   CNL 113 512
//  Updated:  2012-02-16
//  Contact:  http://ttcn.ericsson.se
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
//  Module: EPTF_CLL_LGenBase_ConfigFunctions
// 
//  Purpose:
//    This module provides functions for configuration management in TitanSim 
//    load generators
// 
//  Module Parameters:
//    -
// 
//  Module depends on:
//    <EPTF_CLL_Base_Functions>
//    <EPTF_CLL_Common_Definitions>
//    <EPTF_CLL_HashMapStr2Int_Functions>
//    <EPTF_CLL_HashMapInt2Int_Functions>
//    <EPTF_CLL_LGenBase_ConfigDefinitions>
//    <EPTF_CLL_LGenBase_Definitions>
//    <EPTF_CLL_LGenBase_TemplateDefinitions>
//    <EPTF_CLL_LGenBase_TemplateFunctions>
//    <EPTF_CLL_LGenBaseTrafficMixer_Definitions>
//    <EPTF_CLL_RBTScheduler_Functions>
//    <EPTF_CLL_FBQ_Definitions all>
//    <EPTF_CLL_FBQ_Functions all>
// 
//  Current Owner:
//    ELSZSKU
// 
//  Last Review Date:
//    2008-
// 
//  Detailed Comments:
///////////////////////////////////////////////////////////
module EPTF_CLL_LGenBase_ConfigFunctions
{
import from EPTF_CLL_LGenBase_EventHandlingFunctions all;
import from EPTF_CLL_LGenBase_TrafficFunctions all;
import from EPTF_CLL_Base_Functions all;
import from EPTF_CLL_Base_Definitions all;
import from EPTF_CLL_Common_Definitions all;
import from EPTF_CLL_HashMapStr2Int_Functions all;
import from EPTF_CLL_HashMapInt2Int_Functions all;
import from EPTF_CLL_LGenBase_ConfigDefinitions all;
//import from EPTF_CLL_LGenBase_PhaseFunctions all;
import from EPTF_CLL_LGenBase_PhaseDefinitions all;
import from EPTF_CLL_LGenBase_PhaseConfigFunctions all
import from EPTF_CLL_LGenBase_Definitions all;
//import from EPTF_CLL_LGenBase_TemplateDefinitions all;
import from EPTF_CLL_LGenBase_LoggingFunctions all;
import from EPTF_CLL_LGenBaseTrafficMixer_Definitions all;
import from EPTF_CLL_RBTScheduler_Functions all;
//import from EPTF_CLL_FBQ_Definitions all;
import from EPTF_CLL_FBQ_Functions all;
import from EPTF_CLL_Variable_Definitions all;
import from EPTF_CLL_Variable_Functions all;
import from EPTF_CLL_StatHandlerClient_Functions all;
import from EPTF_CLL_Common_Functions all

friend module EPTF_CLL_LGenBase_EventHandlingFunctions; // f_EPTF_LGenBase_fsmTimerIdx
friend module EPTF_CLL_LGenBase_TrafficFunctions; // f_EPTF_LGenBase_getScNamePrefix, f_EPTF_LGenBase_areETypesCompatible, f_EPTF_LGenBaseStats_getTCName, f_EPTF_LGenBase_convertTrafficStartFinishConditionsInternalDeclarator2Desc, f_EPTF_LGenBase_convertEntityFinishConditionsInternalDeclarator2Desc, f_EPTF_LGenBase_convertTcEntityFinishActions2Desc, f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList, f_EPTF_LGenBase_BurstFuncName2Char, 
friend module EPTF_CLL_LGenBaseStats_Functions; // f_EPTF_LGenBase_getScNamePrefix
friend module EPTF_CLL_LGenBase_Functions; // f_EPTF_LGenBase_BurstFuncName2Char, f_EPTF_LGenBase_initEntityCtxs
friend module EPTF_CLL_ExecCtrl_ScenarioFunctions; // f_EPTF_LGenBase_convertScenarioTypeDeclarator2Internal
friend module EPTF_CLL_ExecCtrlClient_Functions; // f_EPTF_LGenBase_declareTrafficCaseTypeInternal, f_EPTF_LGenBase_declareScenarioTypeInternal

///////////////////////////////////////////////////////////
// Group: DeclaringMetadata
//
// Purpose:
//   Functions to declare metadata for <EPTF_LGenBase_CT> 
//
///////////////////////////////////////////////////////////
group DeclaringMetadata {
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareBehaviorType
  // 
  //  Purpose:
  //    EPTF_LGenBase behavior type declaration
  //
  //  Parameters:
  //    pl_name - *in charstring * - behavior name
  //    pl_maxCount - *in integer * - number of bound-able behavior contexts
  //    pl_resetFn - *in EPTF_LGenBase_BehaviorContextHandler_FT * - behavior context reset function 
  //    pl_bindFn - *in EPTF_LGenBase_BehaviorContextHandler_FT * - behavior context bind function 
  //    pl_unbindFn - *in EPTF_LGenBase_BehaviorContextHandler_FT * - behavior context unbind function 
  //
  //  Return Value:
  //    *integer* - the resulted index of the just declared behavior type in the
  //                behavior type database
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_declareBehaviorType(
    in charstring  pl_name,
    in integer     pl_maxCount,
    in  EPTF_LGenBase_BehaviorContextHandler_FT pl_resetFn,    
    in  EPTF_LGenBase_BehaviorContextBinder_FT pl_bindFn,
    in  EPTF_LGenBase_BehaviorContextHandler_FT pl_unbindFn,
    in EPTF_LGenBase_BehaviorContextBinder_FT pl_bindWithAbsIdxFn := null
  ) 
  runs on EPTF_LGenBase_Private_CT return integer{
    if(-1 < f_EPTF_LGenBase_behaviorTypeNameIndex(pl_name)){
      f_EPTF_LGenBase_loggingError(%definitionId&": The behavior type already exists : "&pl_name)
    }
    
    var integer vl_newIdx := sizeof(v_LGenBase_behaviorTypes);
    v_LGenBase_behaviorTypes[vl_newIdx] := valueof(
      t_LGenBase_BehaviorDeclaration(pl_name,pl_maxCount,pl_bindFn, pl_resetFn,pl_unbindFn,pl_bindWithAbsIdxFn));
    f_EPTF_FBQ_initFreeBusyQueue(v_LGenBase_behaviorTypes[vl_newIdx].listeners);
    v_LGenBase_testSteps[vl_newIdx]:={}
    v_LGenBase_fsmEvents[vl_newIdx]:={}
    v_LGenBase_behaviorTypes[vl_newIdx].behaviorOfEntityHashMap :=
    f_EPTF_int2int_HashMap_New(c_EPTF_LGenBase_behaviorOfEntityListenerHashMapPrefix &pl_name);
    v_LGenBase_behaviorTypes[vl_newIdx].behaviorOfSourceHashMap :=
    f_EPTF_int2int_HashMap_New(c_EPTF_LGenBase_behaviorOfSourceListenerHashMapPrefix &pl_name);
    f_EPTF_str2int_HashMap_Insert(v_LGenBase_behaviorHashMap, pl_name, vl_newIdx);
    //Initialize the new behavior context of all the entities 
    var integer vl_iECount := sizeof(v_LGenBase_entities);
    for ( var integer vl_i := 0; vl_i < vl_iECount ; vl_i := vl_i+1 )
    {
      v_LGenBase_entities[vl_i].bCtxList[vl_newIdx] := {};
    }
    return vl_newIdx;
  }//f_EPTF_LGenBase_declareBehaviorType
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareStep
  // 
  //  Purpose:
  //    EPTF_LGenBase test step declaration
  //
  //  Parameters:
  //    pl_bName - *in* *charstring* - name of the behavior
  //    pl_step - *in* <EPTF_LGenBase_TestStepDescriptor> - test step data
  //
  //  Return Value:
  //    *integer* - the selected index of the just declared test step in the
  //                test step database
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //    This function can be used tu declare test steps for the FSMs.    
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_declareStep(
    in charstring pl_bName,
    in EPTF_LGenBase_TestStepDescriptor pl_step)
  runs on EPTF_LGenBase_Private_CT return integer{
    var integer vl_bIdx := f_EPTF_LGenBase_behaviorTypeNameIndex(pl_bName);
    f_EPTF_Base_assert(%definitionId&": Invalid behavior type: "&pl_bName,-1!=vl_bIdx);
    var integer vl_stepIdx := -1;
    var integer vl_functionIdx;
    vl_functionIdx := f_EPTF_LGenBase_declareFunction(pl_step.name, {testStepFunction := pl_step.step});
    
    vl_stepIdx := sizeof(v_LGenBase_testSteps[vl_bIdx]);
    v_LGenBase_testSteps[vl_bIdx][vl_stepIdx] := vl_functionIdx;//pl_step;
    return vl_stepIdx;
  }//f_EPTF_LGenBase_declareStep
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareFsmEvent
  // 
  //  Purpose:
  //    EPTF_LGenBase FSM input (event) declaration
  //
  //  Parameters:
  //    pl_bName - *charstring* - registered behavior name. See <f_EPTF_LGenBase_declareBehaviorType> 
  //    pl_input - *in* <EPTF_LGenBase_FsmEvent> - FSM input data
  //
  //  Return Value:
  //    *integer* - the selected index of the FSM input in the
  //                FSM input database
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //    
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_declareFsmEvent(
    in charstring pl_bName,
    in charstring pl_input,
    in EPTF_LGenBase_LogEvent_FT pl_logFn := null
  ) 
  runs on EPTF_LGenBase_Private_CT return integer{
    var integer vl_bIdx := f_EPTF_LGenBase_behaviorTypeNameIndex(pl_bName);
    if(0 > vl_bIdx){
      f_EPTF_LGenBase_loggingError(%definitionId&": Invalid behavior type: "&pl_bName);
    }
    var integer vl_i:= sizeof(v_LGenBase_fsmEvents[vl_bIdx]);
    v_LGenBase_fsmEvents[vl_bIdx][vl_i] := {pl_input, pl_logFn};
    
    if(-1 < f_EPTF_LGenBase_inputNameIndex(pl_bName, pl_input)){
      f_EPTF_LGenBase_loggingError(%definitionId&": The event "&pl_input&" of behavior "&pl_bName&" has already been defined!")
    }
    f_EPTF_str2int_HashMap_Insert(v_LGenBase_fsmEventsBehaviorHashMap, pl_bName&tsp_LGenBase_nameSeparator&pl_input, vl_bIdx);
    f_EPTF_str2int_HashMap_Insert(v_LGenBase_fsmEventsInputHashMap, pl_bName&tsp_LGenBase_nameSeparator&pl_input, vl_i);
    v_LGenBase_genericEventListeners[vl_bIdx][vl_i] := c_EPTF_LGenBase_emptyListenerList;
    f_EPTF_FBQ_initFreeBusyQueue(v_LGenBase_genericEventListeners[vl_bIdx][vl_i]);
    v_LGenBase_genericTcListeners[vl_bIdx][vl_i] := c_EPTF_LGenBase_emptyListenerList;
    f_EPTF_FBQ_initFreeBusyQueue(v_LGenBase_genericTcListeners[vl_bIdx][vl_i]);
    v_LGenBase_entityTcListeners[vl_bIdx][vl_i] := c_EPTF_LGenBase_emptyListenerList;
    f_EPTF_FBQ_initFreeBusyQueue(v_LGenBase_entityTcListeners[vl_bIdx][vl_i]);
    v_LGenBase_behaviorTypes[vl_bIdx].entityListenerHashmapRefs[vl_i] := f_EPTF_int2int_HashMap_New(c_EPTF_LGenBase_entityListenerHashMapPrefix &pl_bName&tsp_LGenBase_nameSeparator&pl_input);
    v_LGenBase_behaviorTypes[vl_bIdx].generalSourceListenerHashmapRefs[vl_i] := f_EPTF_int2int_HashMap_New(c_EPTF_LGenBase_generalSourceListenerHashMapPrefix &pl_bName&tsp_LGenBase_nameSeparator&pl_input);
    return vl_i;
  }//f_EPTF_LGenBase_declareFsmEvent
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareFsmEventList
  // 
  //  Purpose:
  //    EPTF_LGenBase FSM input (event) list declaration
  //
  //  Parameters:
  //    pl_eventArray -  list of event data (event constant, event name)
  //    pl_bName - *charstring* - registered behavior name. See <f_EPTF_LGenBase_declareBehaviorType>
  //
  //  
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //    
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_declareFsmEventList(
    in EPTF_LGenBase_EventArrayDeclaratorList pl_eventArray,
    in charstring pl_bName
  ) 
  runs on EPTF_LGenBase_Private_CT {
    
    var integer vl_ret := 0;
    
    for(var integer vl_i := 0; vl_i < sizeof(pl_eventArray); vl_i := vl_i+1){
      
      vl_ret := f_EPTF_LGenBase_declareFsmEvent(pl_bName,pl_eventArray[vl_i].eventName);
      f_EPTF_Base_assert(%definitionId&": "&pl_eventArray[vl_i].eventName&" must be "&int2str(pl_eventArray[vl_i].eventConstant),vl_ret == pl_eventArray[vl_i].eventConstant);
      
    }
    
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareCompactFsmTable
  // 
  //  Purpose:
  //    FSM table declaration using direct fn. references to test steps.
  //
  //  Parameters:
  //    pl_table - *in* <EPTF_LGenBase_CompactFsmTable> - FSM table data
  //
  //  Return Value:
  //    *integer* - the selected index of the FSM table in the
  //                FSM table database
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //    
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_declareCompactFsmTable(
    in  EPTF_LGenBase_CompactFsmTable pl_table) 
  runs on EPTF_LGenBase_Private_CT return integer{
    if(-1 != f_EPTF_LGenBase_fsmNameIndex(pl_table.name)){
      f_EPTF_LGenBase_loggingError(%definitionId&": The FSM table with name "&pl_table.name&" already exists.")
    }
    var integer t:= sizeof(v_LGenBase_fsmTables);
    v_LGenBase_fsmTables[t] := c_EPTF_LGenBase_emptyInternalFsmTable;
    v_LGenBase_fsmTables[t].name :=  pl_table.name;
    f_EPTF_LGenBase_createFSMHashMaps(pl_table.name,v_LGenBase_fsmTables[t],false)    
    v_LGenBase_fsmTables[t].stateList :=  pl_table.stateList;
    f_EPTF_LGenBase_appendTimerList(pl_table.timerList,v_LGenBase_fsmTables[t].timerList)
    //Initialize the column index list
    var EPTF_IntegerList vl_colIdxList := {}
    for ( var integer vl_state := 0; vl_state < sizeof(pl_table.stateList) ; vl_state := vl_state+1 ){
      vl_colIdxList[vl_state] := vl_state
    }
    
    for ( var integer vl_i := 0; vl_i < sizeof(pl_table.table) ; vl_i := vl_i+1 )
    {
      v_LGenBase_fsmTables[t].rows[vl_i].colIdxListByStates := vl_colIdxList
      v_LGenBase_fsmTables[t].rows[vl_i].cellList := pl_table.table[vl_i].cellRow
      v_LGenBase_fsmTables[t].eventXref[vl_i] := c_EPTF_LGenBase_emptyInternalFSMEvent2RowXref;
      v_LGenBase_fsmTables[t].eventXref[vl_i].event2Listen := pl_table.table[vl_i].eventToListen
      v_LGenBase_fsmTables[t].eventXref[vl_i].rowIdx := vl_i
    }
    //v_LGenBase_fsmTables[t].table :=  pl_table.table;
    f_EPTF_LGenBase_CompactFsmTable_checkDuplicatedEventToListen(v_LGenBase_fsmTables[t]);
    f_EPTF_LGenBase_fillEventsHasmaps(t,v_LGenBase_fsmTables[t].eventXref,-1,-1);
    return t;
  }//f_EPTF_LGenBase_declareCompactFsmTable
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fillEventsHasmaps
  // 
  //  Purpose:
  //    Function for filling events hashmap
  //
  //  Parameters:
  //    pl_t - *in* *integer* - index of the FSM table in the tables database
  //    pl_table - *in* <EPTF_LGenBase_InternalFsmTable> - FSM table data  
  //
  //  Return Value:
  //    -
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //    -
  ///////////////////////////////////////////////////////////   
  friend function f_EPTF_LGenBase_fillEventsHasmaps(
    in integer pl_tableIdx,
    in  EPTF_LGenBase_InternalFSMEvent2RowXrefList pl_eventXref,
    in integer pl_tcIdx,
    in integer pl_siblingIdx)
  runs on EPTF_LGenBase_Private_CT{
    //Do not build reftable if not FSM event 
    for (var integer vl_event:=0;vl_event<sizeof(pl_eventXref); vl_event:=vl_event+1) {
      //Check whether the event type is FSM
      if(fsm == pl_eventXref[vl_event].event2Listen.eventType)
      {
        var integer bIdx:=pl_eventXref[vl_event].event2Listen.bIdx;
        var integer iIdx:=pl_eventXref[vl_event].event2Listen.iIdx;
        if(bIdx < 0){
          var integer vl_spbIdx := bIdx*-1
          var integer vl_idx := 0
          if(isbound(v_LGenBase_spEventFSMXrefs[vl_spbIdx][iIdx].singleFsm[pl_tableIdx])){
            vl_idx := sizeof(v_LGenBase_spEventFSMXrefs[vl_spbIdx][iIdx].singleFsm[pl_tableIdx])
          }else{
            v_LGenBase_spEventFSMXrefs[vl_spbIdx][iIdx].fsmOfTc := {};
          } 
          v_LGenBase_spEventFSMXrefs[vl_spbIdx][iIdx].singleFsm[pl_tableIdx][vl_idx]:= c_EPTF_LGenBase_emptyFsmTableXRefItem
          v_LGenBase_spEventFSMXrefs[vl_spbIdx][iIdx].singleFsm[pl_tableIdx][vl_idx].rowIdx := pl_eventXref[vl_event].rowIdx 
        }else{
          if (pl_tcIdx==-1) {
            var integer vl_rowPos := 0
            if(isbound(v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].singleFsm[pl_tableIdx])){
              vl_rowPos := sizeof(v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].singleFsm[pl_tableIdx])
            }
            if (not isbound(v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].fsmOfTc)) {
              v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].fsmOfTc := {}
            }
            v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].singleFsm[pl_tableIdx][vl_rowPos]:= c_EPTF_LGenBase_emptyFsmTableXRefItem
            v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].singleFsm[pl_tableIdx][vl_rowPos].rowIdx := pl_eventXref[vl_event].rowIdx;
            v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].singleFsm[pl_tableIdx][vl_rowPos].siblingRef := pl_eventXref[vl_event].siblingRef;
            if (c_EPTF_Common_debugSwitch){
              f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId,": Adding to table listeners: ",
                  "\n",v_LGenBase_fsmTables[pl_tableIdx].name,
                  "\n",f_EPTF_LGenBase_bIdx2Str(bIdx),
                  "\n",f_EPTF_LGenBase_iIdx2Str(bIdx,iIdx),
                  "\n",v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].singleFsm[pl_tableIdx][vl_rowPos]))
            }
          } else {
            var integer vl_rowPos := 0
            if(isbound(v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].fsmOfTc[pl_tcIdx][pl_siblingIdx])){
              vl_rowPos := sizeof(v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].fsmOfTc[pl_tcIdx][pl_siblingIdx])
            }
            if (not isbound(v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].singleFsm)) {
              v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].singleFsm := {}
            }
            v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].fsmOfTc[pl_tcIdx][pl_siblingIdx][vl_rowPos]:= c_EPTF_LGenBase_emptyFsmTableXRefItem
            v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].fsmOfTc[pl_tcIdx][pl_siblingIdx][vl_rowPos].rowIdx := pl_eventXref[vl_event].rowIdx;
            v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].fsmOfTc[pl_tcIdx][pl_siblingIdx][vl_rowPos].siblingRef := pl_eventXref[vl_event].siblingRef;
            if (c_EPTF_Common_debugSwitch){
              f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId,": Adding to table listeners: ",
                  "\n",v_LGenBase_fsmTables[pl_tableIdx].name,
                  "\n",f_EPTF_LGenBase_bIdx2Str(bIdx),
                  "\n",f_EPTF_LGenBase_iIdx2Str(bIdx,iIdx),
                  "\n",v_LGenBase_behaviorTypes[bIdx].fsmTableXRefDB[iIdx].fsmOfTc[pl_tcIdx][pl_siblingIdx][vl_rowPos]))
            }
          }
        }
      }
    }
  }
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_CompactFsmTable_checkDuplicatedEventToListen
  // 
  //  Purpose:
  //    Function for checking if there is a duplicated listener to be registered for an event
  //
  //  Parameters:
  //    pl_table - *in* <EPTF_LGenBase_CompactFsmTable> - FSM table data
  //
  //  Return Value:
  //    -
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //    Sends a warning log if listener is duplicated
  ///////////////////////////////////////////////////////////  
  private function f_EPTF_LGenBase_CompactFsmTable_checkDuplicatedEventToListen(
    in  EPTF_LGenBase_InternalFsmTable pl_table)
  runs on EPTF_LGenBase_Private_CT{
    for(var integer i := 1; i < sizeof(pl_table.eventXref); i := i + 1) {
      for(var integer j := 0; j < i; j := j + 1) {
        if(pl_table.eventXref[i].event2Listen.bIdx == pl_table.eventXref[j].event2Listen.bIdx and
          pl_table.eventXref[i].event2Listen.iIdx == pl_table.eventXref[j].event2Listen.iIdx) {
          f_EPTF_LGenBase_loggingWarning(%definitionId&": compact FSM table "&pl_table.name&" has duplicated listener for event ("&
            int2str(pl_table.eventXref[i].event2Listen.bIdx)& ", "& int2str(pl_table.eventXref[j].event2Listen.iIdx)& ").");
        }
      }
    }
  }
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmTimerIdx
  // 
  //  Purpose:
  //    Finds the specified timer in the given list of local timers ad 
  //    retrieves its index.     
  //
  ///////////////////////////////////////////////////////////
  friend function f_EPTF_LGenBase_fsmTimerIdx(
    in EPTF_LGenBase_FsmTimerInternalList pl_timerList,
    in charstring pl_timerName) 
  runs on EPTF_LGenBase_Private_CT return integer{
    //There won't be so much timers to use hashmap, and it isn't called during load generation
    for ( var integer vl_timer := 0; vl_timer < sizeof(pl_timerList); vl_timer := vl_timer+1 )
    {
      if(pl_timerList[vl_timer].name == pl_timerName){
        return vl_timer;
      }
    }
    return -1
  }//f_EPTF_LGenBase_fsmTimerIdx
  
  type enumerated EPTF_LGenBase_FsmDeclaratorType {compact, indexed}
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareParamedFsmTable
  // 
  //  Purpose:
  //    FSM table declaration using EPTF_LGenBase_CompactFsmTableDeclarator with 
  //    names of registered functions to test steps.
  //
  //  Parameters:
  //    pl_tableDeclarator - *in* <EPTF_LGenBase_CompactFsmTableDeclarator> - FSM table declarator
  //    pl_type - *in* <EPTF_LGenBase_FsmDeclaratorType> - FSM table type (compact, indexed) 
  //
  //  Return Value:
  //    *integer* - the selected index of the FSM table in the
  //                FSM table database
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_declareParamedFsmTable(
    in EPTF_LGenBase_CompactFsmTableDeclarator pl_tableDeclarator, 
    in EPTF_LGenBase_FsmDeclaratorType pl_type := compact) //For backward compatibility only
  runs on EPTF_LGenBase_Private_CT return integer{
    var EPTF_LGenBase_FSMInternalDeclarator vl_internal
    f_EPTF_LGenBase_convertParamedFsm2Internal(pl_tableDeclarator, vl_internal)
    return f_EPTF_LGenBase_declareFSMTableFromInternal(vl_internal)
  }//EPTF_LGenBase_FsmDeclaratorType
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareFSMTable
  // 
  //  Purpose:
  //    
  //
  //  Parameters:
  //    pl_fsm - *in* <EPTF_LGenBase_FsmTableDeclarator> - FSM table data
  //
  //  Return Value:
  //    *integer* - index of the new FSM table
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //    
  //
  /////////////////////////////////////////////////////////// 
  public function f_EPTF_LGenBase_declareFSMTable(in EPTF_LGenBase_FsmTableDeclarator pl_fsm)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var EPTF_LGenBase_FSMInternalDeclarator vl_fsmInt
    f_EPTF_LGenBase_convertFlexFsmDeclaration2Internal(pl_fsm,vl_fsmInt)
    return f_EPTF_LGenBase_declareFSMTableFromInternal(vl_fsmInt)
  }//f_EPTF_LGenBase_declareFSMTable
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareFSMTables
  // 
  //  Purpose:
  //    
  //
  //  Parameters:
  //	pl_fsmList - *in* <EPTF_LGenBase_FsmTableDeclaratorList> - a list of FSM tables
  //
  //  Return Value:
  //    <EPTF_IntegerList> - list of the indexes of the new FSM tables
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //    
  //
  /////////////////////////////////////////////////////////// 
  public function f_EPTF_LGenBase_declareFSMTables(in EPTF_LGenBase_FsmTableDeclaratorList pl_fsmList)
  runs on EPTF_LGenBase_Private_CT
  return EPTF_IntegerList{
    var EPTF_IntegerList vl_ret := {};
    for ( var integer vl_i := 0; vl_i < sizeof(pl_fsmList) ; vl_i := vl_i+1 )
    {
      vl_ret[vl_i] := f_EPTF_LGenBase_declareFSMTable(pl_fsmList[vl_i]);
    }
    return vl_ret;
  }//f_EPTF_LGenBase_declareFSMTables
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_TcMgmt_declareEntityTypes
  // 
  //  Purpose:
  //    Registeres the entity types in the database. 
  //    Calls the <f_EPTF_LGenBase_declareEntityType>
  //    See also:<EPTF_LGenBase_TcMgmt_EntityTypeDeclaratorList>
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_TcMgmt_declareEntityTypes(
    in  EPTF_LGenBase_TcMgmt_EntityTypeDeclaratorList pl_typeList) 
  runs on EPTF_LGenBase_Private_CT
  return EPTF_IntegerList{
    var EPTF_IntegerList vl_ret := {};
    for ( var integer vl_i := 0; vl_i < sizeof(pl_typeList) ; vl_i := vl_i+1 )
    {
      vl_ret[vl_i] := f_EPTF_LGenBase_declareEntityType(pl_typeList[vl_i].name, pl_typeList[vl_i].behaviorTypeIdxList);
    }
    return vl_ret;
  }//f_EPTF_LGenBase_TcMgmt_declareEntityTypes
  
  ///////////////////////////////////////////////////////////
  //  Group: TCMgmt
  // 
  //  Purpose:
  //    Traffic management-related declarators
  ///////////////////////////////////////////////////////////
  group TCMgmt{  
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_declareCompactFsmTables
    // 
    //  Purpose:
    //    A detailed FSM table declaration using EPTF_LGenBase_CompactFsmTableDeclaratorList with 
    //    names of registered functions to test steps.
    //
    //  Parameters:
    //    pl_tableList - *in* <EPTF_LGenBase_TcMgmt_CompactFsmTableDeclaratorList> - a list of FSM tables
    //
    //  Return Value:
    //    <EPTF_IntegerList> - the selected indices of the FSM table in the FSM table database
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //    The FSM tables can be described even in config files.
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_TcMgmt_declareCompactFsmTables(
      in  EPTF_LGenBase_TcMgmt_CompactFsmTableDeclaratorList pl_tableList) 
    runs on EPTF_LGenBase_Private_CT
    return EPTF_IntegerList{
      var EPTF_IntegerList vl_ret := {};
      for ( var integer vl_i := 0; vl_i < sizeof(pl_tableList) ; vl_i := vl_i+1 )
      {
        vl_ret[vl_i] := f_EPTF_LGenBase_declareParamedFsmTable(pl_tableList[vl_i]);
      }
      return vl_ret;
    }//f_EPTF_LGenBase_TcMgmt_declareCompactFsmTables
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_TcMgmt_declareIndexedFsmTables
    // 
    //  Purpose:
    //    FSM table declaration using EPTF_LGenBase_TcMgmt_IndexedFsmTableDeclaratorList with 
    //    names of registered functions to test steps.
    //    See also:<EPTF_LGenBase_TcMgmt_IndexedFsmTableDeclaratorList>
    //
    //  Parameters:
    //    pl_tableList - *in* <EPTF_LGenBase_TcMgmt_IndexedFsmTableDeclaratorList> - FSM table data
    //
    //  Return Value:
    //    *integer* - the selected index of the FSM table in the
    //                FSM table database
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //    The FSM tables can be described even in config files.
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_TcMgmt_declareIndexedFsmTables(
      in  EPTF_LGenBase_TcMgmt_IndexedFsmTableDeclaratorList pl_tableList) 
    runs on EPTF_LGenBase_Private_CT
    return EPTF_IntegerList{
      var EPTF_IntegerList vl_ret := {};
      for ( var integer vl_i := 0; vl_i < sizeof(pl_tableList) ; vl_i := vl_i+1 )
      {
        vl_ret[vl_i] := f_EPTF_LGenBase_declareParamedFsmTable(pl_tableList[vl_i]);
      }
      return vl_ret;
    }//f_EPTF_LGenBase_TcMgmt_declareIndexedFsmTables        
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_TcMgmt_declareEntityGroups
    // 
    //  Purpose:
    //    Creates the entity groups. Calls the <f_EPTF_LGenBase_createEntityGroup>.
    //    See also:<EPTF_LGenBase_TcMgmt_EntityGrpDeclaratorList>
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_TcMgmt_declareEntityGroups(in  EPTF_LGenBase_TcMgmt_EntityGrpDeclaratorList pl_grpTypeList) 
    runs on EPTF_LGenBase_Private_CT
    return EPTF_IntegerList{
      var EPTF_IntegerList vl_ret := {};
      for ( var integer vl_i := 0; vl_i < sizeof(pl_grpTypeList) ; vl_i := vl_i+1 )
      {
        vl_ret[vl_i] := f_EPTF_LGenBase_createEntityGroup(pl_grpTypeList[vl_i]);
      }
      return vl_ret;
    }//f_EPTF_LGenBase_TcMgmt_declareEntityGroups
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_TcMgmt_declareScenariosTypes
    // 
    //  Purpose:
    //    Registers a list of scenarios. Calls the <f_EPTF_LGenBase_declareScenarioType3>.
    //    See also:<EPTF_LGenBase_ScenarioTypeInternalDeclaratorList>
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_TcMgmt_declareScenarioTypes(in EPTF_LGenBase_ScenarioTypeDeclaratorList pl_scTypeList) 
    runs on EPTF_LGenBase_Private_CT
    return EPTF_IntegerList{
      var EPTF_IntegerList vl_ret := {};
      for ( var integer vl_i := 0; vl_i < sizeof(pl_scTypeList) ; vl_i := vl_i+1 )
      {
        vl_ret[vl_i] := f_EPTF_LGenBase_declareScenarioType3(pl_scTypeList[vl_i]);
      }
      return vl_ret;
    }//f_EPTF_LGenBase_TcMgmt_declareScenarios2     
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_declareIndexedCompactFsmTable
    // 
    //  Purpose:
    //    Declare an FSM table using (behaviorTypeIdx,testIdx) tuples instead of
    //    direct fn. references. 
    //
    //  Parameters:
    //    pl_table - *in* <EPTF_LGenBase_IndexedCompactFsmTable> - indexedFSM table data
    //
    //  Return Value:
    //    *integer* - the selected index of the FSM table in the
    //                FSM table database
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //    It converts the <EPTF_LGenBase_IndexedCompactFsmTable>  argument to
    //    <EPTF_LGenBase_CompactFsmTable> on-the-fly and stores as such. Nextstate 
    //    declarations are asserted if present.
    //
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_declareIndexedCompactFsmTable(
      in  EPTF_LGenBase_IndexedCompactFsmTable pl_table) 
    runs on EPTF_LGenBase_Private_CT return integer{
      var integer t:= sizeof(v_LGenBase_fsmTables);
      v_LGenBase_fsmTables[t] := c_EPTF_LGenBase_emptyInternalFsmTable     
      v_LGenBase_fsmTables[t].name := pl_table.name;
      f_EPTF_LGenBase_createFSMHashMaps(pl_table.name,v_LGenBase_fsmTables[t],false)    
      v_LGenBase_fsmTables[t].stateList := pl_table.stateList;
      f_EPTF_LGenBase_appendTimerList(pl_table.timerList, v_LGenBase_fsmTables[t].timerList)
      //Initialize the column index list
      var EPTF_IntegerList vl_colIdxList := {}
      for ( var integer vl_state := 0; vl_state < sizeof(pl_table.stateList) ; vl_state := vl_state+1 ){
        vl_colIdxList[vl_state] := vl_state
      }
      for (var integer r:=0; r<sizeof(pl_table.table); r:=r+1){
        v_LGenBase_fsmTables[t].eventXref[r] := c_EPTF_LGenBase_emptyInternalFSMEvent2RowXref;
        v_LGenBase_fsmTables[t].eventXref[r].event2Listen := pl_table.table[r].eventToListen
        v_LGenBase_fsmTables[t].eventXref[r].rowIdx := r
        for (var integer c:=0; c<sizeof(pl_table.table[r].cellRow); c:=c+1) {
          if(ispresent(pl_table.table[r].cellRow[c].actionList)) {
            for (var integer a:=0;a<sizeof(pl_table.table[r].cellRow[c].actionList); a:=a+1){
              var integer aBIdx:=pl_table.table[r].cellRow[c].actionList[a].step.bIdx,
              aSidx:=pl_table.table[r].cellRow[c].actionList[a].step.sIdx;
              v_LGenBase_fsmTables[t].rows[r].cellList[c].actionList[a].step := 
              v_LGenBase_functions[v_LGenBase_testSteps[aBIdx][aSidx]].testStepFunction;
              //v_LGenBase_testSteps[aBIdx][aSidx].step;          
              v_LGenBase_fsmTables[t].rows[r].cellList[c].actionList[a].stepContextArgs := 
              pl_table.table[r].cellRow[c].actionList[a].stepContextArgs;          
            }//actionList
          } else {
            v_LGenBase_fsmTables[t].rows[r].cellList[c].actionList := omit
          }
          v_LGenBase_fsmTables[t].rows[r].colIdxListByStates := vl_colIdxList
          v_LGenBase_fsmTables[t].rows[r].cellList[c].nextState := 
          pl_table.table[r].cellRow[c].nextState
          v_LGenBase_fsmTables[t].rows[r].cellList[c].nextStateCalculation := 
          pl_table.table[r].cellRow[c].nextStateCalculation
          f_EPTF_Base_assert(%definitionId&": Declared nextstate must be valid",
            not ispresent(pl_table.table[r].cellRow[c].nextState)
            or (ispresent(pl_table.table[r].cellRow[c].nextState) 
              and  (pl_table.table[r].cellRow[c].nextState>=0 
                or pl_table.table[r].cellRow[c].nextState<sizeof(pl_table.stateList)))
          )
        }//columns
      }//rows
      f_EPTF_LGenBase_fillEventsHasmaps(t,v_LGenBase_fsmTables[t].eventXref,-1,-1);
      v_LGenBase_temporaryHashMaps := {}
      return t;
    }//f_EPTF_LGenBase_declareIndexedCompactFsmTable
  } // group TCMgmt
  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareEntityType
  // 
  //  Purpose:
  //    Initializes an entity type
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_declareEntityType(
    in charstring pl_name, //name of the entity type
    in EPTF_CharstringList pl_behaviorTypeList //references to the behavior types it exhibits 
  )
  runs on EPTF_LGenBase_Private_CT
  return integer{ 
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": The name of the entity type mustn't be empty.","" != pl_name);
      f_EPTF_Base_assert(%definitionId&": The entity type "&pl_name&" already exists.",-1 == f_EPTF_LGenBase_entityTypeNameIndex(pl_name));
    }
    var integer vl_ret := sizeof(v_LGenBase_entityTypes);
    var EPTF_LGenBase_EntityType vl_eType := {
      name := pl_name, 
      behaviorTypeIdxList := {}, 
      currCount := 0
    };
    var integer vl_bMax := sizeof(pl_behaviorTypeList);
    for ( var integer vl_i := 0; vl_i < vl_bMax ; vl_i := vl_i+1 )
    {
      vl_eType.behaviorTypeIdxList[vl_i] := f_EPTF_LGenBase_behaviorTypeNameIndex(pl_behaviorTypeList[vl_i]);
      f_EPTF_Base_assert(%definitionId&": Invalid behavior type:"&pl_behaviorTypeList[vl_i],-1 != vl_eType.behaviorTypeIdxList[vl_i]);	  
    }
    v_LGenBase_entityTypes[vl_ret] := vl_eType;     
    return vl_ret;
  }//f_EPTF_LGenBase_declareEntityType
  
  ///////////////////////////////////////////////////////////
  //  Group: trafficDeclarators
  // 
  //  Purpose:
  //    Traffic case and scenario declarators
  ///////////////////////////////////////////////////////////  
  group trafficDeclarators{  
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_convertScenarioTypeDeclarator2Internal
    // 
    //  Purpose:
    //    Processes a <EPTF_LGenBase_ScenarioTypeDeclarator> and
    //    converts it to an internal <EPTF_LGenBase_ScenarioTypeInternalDeclarator>
    ///////////////////////////////////////////////////////////
    friend function f_EPTF_LGenBase_convertScenarioTypeDeclarator2Internal(
      in EPTF_LGenBase_ScenarioTypeDeclarator pl_scDecl,
      out EPTF_LGenBase_ScenarioTypeInternalDeclarator pl_dest)
    //TODO in EPTF_LGenBase_Error_FT pl_errorFn := refers()
    runs on EPTF_Base_CT{
      pl_dest := c_EPTF_LGenBase_emptyScenarioTypeInternalDeclarator;
      pl_dest.name := pl_scDecl.name;
      //parameters
      for ( var integer vl_i := 0; vl_i < sizeof(pl_scDecl.scParamsList) ; vl_i := vl_i+1 ){
        select (true){
          case( ischosen(pl_scDecl.scParamsList[vl_i].enabled) ){
            pl_dest.enabled := pl_scDecl.scParamsList[vl_i].enabled
          }
          case( ischosen(pl_scDecl.scParamsList[vl_i].phaseListName) ){
            pl_dest.phaseListName := pl_scDecl.scParamsList[vl_i].phaseListName
          }
          case( ischosen(pl_scDecl.scParamsList[vl_i].phaseFinishConditions) ){
            pl_dest.phaseFinishConditions := pl_scDecl.scParamsList[vl_i].phaseFinishConditions
          }
          case( ischosen(pl_scDecl.scParamsList[vl_i].phaseStateChangeActions) ){
            pl_dest.phaseStateChangeActions := pl_scDecl.scParamsList[vl_i].phaseStateChangeActions
          }
          case( ischosen(pl_scDecl.scParamsList[vl_i].weightedScData) ){
            pl_dest.weightedScData := pl_scDecl.scParamsList[vl_i].weightedScData
          }
          case( ischosen(pl_scDecl.scParamsList[vl_i].trafficType) ){
            pl_dest.trafficType := pl_scDecl.scParamsList[vl_i].trafficType
          }
          case else{
            f_EPTF_Base_assert(%definitionId&": Invalid scenario type parameter:"&log2str(pl_scDecl.scParamsList[vl_i]),false)
          }
        }
      }
      //traffic cases
      for ( var integer vl_i := 0; vl_i < sizeof(pl_scDecl.tcList) ; vl_i := vl_i+1 )
      {
        pl_dest.tcList[vl_i].enable := false; //take place only
        f_EPTF_LGenBase_convertTcOfScenarioTypeDeclarator2Internal(
          pl_scDecl.tcList[vl_i],
          pl_scDecl.name,
          pl_dest.tcList[vl_i])
      }
      f_EPTF_LGenBase_checkScenarioType(pl_dest);
    }
    
    ///////////////////////////////////////////////////////////
    //  PrivateFunction: f_EPTF_LGenBase_convertTcOfScenarioTypeDeclarator2Internal
    // 
    //  Purpose:
    //    Processes a <EPTF_LGenBase_TcOfScenarioDeclarator> and
    //    converts it to an internal <EPTF_LGenBase_TcOfScenarioInternalDeclarator>
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_convertTcOfScenarioTypeDeclarator2Internal(
      in EPTF_LGenBase_TcOfScenarioDeclarator pl_tcDecl,
      in charstring pl_scName,
      out EPTF_LGenBase_TcOfScenarioInternalDeclarator pl_dest)
    //TODO in EPTF_LGenBase_Error_FT pl_errorFn := refers()
    runs on EPTF_Base_CT{
      pl_dest := c_EPTF_LGenBase_emptyTcOfScenarioInternalDeclarator;
      pl_dest.tcPrivateName := pl_tcDecl.tcName;
      var boolean vl_tcTypeName := false
      var boolean vl_startDelay := false
      var boolean vl_enableEntitiesAtStart := false
      var boolean vl_enabledAtStart := false
      var boolean vl_target := false
      var boolean vl_scheduler := false
      var boolean vl_entitySelection := false
      var boolean vl_ranges := false
      var boolean vl_params := false
      var boolean vl_entityFinishConditions := false
      var boolean vl_entityFinishActions := false
      var boolean vl_trafficStartFinish := false
      var boolean vl_trafficFinishedActions := false
      var boolean vl_templateSet := false
      var boolean vl_fsmList := false
      var boolean vl_siblingFsmList := false;
      var boolean vl_customEntitySucc := false
      //f_EPTF_Base_assert(%definitionId&": Invalid traffic case name: "&pl_tcDecl.tcName, -1 != pl_dest.tcTypeIdx);
      for ( var integer vl_i := 0; vl_i < sizeof(pl_tcDecl.tcParamsList) ; vl_i := vl_i+1 ){
        select( true ){
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].tcTypeName)){
            if(vl_tcTypeName){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "tcTypeName", 
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].tcTypeName),
                log2str( pl_dest.tcTypeName))
            }
            pl_dest.tcTypeName := pl_tcDecl.tcParamsList[vl_i].tcTypeName
            vl_tcTypeName := true;
          }
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].startDelay)){
            if(vl_startDelay){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "startDelay",
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].startDelay),
                log2str( pl_dest.startDelay))
            }
            pl_dest.startDelay := pl_tcDecl.tcParamsList[vl_i].startDelay
            vl_startDelay := true;
          }
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].enableEntitiesAtStart)){
            if(vl_enableEntitiesAtStart){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "enableEntitiesAtStart",
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].enableEntitiesAtStart),
                log2str( pl_dest.enableEntities))
            }
            pl_dest.enableEntities := pl_tcDecl.tcParamsList[vl_i].enableEntitiesAtStart
            vl_enableEntitiesAtStart := true
          }
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].enabledAtStart)){
            if(vl_enabledAtStart){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "enabledAtStart",
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].enabledAtStart),
                log2str( pl_dest.enable))
            }
            pl_dest.enable := pl_tcDecl.tcParamsList[vl_i].enabledAtStart
            vl_enabledAtStart := true
          }
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].target)){
            if(vl_target){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "target",
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].target),
                log2str( pl_dest.target))
            }
            pl_dest.target := pl_tcDecl.tcParamsList[vl_i].target
            vl_target := true
          }
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].scheduler)){
            if(vl_scheduler){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "scheduler",
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].scheduler),
                log2str( pl_dest.scheduler))
            }
            if(ischosen(pl_tcDecl.tcParamsList[vl_i].scheduler.preDefinedName)){
              pl_dest.scheduler := f_EPTF_LGenBase_BurstFuncName2Char(pl_tcDecl.tcParamsList[vl_i].scheduler.preDefinedName); 
            } else {
              pl_dest.scheduler := pl_tcDecl.tcParamsList[vl_i].scheduler.userDefinedName;
            }
            vl_scheduler := true
          }       
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].entitySelection)){
            if(vl_entitySelection){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "entitySelection",
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].entitySelection),
                log2str( pl_dest.entitySelection))
            }
            pl_dest.entitySelection := pl_tcDecl.tcParamsList[vl_i].entitySelection
            vl_entitySelection := true
          }
          
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].ranges)){
            if(vl_ranges){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "ranges",
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].ranges),
                log2str( pl_dest.ranges))
            }
            pl_dest.ranges := pl_tcDecl.tcParamsList[vl_i].ranges
            vl_ranges := true
          }
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].params)){
            if(vl_params){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "params",
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].params),
                log2str( pl_dest.params))
            }
            pl_dest.params := pl_tcDecl.tcParamsList[vl_i].params
            vl_params := true
          }
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].entityFinishConditions)){
            if(vl_entityFinishConditions){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "entityFinishConditions",
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].entityFinishConditions),
                log2str( pl_dest.entityFinishConditions))
            }
            vl_entityFinishConditions := true
            for ( var integer vl_eCond := 0; vl_eCond < sizeof(pl_tcDecl.tcParamsList[vl_i].entityFinishConditions) ; vl_eCond := vl_eCond+1 ){
              select( true ){
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].nrOfExecStart)){
                  if(not ispresent( pl_dest.entityFinishConditions.nrOfExecStart)){
                    pl_dest.entityFinishConditions.nrOfExecStart := pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].nrOfExecStart
                  }else{
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "nrOfExecStart",
                      "entity finish condition",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].nrOfExecStart),
                      log2str( pl_dest.entityFinishConditions.nrOfExecStart))
                  }
                }
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].nrOfFails)){
                  if(ispresent(pl_dest.entityFinishConditions.nrOfFails)){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "nrOfFails",
                      "entity finish condition",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].nrOfFails),
                      log2str( pl_dest.entityFinishConditions.nrOfFails))
                  }
                  pl_dest.entityFinishConditions.nrOfFails := pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].nrOfFails
                }
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].nrOfErrors)){
                  if(ispresent(pl_dest.entityFinishConditions.nrOfErrors)){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "nrOfErrors",
                      "entity finish condition",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].nrOfErrors),
                      log2str( pl_dest.entityFinishConditions.nrOfErrors))
                  }
                  pl_dest.entityFinishConditions.nrOfErrors := pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].nrOfErrors
                }
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].nrOfTimeouts)){
                  if(ispresent(pl_dest.entityFinishConditions.nrOfTimeouts)){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "nrOfTimeouts",
                      "entity finish condition",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].nrOfTimeouts),
                      log2str( pl_dest.entityFinishConditions.nrOfTimeouts))
                  }
                  pl_dest.entityFinishConditions.nrOfTimeouts := pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].nrOfTimeouts
                }
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].nrOfSuccesses)){
                  if(ispresent(pl_dest.entityFinishConditions.nrOfSuccesses)){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "nrOfSuccesses",
                      "entity finish condition",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].nrOfSuccesses),
                      log2str( pl_dest.entityFinishConditions.nrOfSuccesses))
                  }
                  pl_dest.entityFinishConditions.nrOfSuccesses := pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].nrOfSuccesses
                }
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].customFinishCondition)){
                  if(ispresent(pl_dest.entityFinishConditions.customFinishCondition) and 
                    "" != pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].customFinishCondition){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "customFinishCondition",
                      "entity finish condition",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].customFinishCondition),
                      log2str( pl_dest.entityFinishConditions.customFinishCondition))
                  }else{
                    pl_dest.entityFinishConditions.customFinishCondition := pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond].customFinishCondition
                  }
                }
                case else
                {
                  if (c_EPTF_Common_debugSwitch){
                    f_EPTF_Base_assert(%definitionId&": Invalid entity finish condition type: "&
                      log2str( pl_tcDecl.tcParamsList[vl_i].entityFinishConditions[vl_eCond]),false);
                  }
                }
              }
            }
          }
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].entityFinishActions)){
            if(vl_entityFinishActions){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "entityFinishActions",
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].entityFinishActions),
                log2str( pl_dest.entityFinishActions))
            }
            pl_dest.entityFinishActions := pl_tcDecl.tcParamsList[vl_i].entityFinishActions
            vl_entityFinishActions := true
          }
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].trafficStartFinish)){
            if(vl_trafficStartFinish){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "trafficStartFinish",
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].trafficStartFinish),
                log2str( pl_dest.trafficStartFinishConditionsAndActions))
            }
            for ( var integer vl_tf := 0; vl_tf < sizeof(pl_tcDecl.tcParamsList[vl_i].trafficStartFinish); vl_tf := vl_tf+1 ){
              select( true ){
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].customFinish) ){
                  if(ispresent(pl_dest.trafficStartFinishConditionsAndActions.customFinish)){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "customFinish",
                      "trafficStartFinish",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].customFinish),
                      log2str( pl_dest.trafficStartFinishConditionsAndActions.customFinish))
                  }
                  pl_dest.trafficStartFinishConditionsAndActions.customFinish := pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].customFinish
                }
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].entitiesFinished) ){
                  if(ispresent(pl_dest.trafficStartFinishConditionsAndActions.entitiesFinished)){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "entitiesFinished",
                      "trafficStartFinish",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].entitiesFinished),
                      log2str( pl_dest.trafficStartFinishConditionsAndActions.entitiesFinished))
                  }
                  pl_dest.trafficStartFinishConditionsAndActions.entitiesFinished := pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].entitiesFinished
                }
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].availableEntitiesFinished) ){
                  if(ispresent(pl_dest.trafficStartFinishConditionsAndActions.availableEntitiesFinished)){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "availableEntitiesFinished",
                      "trafficStartFinish",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].availableEntitiesFinished),
                      log2str( pl_dest.trafficStartFinishConditionsAndActions.availableEntitiesFinished))
                  }
                  pl_dest.trafficStartFinishConditionsAndActions.availableEntitiesFinished := pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].availableEntitiesFinished
                }
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].execTime) ){
                  if(ispresent(pl_dest.trafficStartFinishConditionsAndActions.execTime)){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "execTime",
                      "trafficStartFinish",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].execTime),
                      log2str( pl_dest.trafficStartFinishConditionsAndActions.execTime))
                  }
                  pl_dest.trafficStartFinishConditionsAndActions.execTime := pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].execTime
                }
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfExecStart) ){
                  if(ispresent(pl_dest.trafficStartFinishConditionsAndActions.nrOfExecStart)){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "nrOfExecStart",
                      "trafficStartFinish",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfExecStart),
                      log2str( pl_dest.trafficStartFinishConditionsAndActions.nrOfExecStart))
                  }
                  pl_dest.trafficStartFinishConditionsAndActions.nrOfExecStart := pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfExecStart
                }
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfFails) ){
                  if(ispresent(pl_dest.trafficStartFinishConditionsAndActions.nrOfFails)){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "nrOfFails",
                      "trafficStartFinish",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfFails),
                      log2str( pl_dest.trafficStartFinishConditionsAndActions.nrOfFails))
                  }
                  pl_dest.trafficStartFinishConditionsAndActions.nrOfFails := pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfFails
                }
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfErrors) ){
                  if(ispresent(pl_dest.trafficStartFinishConditionsAndActions.nrOfErrors)){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "nrOfErrors",
                      "trafficStartFinish",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfErrors),
                      log2str( pl_dest.trafficStartFinishConditionsAndActions.nrOfErrors))
                  }
                  pl_dest.trafficStartFinishConditionsAndActions.nrOfErrors := pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfErrors
                }
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfTimeouts) ){
                  if(ispresent(pl_dest.trafficStartFinishConditionsAndActions.nrOfTimeouts)){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "nrOfTimeouts",
                      "trafficStartFinish",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfTimeouts),
                      log2str( pl_dest.trafficStartFinishConditionsAndActions.nrOfTimeouts))
                  }
                  pl_dest.trafficStartFinishConditionsAndActions.nrOfTimeouts := pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfTimeouts
                }
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfRangeLoop) ){
                  if(ispresent(pl_dest.trafficStartFinishConditionsAndActions.nrOfRangeLoop)){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "nrOfRangeLoop",
                      "trafficStartFinish",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfRangeLoop),
                      log2str( pl_dest.trafficStartFinishConditionsAndActions.nrOfRangeLoop))
                  }
                  pl_dest.trafficStartFinishConditionsAndActions.nrOfRangeLoop := pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfRangeLoop
                }
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfSuccesses) ){
                  if(ispresent(pl_dest.trafficStartFinishConditionsAndActions.nrOfSuccesses)){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "nrOfSuccesses",
                      "trafficStartFinish",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfSuccesses),
                      log2str( pl_dest.trafficStartFinishConditionsAndActions.nrOfSuccesses))
                  }
                  pl_dest.trafficStartFinishConditionsAndActions.nrOfSuccesses := pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].nrOfSuccesses
                }
                case ( ischosen(pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].anythingFinished) ){
                  if(ispresent(pl_dest.trafficStartFinishConditionsAndActions.anythingFinished)){
                    f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
                      %definitionId,
                      "anythingFinished",
                      "trafficStartFinish",
                      pl_tcDecl.tcName,
                      pl_scName,
                      log2str( pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].anythingFinished),
                      log2str( pl_dest.trafficStartFinishConditionsAndActions.anythingFinished))
                  }
                  pl_dest.trafficStartFinishConditionsAndActions.anythingFinished := pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf].anythingFinished
                }
                case else{
                  if (c_EPTF_Common_debugSwitch){
                    f_EPTF_Base_assert(%definitionId&": Invalid trafficStartFinish condition type: "&
                      log2str( pl_tcDecl.tcParamsList[vl_i].trafficStartFinish[vl_tf]),false);
                  }
                }
              }
            }          
          }
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].trafficFinishedActions)){
            if(vl_trafficFinishedActions){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "trafficFinishedActions",
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].trafficFinishedActions),
                log2str( pl_dest.trafficFinishedActions))
            }
            pl_dest.trafficFinishedActions := pl_tcDecl.tcParamsList[vl_i].trafficFinishedActions
            vl_trafficFinishedActions := true
          }
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].templateSet)){
            if(vl_templateSet){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "templateSet",
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].templateSet),
                log2str( pl_dest.templateSet))
            }
            pl_dest.templateSet := pl_tcDecl.tcParamsList[vl_i].templateSet
            vl_templateSet := true
          }
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].fsmList)){
            if(vl_fsmList){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "fsmList", 
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].fsmList),
                log2str( pl_dest.fsmList))
            }
            var integer vl_initialSize := sizeof(pl_dest.fsmList);
            for ( var integer vl_fsm := 0; vl_fsm < sizeof(pl_tcDecl.tcParamsList[vl_i].fsmList) ; vl_fsm := vl_fsm+1 ){
              pl_dest.fsmList[vl_fsm+vl_initialSize] := c_EPTF_LGenBase_emptyTcTypeFSM;
              pl_dest.fsmList[vl_fsm+vl_initialSize].fsmName := pl_tcDecl.tcParamsList[vl_i].fsmList[vl_fsm]
              pl_dest.fsmList[vl_fsm+vl_initialSize].siblingName := pl_tcDecl.tcParamsList[vl_i].fsmList[vl_fsm]
            }
            vl_fsmList := true;
          }
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].siblingFsmList)){
            if(vl_siblingFsmList){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "siblingFsmList", 
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].siblingFsmList),
                log2str( pl_dest.fsmList))
            }
            var integer vl_initialSize := sizeof(pl_dest.fsmList);
            for ( var integer vl_fsm := 0; vl_fsm < sizeof(pl_tcDecl.tcParamsList[vl_i].siblingFsmList) ; vl_fsm := vl_fsm+1 ){
              pl_dest.fsmList[vl_fsm+vl_initialSize] := c_EPTF_LGenBase_emptyTcTypeFSM;
              pl_dest.fsmList[vl_fsm+vl_initialSize].fsmName := pl_tcDecl.tcParamsList[vl_i].siblingFsmList[vl_fsm].fsmType
              pl_dest.fsmList[vl_fsm+vl_initialSize].siblingName := pl_tcDecl.tcParamsList[vl_i].siblingFsmList[vl_fsm].siblingName
            }
            vl_siblingFsmList := true;
          }
          case(ischosen(pl_tcDecl.tcParamsList[vl_i].customEntitySucc)){
            if(vl_customEntitySucc){
              f_EPTF_LGenBase_logDuplicatedDef(
                %definitionId,
                "customEntitySucc", 
                pl_tcDecl.tcName,
                pl_scName,
                log2str( pl_tcDecl.tcParamsList[vl_i].customEntitySucc),
                log2str( pl_dest.customEntitySucc))
            }
            pl_dest.customEntitySucc := pl_tcDecl.tcParamsList[vl_i].customEntitySucc
            vl_customEntitySucc := true;
          }
          case else{
            f_EPTF_Base_assert(%definitionId&": Invalid TC of scenario parameter type: "&log2str(pl_tcDecl.tcParamsList[vl_i]),false)
          }
        }
      }
      if("" == pl_dest.tcTypeName and 0 == sizeof(pl_dest.fsmList)){
        pl_dest.tcTypeName := pl_tcDecl.tcName
      }
    }
    
  } // group trafficDeclarators
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getCustomFinishConditionFunctionRef
  // 
  //  Purpose:
  //    Finds the function reference of the specified 
  //    <EPTF_LGenBase_customFinishCondition_FT>-type function, and
  //    retrieves it if found.
  ///////////////////////////////////////////////////////////
  private function f_EPTF_LGenBase_getCustomFinishConditionFunctionRef(
    in charstring pl_fnName,
    inout EPTF_LGenBase_customFinishCondition_FT pl_ret)
  runs on EPTF_LGenBase_Private_CT{
    if("" != pl_fnName){
      var integer vl_fnIdx := f_EPTF_LGenBase_functionNameIndex(pl_fnName)
      if(-1 == vl_fnIdx){
        f_EPTF_LGenBase_loggingError(%definitionId&": Invalid custom entity finish condition funcion name: "&pl_fnName)
      }
      if(ischosen(v_LGenBase_functions[vl_fnIdx].customFinishCondition)){
        pl_ret := v_LGenBase_functions[vl_fnIdx].customFinishCondition
      }else{
        f_EPTF_LGenBase_loggingError(%definitionId&": Invalid funcion type for custom entity finish condition "&pl_fnName)
      } 
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareTrafficCaseType
  // 
  //  Purpose:
  //    Processes a <EPTF_LGenBase_TrafficCaseTypeDeclarator> pl_tcType and
  //    declares the traffic case type
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_declareTrafficCaseType(in EPTF_LGenBase_TrafficCaseTypeDeclarator pl_tcType)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var EPTF_LGenBase_TrafficCaseTypeInternalDeclarator vl_tcType := c_EPTF_LGenBase_emptyTrafficCaseTypeInternalDeclarator;
    vl_tcType.name := pl_tcType.name;
    vl_tcType.fsmName := pl_tcType.fsmName;
    vl_tcType.entityType := pl_tcType.entityType;
    for ( var integer vl_i := 0; vl_i < sizeof(pl_tcType.tcParams) ; vl_i := vl_i+1 ){
      if(ischosen(pl_tcType.tcParams[vl_i].customEntitySucc)){
        vl_tcType.customEntitySucc := pl_tcType.tcParams[vl_i].customEntitySucc
      }
    }
    return f_EPTF_LGenBase_declareTrafficCaseTypeInternal(vl_tcType)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareScenarioType3
  // 
  //  Purpose:
  //    Creates a traffic case scenario for TitanSim R3.
  // 
  //  Detailed Comments:
  //    This is a TitanSim R3 scenario declaration function. It registers one scenario. The scenario can be normal or weighted.   
  //    A scenario is a collection of traffic cases.
  //    See <f_EPTF_LGenBase_validateScenarioType>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_declareScenarioType3(in EPTF_LGenBase_ScenarioTypeDeclarator pl_scenario)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var EPTF_LGenBase_ScenarioTypeInternalDeclarator vl_scInternalType;
    f_EPTF_LGenBase_convertScenarioTypeDeclarator2Internal(pl_scenario, vl_scInternalType)
    if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
      f_EPTF_LGenBase_loggingDebugConfig(%definitionId&": The converted scenario declarator: "&log2str(vl_scInternalType))
      for ( var integer vl_tc := 0; vl_tc < sizeof(vl_scInternalType.tcList) ; vl_tc := vl_tc+1 ){
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
          f_EPTF_LGenBase_loggingDebugConfig(%definitionId&": The converted traffic case declarator: "&log2str(vl_scInternalType.tcList[vl_tc]))
        }
      }
    }
    return f_EPTF_LGenBase_declareScenarioTypeInternal(vl_scInternalType);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_createEntityGroup
  // 
  //  Purpose:
  //    Initializes an entity group
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_createEntityGroup( EPTF_LGenBase_EntityGrpDeclarator pl_grpDesc )
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": The entity group name mustn't be empty.","" != pl_grpDesc.name); 
    f_EPTF_Base_assert(%definitionId&": The entity type name mustn't be empty.","" != pl_grpDesc.eType); 
    f_EPTF_Base_assert(%definitionId&": The entity group "&pl_grpDesc.name&" already exists.",-1 == f_EPTF_LGenBase_entityGrpNameIndex(pl_grpDesc.name));
    var integer vl_eTypeIdx := f_EPTF_LGenBase_entityTypeNameIndex(pl_grpDesc.eType);
    f_EPTF_Base_assert(%definitionId&": Invalid entity type "&pl_grpDesc.eType, -1 != vl_eTypeIdx);
    f_EPTF_Base_assert(%definitionId&": Invalid count of entities: "&int2str(pl_grpDesc.eCount),0 <= pl_grpDesc.eCount);
    //Create entities --
    var integer vl_eOffset := sizeof(v_LGenBase_entities); //entity index of first member
    //Check maximal capacity of behaviors
    var integer vl_maxCount := f_EPTF_LGenBase_getETypeAvailableByIdx(vl_eTypeIdx);
    if(0 > vl_maxCount or vl_maxCount > pl_grpDesc.eCount){
      vl_maxCount := pl_grpDesc.eCount;
    }
    var integer vl_ret := sizeof(v_LGenBase_entityGroups);
    //Create entities in the list of LGenBase
    f_EPTF_LGenBase_initEntityCtxs(vl_eOffset, vl_maxCount, /*v_LGenBase_entityNamePrefix,*/vl_ret);
    
    //Call behavior context binding for all the entities
    var integer vl_behavCount := sizeof(v_LGenBase_entityTypes[vl_eTypeIdx].behaviorTypeIdxList);
    for(var integer vl_behav := 0; vl_behav < vl_behavCount; vl_behav := vl_behav + 1){
      for(var integer vl_entityRelIdx := 0; vl_entityRelIdx < vl_maxCount; vl_entityRelIdx := vl_entityRelIdx + 1){
        var EPTF_IntegerList vl_bCtx := {}; 
        if(null != v_LGenBase_behaviorTypes[v_LGenBase_entityTypes[vl_eTypeIdx].behaviorTypeIdxList[vl_behav]].contextBindFn){
          vl_bCtx := v_LGenBase_behaviorTypes[v_LGenBase_entityTypes[vl_eTypeIdx].behaviorTypeIdxList[vl_behav]].contextBindFn.apply( vl_entityRelIdx );
        }
        if(null != v_LGenBase_behaviorTypes[v_LGenBase_entityTypes[vl_eTypeIdx].behaviorTypeIdxList[vl_behav]].contextBindWithAbsIdxFn){
          vl_bCtx := v_LGenBase_behaviorTypes[v_LGenBase_entityTypes[vl_eTypeIdx].behaviorTypeIdxList[vl_behav]].contextBindWithAbsIdxFn.apply( vl_entityRelIdx+vl_eOffset );
        }
        v_LGenBase_entities[vl_entityRelIdx+vl_eOffset].bCtxList[v_LGenBase_entityTypes[vl_eTypeIdx].behaviorTypeIdxList[vl_behav]]:=vl_bCtx;
      }
      v_LGenBase_behaviorTypes[v_LGenBase_entityTypes[vl_eTypeIdx].behaviorTypeIdxList[vl_behav]].bCurrCount :=
      v_LGenBase_behaviorTypes[v_LGenBase_entityTypes[vl_eTypeIdx].behaviorTypeIdxList[vl_behav]].bCurrCount + vl_maxCount;
    }
    v_LGenBase_entityTypes[vl_eTypeIdx].currCount := v_LGenBase_entityTypes[vl_eTypeIdx].currCount + vl_maxCount;
    //Create entity group
    v_LGenBase_entityGroups[vl_ret] := c_EPTF_LGenBase_emptyEntityGroup
    v_LGenBase_entityGroups[vl_ret].name := pl_grpDesc.name
    v_LGenBase_entityGroups[vl_ret].eTypeIdx := vl_eTypeIdx
    v_LGenBase_entityGroups[vl_ret].eOffset := vl_eOffset
    v_LGenBase_entityGroups[vl_ret].eCount := vl_maxCount
    for (var integer x:= 0; x<sizeof(v_LGenBase_entityGroupCreated); x:= x+1)
    {
      v_LGenBase_entityGroupCreated[x].apply( vl_ret );
    }
    return vl_maxCount;
  }//f_EPTF_LGenBase_createEntityGroup
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setTrafficCorrigationForEGrp
  // 
  //  Purpose:
  //    Sets the traffic corrigation factor of an entity group
  //    This is used to delay traffic generation
  //    event on different LGens differently
  //    Also the initial burst error is set differently on
  //    different LGens.
  //    Traffic start event is delayed with pl_trafficCorrigation/targetCPS seconds.
  //    The initial burst error is set to pl_trafficCorrigation.
  //    This function is used by ExecCtrl only.
  ///////////////////////////////////////////////////////////
  friend function f_EPTF_LGenBase_setTrafficCorrigationForEGrp(
    in charstring pl_grpName,
    in float pl_trafficCorrigation  // this is the corrigation factor for traffic start and initial burst error
  )
  runs on EPTF_LGenBase_Private_CT {
    var integer vl_grpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_grpName);
    f_EPTF_Base_assert(%definitionId&": The entity group "&pl_grpName&" does not exists.",-1 != vl_grpIdx);
    f_EPTF_Base_assert(%definitionId&": Invalid traffic corrigation factor "&float2str(pl_trafficCorrigation)& " for entity group "&pl_grpName,
      0.0 <= pl_trafficCorrigation and pl_trafficCorrigation < 1.0);
    
    v_LGenBase_entityGroups[vl_grpIdx].trafficCorrigation := pl_trafficCorrigation
  }//f_EPTF_LGenBase_createEntityGroup
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_removeEntityGroup
  // 
  //  Purpose:
  //    Removes an entity group and cleans it up
  // 
  //  Detailed Comments:
  //    Calls the <f_EPTF_LGenBase_removeEntityGroupByIdx>  function
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_removeEntityGroup(
    in charstring pl_name //name of the group
  )
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_grpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_name);
    f_EPTF_Base_assert(%definitionId&": Invalid entity group name: "&pl_name,-1 != vl_grpIdx);
    f_EPTF_LGenBase_removeEntityGroupByIdx(vl_grpIdx);
  }//f_EPTF_LGenBase_removeEntityGroup
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_removeEntityGroupByIdx
  // 
  //  Purpose:
  //    Removes an entity group and cleans it up
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_removeEntityGroupByIdx(
    in integer pl_grpIdx //name of the group
  )
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_LGenBase_clearEntityGroup(pl_grpIdx, v_LGenBase_entityGroups[pl_grpIdx])
    v_LGenBase_entityGroups[pl_grpIdx] := cEPTF_LGenBase_emptyEntityGroup
  }
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_removeEntityGroupByIdx
  // 
  //  Purpose:
  //    Removes an entity group and cleans it up
  ///////////////////////////////////////////////////////////
  private function f_EPTF_LGenBase_clearEntityGroup(
    in integer pl_eGrpIdx,
    in EPTF_LGenBase_EntityGroup pl_eGrp 
  )
  runs on EPTF_LGenBase_Private_CT{
    for(var integer vl_sc := 0; vl_sc < sizeof(pl_eGrp.scenarios); vl_sc := vl_sc + 1){
      f_EPTF_LGenBase_removeScenario(pl_eGrpIdx, vl_sc)
    }
    
    //Call behavior context unbind for all the entities
    var integer vl_eTypeIdx := pl_eGrp.eTypeIdx;
    var integer vl_behavCount := sizeof(v_LGenBase_entityTypes[vl_eTypeIdx].behaviorTypeIdxList);
    var integer vl_eCount := pl_eGrp.eCount;
    var integer vl_eOffset := pl_eGrp.eOffset;
    for(var integer vl_behav := 0; vl_behav < vl_behavCount; vl_behav := vl_behav + 1){
      for(var integer vl_entity := vl_eOffset; vl_entity < vl_eOffset + vl_eCount; vl_entity := vl_entity + 1){
        if(null != v_LGenBase_behaviorTypes[v_LGenBase_entityTypes[vl_eTypeIdx].behaviorTypeIdxList[vl_behav]].contextUnbindFn){
          v_LGenBase_behaviorTypes[v_LGenBase_entityTypes[vl_eTypeIdx].behaviorTypeIdxList[vl_behav]].contextUnbindFn.apply( vl_entity );
        }
        //v_LGenBase_entities[vl_entity].bCtxList[vl_behav] := {};
      }
      v_LGenBase_behaviorTypes[v_LGenBase_entityTypes[vl_eTypeIdx].behaviorTypeIdxList[vl_behav]].bCurrCount :=
      v_LGenBase_behaviorTypes[v_LGenBase_entityTypes[vl_eTypeIdx].behaviorTypeIdxList[vl_behav]].bCurrCount - vl_eCount;
    }
    //Remove entities
    for (var integer vl_i := vl_eOffset + vl_eCount - 1; vl_i>=vl_eOffset; vl_i:=vl_i-1) {
      //Deactivate pending FSMs
      for ( var integer vl_fsm := 0; vl_fsm < sizeof(v_LGenBase_entities[vl_i].fsmCtxList) ; vl_fsm := vl_fsm+1 ){
        if (-1 < v_LGenBase_entities[vl_i].fsmCtxList[vl_fsm].tableIdx){
          f_EPTF_LGenBase_deactivateFsm(vl_i, vl_fsm)
        }
      }
      
      // TODO: the v_LGenBase_entities[vl_i].fsmCtxQueue FBQ should be removed also
      v_LGenBase_entities[vl_i] := c_empty_LGenBase_EntityCtx; 
    }
    v_LGenBase_entityTypes[pl_eGrp.eTypeIdx].currCount :=
    v_LGenBase_entityTypes[pl_eGrp.eTypeIdx].currCount - vl_eCount; 
  }//f_EPTF_LGenBase_removeEntityGroupByIdx
  
  private function f_EPTF_LGenBase_removeTC(
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_eGrpIdx := v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref
    var integer vl_scIdx := v_LGenBase_trafficCases[pl_tcIdx].eScenarioBackRef
    var integer vl_tcRelIdx := v_LGenBase_trafficCases[pl_tcIdx].eTcRelIdx
    v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].tcIdxList[vl_tcRelIdx] := -1
    if ( -1 < v_LGenBase_trafficCases[pl_tcIdx].stopTimeoutTimer )
    {
      if(not f_EPTF_SchedulerComp_CancelEvent(v_LGenBase_trafficCases[pl_tcIdx].stopTimeoutTimer)) {
        f_EPTF_LGenBase_loggingWarning(%definitionId&": Cancelling stop timeout timer of TC "&
          v_LGenBase_trafficCases[pl_tcIdx].uniqueName&" failed.");
      }
      v_LGenBase_trafficCases[pl_tcIdx].stopTimeoutTimer := -1;
      f_EPTF_LGenBase_logNotRespondedEntities(pl_tcIdx, "stop or abort")
    }
    if(-1 != v_LGenBase_trafficCases[pl_tcIdx].schedulingTimer){
      if(not f_EPTF_SchedulerComp_CancelEvent(v_LGenBase_trafficCases[pl_tcIdx].schedulingTimer)) {
        f_EPTF_LGenBase_loggingWarning(%definitionId&": Cancelling scheduled timer of running TC "&
          v_LGenBase_trafficCases[pl_tcIdx].uniqueName&" failed.");
      }
      v_LGenBase_trafficCases[pl_tcIdx].schedulingTimer := -1;
    }
    if ( -1 != v_LGenBase_trafficCases[pl_tcIdx].execTimeTimer )
    {
      if(not f_EPTF_SchedulerComp_CancelEvent(v_LGenBase_trafficCases[pl_tcIdx].execTimeTimer)) {
        f_EPTF_LGenBase_loggingWarning(%definitionId&": Cancelling exec time expiration timer of TC "&
          v_LGenBase_trafficCases[pl_tcIdx].uniqueName&" failed.");
      }
      v_LGenBase_trafficCases[pl_tcIdx].execTimeTimer := -1;
    }
    
    f_EPTF_str2int_HashMap_Delete(v_LGenBase_trafficCases[pl_tcIdx].uniqueName&c_EPTF_LGenBase_tcParamsHasmapPostfix);
    //??EPTF_LGenBase_SchedulerData schedulerData, //burst calc functions, lastBurstSize, burstSizeCumulativeError 
    
    //If the creation of objects with TC scope moved to createTC
    //EPTF_IntegerList varList,
    //EPTF_IntegerList statisticList,
    //EPTF_IntegerList statMeasStatList
    
    //TODO Log running entities? EPTF_LGenBase_EntityInfo entityInfo, // if entity is free then ready for TC start
    //TODO ??integer templateSetIdx,  // -1 if doesn't exist
    /*
    for ( var integer vl_stat := 0; vl_stat < sizeof(v_LGenBase_trafficCases[pl_tcIdx].statHandlerStatList) ; vl_stat := vl_stat+1 )
    {
      var charstring vl_statName := f_EPTF_LGenBase_varNameOfTCVar(pl_tcIdx, v_LGenBase_trafficCases[pl_tcIdx].statHandlerStatList[vl_stat].statName)
      f_EPTF_StatHandlerClient_deregisterStat(
        pl_statName := vl_statName,
        pl_sourceCompRef := self,
        pl_statHandler := self
      )
    }
    
    for ( var integer vl_stat := 0; vl_stat < sizeof(v_LGenBase_trafficCases[pl_tcIdx].siblingStatHandlerStatList) ; vl_stat := vl_stat+1 ){
      for ( var integer vl_e := 0; vl_e < sizeof(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList) ; vl_e := vl_e+1 ){
        var charstring vl_statName := f_EPTF_LGenBase_varNameOfSiblingFSMsVar(
          pl_tcIdx,
          vl_e,
          v_LGenBase_trafficCases[pl_tcIdx].siblingStatHandlerStatList[vl_stat].statName)
        f_EPTF_StatHandlerClient_deregisterStat(
          pl_statName := vl_statName,
          pl_sourceCompRef := self,
          pl_statHandler := self
        )
      }
    }
    */
    // if not in cleanup:
    if (f_EPTF_Base_cleanupIsInProgress()==true) {
      //TC Variables
      for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_trafficCases[pl_tcIdx].varList) ; vl_i := vl_i+1 ){
        f_EPTF_Var_removeVar(v_LGenBase_trafficCases[pl_tcIdx].varList[vl_i].varId)
      }
    }
    //v_LGenBase_trafficCases[pl_tcIdx].statMeasStatList
    //
    
    //Deactivate FSMs
    for ( var integer vl_e := 0; vl_e < v_LGenBase_entityGroups[vl_eGrpIdx].eCount ; vl_e := vl_e+1 ){
      for ( var integer vl_fsm := 0; vl_fsm < sizeof(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[vl_e].siblingFsmCtxList) ; vl_fsm := vl_fsm+1 ){
        var integer vl_fsmCtxIdx := v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[vl_e].siblingFsmCtxList[vl_fsm]
        f_EPTF_LGenBase_deactivateFsm(v_LGenBase_entityGroups[vl_eGrpIdx].eOffset+vl_e, vl_fsmCtxIdx);
      }
    }
    v_LGenBase_trafficCases[pl_tcIdx] := c_EPTF_LGenBase_TcMgmt_emptytcDescriptor
    
  }
  private function f_EPTF_LGenBase_removeScenario(
    in integer pl_eGrpIdx,
    in integer pl_scReldx)
  runs on EPTF_LGenBase_Private_CT{
    if(ispresent(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scReldx].schedulerData) and
      -1 < v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scReldx].schedulerData.schedulingTimer){
      if(not f_EPTF_SchedulerComp_CancelEvent(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scReldx].schedulerData.schedulingTimer)){
        f_EPTF_LGenBase_loggingWarning(%definitionId&": Cancelling sceduled timer of scenario "&
          v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scReldx].uniqueName&
          " failed.");
      }
      v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scReldx].schedulerData.schedulingTimer := -1;
    }
    for ( var integer vl_tc := 0; vl_tc < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scReldx].tcIdxList) ; vl_tc := vl_tc+1 ){
      var integer vl_tcAbsIdx := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scReldx].tcIdxList[vl_tc]
      f_EPTF_LGenBase_removeTC(vl_tcAbsIdx)
    }
  } 
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_logNotRespondedEntities
  //
  //  Purpose:
  //    Logs the entities which didn't respond to the stop event.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_logNotRespondedEntities(
    in integer pl_tcIdx,
    in charstring pl_stopOrAbort)
  runs on EPTF_LGenBase_Private_CT{
    if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
      var charstring vl_entityList := %definitionId&": There are entities not responded to the "&pl_stopOrAbort&" event:"
      var integer vl_e := -1
      var boolean vl_found := f_EPTF_FBQ_getBusyHeadIdx(vl_e, v_LGenBase_trafficCases[pl_tcIdx].stoppingEntityInfo)
      while(vl_found){
        vl_entityList := vl_entityList&"\n" & f_EPTF_LGenBase_getEntityName(vl_e)
        vl_found := f_EPTF_FBQ_getFwdBusyItemIdx(vl_e, v_LGenBase_trafficCases[pl_tcIdx].stoppingEntityInfo)
      }
      f_EPTF_LGenBase_loggingDebugTraffic(vl_entityList)
    }
  }  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_addFsmDebugPostproc
  //
  //  Purpose:
  //    Registers a postproc function to attach when an FSM debug variable created
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_addFsmDebugPostproc(in EPTF_Var_GenericFn pl_postproc)
  runs on EPTF_LGenBase_Private_CT return integer
  {
    var integer i:= sizeof(v_LGenBase_fsmDebugPostprocList);
    v_LGenBase_fsmDebugPostprocList[i] := pl_postproc
    return i;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_removeFsmDebugPostproc
  //
  //  Purpose:
  //    Removes a postproc function added by the <f_EPTF_LGenBase_addFsmDebugPostproc>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_removeFsmDebugPostproc(in integer pl_idx) runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Error: attempting to delete FSM debug postproc at invalid idx:" & int2str(pl_idx), pl_idx>-1 and pl_idx<sizeof(v_LGenBase_fsmDebugPostprocList));
    
    var EPTF_Var_GenericFns vl_list := v_LGenBase_fsmDebugPostprocList;
    var integer i;
    
    v_LGenBase_fsmDebugPostprocList:= {};
    for (i:=0; i<pl_idx; i:= i+1)  {
      v_LGenBase_fsmDebugPostprocList[i] := vl_list[i];
    }
    
    for (i:=pl_idx; i<sizeof(vl_list)-1; i:= i+1)  {
      v_LGenBase_fsmDebugPostprocList[i] := vl_list[i+1];
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_addSingleShotDebugPostproc
  //
  //  Purpose:
  //    Registers a postproc function to attach when an FSM debug variable created
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_addSingleShotDebugPostproc(in EPTF_Var_GenericFn pl_postproc)
  runs on EPTF_LGenBase_Private_CT return integer
  {
    var integer i:= sizeof(v_LGenBase_singleShotDebugPostprocList);
    v_LGenBase_singleShotDebugPostprocList[i] := pl_postproc
    return i;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_removeSingleShotDebugPostproc
  //
  //  Purpose:
  //    Removes a postproc function added by the <f_EPTF_LGenBase_addSingleShotDebugPostproc>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_removeSingleShotDebugPostproc(in integer pl_idx) runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Error: attempting to delete SingleShot debug postproc at invalid idx:" & int2str(pl_idx), pl_idx>-1 and pl_idx<sizeof(v_LGenBase_singleShotDebugPostprocList));
    
    var EPTF_Var_GenericFns vl_list := v_LGenBase_singleShotDebugPostprocList;
    var integer i;
    
    v_LGenBase_singleShotDebugPostprocList:= {};
    for (i:=0; i<pl_idx; i:= i+1)  {
      v_LGenBase_singleShotDebugPostprocList[i] := vl_list[i];
    }
    
    for (i:=pl_idx; i<sizeof(vl_list)-1; i:= i+1)  {
      v_LGenBase_singleShotDebugPostprocList[i] := vl_list[i+1];
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_addFsmDefaultDebugPostproc
  //
  //  Purpose:
  //    Adds a postproc function to the default FSM debug variable
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_addFsmDefaultDebugPostproc(in EPTF_Var_GenericFn pl_postproc)
  runs on EPTF_LGenBase_Private_CT
  {
    f_EPTF_Var_addPostProcFn(v_LGenBase_defaultLogBuffer, pl_postproc)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_removeFsmDefaultDebugPostproc
  //
  //  Purpose:
  //    Removes a postproc function added by the <f_EPTF_LGenBase_addFsmDefaultDebugPostproc>
  //    from the default FSM debug variable
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_removeFsmDefaultDebugPostproc(in EPTF_Var_GenericFn pl_postproc)
  runs on EPTF_LGenBase_Private_CT
  {
    f_EPTF_Var_removePostProcFn(v_LGenBase_defaultLogBuffer, pl_postproc)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareFunction
  // 
  //  Purpose:
  //    Registers the reference of the function with the specified name 
  //
  //  Parameters:
  //    pl_name - *in* *charstring* - the name of the newly registered function
  //    pl_fn - *in* <EPTF_LGenBase_RegisteredFunctions> - the type and function reference  
  //
  //  Return Value:
  //    *integer* - The index of the registered function
  //   
  //  Detailed Comments:
  //    The custom finish condition and action functions of
  //    <EPTF_LGenBase_TcMgmt_GroupFinishConditions>, 
  //    <EPTF_LGenBase_TcMgmt_EntityFinishConditions>, 
  //    <EPTF_LGenBase_TcMgmt_GroupActions>, 
  //    <EPTF_LGenBase_TcMgmt_EntityActions> and the 
  //    customEntitySucc of the <EPTF_LGenBase_tcTypeDeclarator>
  //    can refer to these functions.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_declareFunction(
    in charstring pl_name,
    in EPTF_LGenBase_RegisteredFunctions pl_fn 
  )
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var integer vl_ret;
    if(ischosen(pl_fn.testStepFunction)) { // if a testStepFunction is declared
      if(f_EPTF_str2int_HashMap_Find(v_LGenBase_functionHashMap, pl_name, vl_ret)) {
        f_EPTF_LGenBase_loggingWarning(%definitionId&": This test step name is already registered. It should only be declared with f_EPTF_LGenBase_declareStep().");      
        return vl_ret;
      }
    }
    f_EPTF_Base_assert(%definitionId&": The function name "&pl_name&" already exists.",-1 == f_EPTF_LGenBase_functionNameIndex(pl_name));
    vl_ret := sizeof(v_LGenBase_functions);
    v_LGenBase_functions[vl_ret] := pl_fn;
    f_EPTF_str2int_HashMap_Insert(v_LGenBase_functionHashMap,pl_name,vl_ret);
    return vl_ret;
  }//f_EPTF_LGenBase_declareFunction
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareReferredTcList
  // 
  //  Purpose:
  //    Appends traffic case references to the referred traffic case list 
  //    of the specified traffic case.  
  // 
  //  Detailed Comments:
  //    The referred traffic cases must be in the same scenario
  //    of the same entity group, of course
  ///////////////////////////////////////////////////////////
  private function f_EPTF_LGenBase_declareReferredTcList(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName,
    in EPTF_CharstringList pl_referredTcList
  )
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_tcIdx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName);
    var integer vl_base := sizeof(v_LGenBase_trafficCases[vl_tcIdx].referredTrafficCases);
    for ( var integer vl_i := 0; vl_i < sizeof(pl_referredTcList) ; vl_i := vl_i+1 )
    {
      v_LGenBase_trafficCases[vl_tcIdx].referredTrafficCases[vl_base+vl_i] :=
      f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_referredTcList[vl_i]);
    }
    
  }//f_EPTF_LGenBase_declareReferredTcList
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_insertFsmSteps
  // 
  //  Purpose:
  //    Inserts the actions described in the pl_actions
  //    argument into the FSM hookpoints having the name
  //    given in the pl_hookpointName argument
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_insertFsmSteps(
    inout EPTF_LGenBase_FsmTableDeclarator pl_table,
    in charstring pl_hookpointName,
    in EPTF_LGenBase_FsmActionDeclaratorList pl_actions)
  runs on EPTF_LGenBase_Private_CT{
    select( true ){
      //classicTable
      case ( ischosen(pl_table.table.classicTable )){
        for ( var integer vl_i := 0; vl_i < sizeof(pl_table.table.classicTable); vl_i := vl_i+1 ) {
          if(isbound(pl_table.table.classicTable[vl_i].cellRow)) {
            for ( var integer vl_j := 0; vl_j < sizeof(pl_table.table.classicTable[vl_i].cellRow); vl_j := vl_j+1 ) {
              if(ispresent(pl_table.table.classicTable[vl_i].cellRow[vl_j].actionList)) {
                f_EPTF_LGenBase_insertActionList(pl_table.table.classicTable[vl_i].cellRow[vl_j].actionList, pl_actions, pl_hookpointName);
              }
            }
          }
        }
      }
      
      //extendedTable
      case(ischosen(pl_table.table.extendedTable)) {
        for ( var integer vl_i := 0; vl_i < sizeof(pl_table.table.extendedTable); vl_i := vl_i+1 ) {
          select( true ){
            
            //classicCellRow
            case(ischosen(pl_table.table.extendedTable[vl_i].cellRow.classicCellRow)) {
              for ( var integer vl_j := 0; vl_j < sizeof(pl_table.table.extendedTable[vl_i].cellRow.classicCellRow); vl_j := vl_j+1 ) {
                if(ispresent(pl_table.table.extendedTable[vl_i].cellRow.classicCellRow[vl_j].actionList)) {
                  f_EPTF_LGenBase_insertActionList(pl_table.table.extendedTable[vl_i].cellRow.classicCellRow[vl_j].actionList, pl_actions, pl_hookpointName);
                }
              }
            }
            
            //statedCellRow
            case(ischosen(pl_table.table.extendedTable[vl_i].cellRow.statedCellRow)) {
              for ( var integer vl_j := 0; vl_j < sizeof(pl_table.table.extendedTable[vl_i].cellRow.statedCellRow); vl_j := vl_j+1 ) {
                if(ispresent(pl_table.table.extendedTable[vl_i].cellRow.statedCellRow[vl_j].cell.actionList)) {
                  f_EPTF_LGenBase_insertActionList(pl_table.table.extendedTable[vl_i].cellRow.statedCellRow[vl_j].cell.actionList, pl_actions, pl_hookpointName);
                }
              }
            }
            
            //extstatedCellRow
            case(ischosen(pl_table.table.extendedTable[vl_i].cellRow.extStatedCellRow)) {
              for ( var integer vl_j := 0; vl_j < sizeof(pl_table.table.extendedTable[vl_i].cellRow.extStatedCellRow); vl_j := vl_j+1 ) {
                if(ispresent(pl_table.table.extendedTable[vl_i].cellRow.extStatedCellRow[vl_j].cell.actionList)) {
                  f_EPTF_LGenBase_insertActionList(pl_table.table.extendedTable[vl_i].cellRow.extStatedCellRow[vl_j].cell.actionList, pl_actions, pl_hookpointName);
                }
              }
            }         
            case else{
              //Program code inconsitency
              f_EPTF_Base_assert("Error, unknown row type: "&log2str(pl_table.table.extendedTable[vl_i].cellRow),false);
            }
          }   
        }
      }   
      case else{
        //Program code inconsitency
        f_EPTF_Base_assert("Error, unknown table type: "&log2str(pl_table.table),false);
      }
    }
    
  }
  
  //Move the actions after the hookpoint to the end
  //Overwrite the actions from the hookpoint position with the new ones
  private function f_EPTF_LGenBase_insertActionList(
    inout EPTF_LGenBase_FsmActionDeclaratorList pl_orig_actions,
    in EPTF_LGenBase_FsmActionDeclaratorList pl_actions,
    in charstring pl_hookpointName
  )
  runs on EPTF_LGenBase_Private_CT{
    for ( var integer vl_k := 0; vl_k < sizeof(pl_orig_actions); vl_k := vl_k+1 ) {
      if(pl_orig_actions[vl_k].stepOrFunctionName == c_EPTF_LGenBase_stepName_hookpoint and
        pl_orig_actions[vl_k].contextArgs.charstringValue == pl_hookpointName) {
        
        var integer vl_hookSize := sizeof(pl_actions);
        var integer vl_actionListSize := sizeof(pl_orig_actions);
        
        for(var integer vl_l := 0; vl_l < vl_hookSize; vl_l := vl_l+1) {
          pl_orig_actions[vl_actionListSize+vl_l] := pl_actions[vl_l];
        }
        
        //size changed
        vl_actionListSize := sizeof(pl_orig_actions);
        
        for(var integer vl_l := vl_actionListSize-1; vl_l-vl_hookSize >= vl_k; vl_l := vl_l-1) {
          pl_orig_actions[vl_l] := pl_orig_actions[vl_l-vl_hookSize];
        }
        
        var integer vl_hookpointIdx := vl_k + vl_hookSize;
        for(var integer vl_l := 0; vl_l < vl_hookSize; vl_l := vl_l+1) {
          pl_orig_actions[vl_hookpointIdx - vl_hookSize + vl_l] := pl_actions[vl_l];
        }
        vl_k := vl_k + vl_hookSize;
      }
    }
  }  
}//DeclaringMetadata


///////////////////////////////////////////////////////////
// Group: GetSet
//
// Purpose:
//   Functions to manipulate background data 
//
///////////////////////////////////////////////////////////
group GetSet{
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_BurstFuncName2Char
  // 
  //  Purpose:
  //    Convert the predefined burst function names to a charstring value
  //
  //  Parameters:
  //    pl_EPTF_LGenBase_burstFunc - *in* <EPTF_LGenBase_burstFunc> - The type of method of burst calculation
  //
  //  Return Value:
  //    *charstring* - The charstring value
  //
  //  Errors & assertions:
  //    - The method must not be "userDefined".
  //
  //  Detailed Comments:
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_BurstFuncName2Char(
    in EPTF_LGenBase_burstFunc pl_EPTF_LGenBase_burstFunc) 
  runs on EPTF_Base_CT 
  return charstring{
    var charstring vl_name := "";  
    select( pl_EPTF_LGenBase_burstFunc )
    {
      case (terminating)
      {
        vl_name := c_EPTF_LGenBase_BurstCalc_terminating;
      }      
      case (orig)
      {
        vl_name := c_EPTF_LGenBase_BurstCalc_orig;
      }
      case (imst)
      { 
        vl_name := c_EPTF_LGenBase_BurstCalc_imst;
      }
      case (imst2)
      { 
        vl_name := c_EPTF_LGenBase_BurstCalc_imst2;
      }
      case (cs)
      { 
        vl_name := c_EPTF_LGenBase_BurstCalc_cs;
      }
      case (poisson)
      { 
        vl_name := c_EPTF_LGenBase_BurstCalc_poisson;
      }        
      case (userDefined)
      {
        vl_name := c_EPTF_LGenBase_BurstCalc_userDefined;
      }
      case else
      {
        //A bit paranoia.
        f_EPTF_Base_assert(%definitionId&"Unhandled burst management type.",false);
      }
    }//select
    
    return vl_name;  
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_behaviorTypeNameIndex
  // 
  //  Purpose:
  //    Retrieves the index of the behavior type with the specified name.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_behaviorTypeNameIndex(
    in charstring pl_name)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if(""==pl_name){return -1;}
    var integer vl_ret := -1;
    if(f_EPTF_str2int_HashMap_Find(v_LGenBase_behaviorHashMap,pl_name,vl_ret)){
      return vl_ret;
    }
    return -1;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_inputNameIndex
  // 
  //  Purpose:
  //    Retrieves the index of the input with the specified names.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_inputNameIndex(
    in charstring pl_behaviorName,
    in charstring pl_inputName)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if(""==pl_behaviorName or ""==pl_inputName){return -1;}
    var integer vl_ret := -1;
    if(f_EPTF_str2int_HashMap_Find(v_LGenBase_fsmEventsInputHashMap, pl_behaviorName&tsp_LGenBase_nameSeparator&pl_inputName,vl_ret)){
      return vl_ret;
    }
    return -1;
  }
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_functionNameIndex
  // 
  //  Purpose:
  //    Retrieves the index of the function with the specified name.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_functionNameIndex(
    in charstring pl_name)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if(""==pl_name){return -1;}
    var integer vl_ret := -1;
    if(f_EPTF_str2int_HashMap_Find(v_LGenBase_functionHashMap,pl_name,vl_ret)){
      return vl_ret;
    }
    return -1;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_functionReferenceByName
  // 
  //  Purpose:
  //    Retrieves the reference of the function with the specified name.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_functionReferenceByName(
    in charstring pl_name,
    out EPTF_LGenBase_RegisteredFunctions pl_fn)
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    var integer vl_ret := f_EPTF_LGenBase_functionNameIndex(pl_name);
    if (vl_ret == -1){
      return false;
    }
    else
    {
      pl_fn := v_LGenBase_functions[vl_ret];
      return true;
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getETypeIdxOfTcType
  // 
  //  Purpose:
  //    Retrieves the entity type index of a traffic case type
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getETypeIdxOfTcType(
    in integer pl_eTypeIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer
  {
    return v_LGenBase_trafficCaseTypes[pl_eTypeIdx].entityTypeIdx;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getETypeNameOfTcType
  // 
  //  Purpose:
  //    Retrieves the entity type name of a traffic case type
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getETypeNameOfTcType(
    in integer pl_eTypeIdx)
  runs on EPTF_LGenBase_Private_CT
  return charstring
  {
    return v_LGenBase_entityTypes[v_LGenBase_trafficCaseTypes[pl_eTypeIdx].entityTypeIdx].name;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcTypeCount
  // 
  //  Purpose:
  //    Retrieves the number of traffic case types
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTcTypeCount()
  runs on EPTF_LGenBase_Private_CT
  return integer
  {
    return sizeof(v_LGenBase_trafficCaseTypes);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcTypeName
  // 
  //  Purpose:
  //    Retrieves the name of a traffic case type
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTcTypeName(
    in integer pl_tcTypeIdx)
  runs on EPTF_LGenBase_Private_CT
  return charstring
  {
    if(0 <= pl_tcTypeIdx and pl_tcTypeIdx < sizeof(v_LGenBase_trafficCaseTypes)){
      return v_LGenBase_trafficCaseTypes[pl_tcTypeIdx].name;
    }else{
      return ""
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_tcTypeNameIndex
  // 
  //  Purpose:
  //    Retrieves the index of the traffic case type with the specified name.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_tcTypeNameIndex(
    in charstring pl_name)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if(""==pl_name){return -1;}
    var integer vl_size := sizeof(v_LGenBase_trafficCaseTypes);
    for(var integer vl_i := 0; vl_i < vl_size; vl_i := vl_i + 1){
      if(v_LGenBase_trafficCaseTypes[vl_i].name == pl_name){
        return vl_i;
      }
    }
    return -1;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_tcDescNameIndex
  // 
  //  Purpose:
  //    Retrieves the index of the traffic case descriptor with the specified name.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_tcDescNameIndex(
    in charstring pl_name)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if(""==pl_name){return -1;}
    var integer vl_size := sizeof(v_LGenBase_trafficCases);
    for(var integer vl_i := 0; vl_i < vl_size; vl_i := vl_i + 1){
      if(v_LGenBase_trafficCases[vl_i].privateName == pl_name){
        return vl_i;
      }
    }
    return -1;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_tcTypeNameOfTcOfSc
  // 
  //  Purpose:
  //    Retrieves the type name of the traffic case of scenario declarator.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_tcTypeNameOfTcOfSc(
    in EPTF_LGenBase_ScenarioTypeInternalDeclarator pl_sc,
    in integer pl_tcRelIdx)
  runs on EPTF_Base_CT
  return charstring{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcRelIdx),-1 < pl_tcRelIdx and pl_tcRelIdx < sizeof(pl_sc.tcList));
    return pl_sc.tcList[pl_tcRelIdx].tcTypeName;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_tcNameOfTcOfSc
  // 
  //  Purpose:
  //    Retrieves the name of the traffic case of scenario declarator.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_tcNameOfTcOfSc(
    in EPTF_LGenBase_ScenarioTypeInternalDeclarator pl_sc,
    in integer pl_tcRelIdx)
  runs on EPTF_Base_CT
  return charstring{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcRelIdx),-1 < pl_tcRelIdx and pl_tcRelIdx < sizeof(pl_sc.tcList));
    return pl_sc.tcList[pl_tcRelIdx].tcPrivateName;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmNameIndex
  // 
  //  Purpose:
  //    Retrieves the index of the fsm with the specified name.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmNameIndex(
    in charstring pl_name)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if(""==pl_name){return -1;}
    var integer vl_size := sizeof(v_LGenBase_fsmTables);
    for(var integer vl_i := 0; vl_i < vl_size; vl_i := vl_i + 1){
      if(v_LGenBase_fsmTables[vl_i].name == pl_name){
        return vl_i;
      }
    }
    return -1;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_entityGrpNameIndex
  // 
  //  Purpose:
  //    Retrieves the index of the entity group with the specified name.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_entityGrpNameIndex(
    in charstring pl_name)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if(""==pl_name){return -1;}
    var integer vl_size := sizeof(v_LGenBase_entityGroups);
    for(var integer vl_i := 0; vl_i < vl_size; vl_i := vl_i + 1){
      if(v_LGenBase_entityGroups[vl_i].name == pl_name){
        return vl_i;
      }
    }
    return -1;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_entityTypeNameIndex
  // 
  //  Purpose:
  //    Retrieves the index of the entity type with the specified name.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_entityTypeNameIndex(
    in charstring pl_name)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if(""==pl_name){return -1;}
    var integer vl_size := sizeof(v_LGenBase_entityTypes);
    for(var integer vl_i := 0; vl_i < vl_size; vl_i := vl_i + 1){
      if(v_LGenBase_entityTypes[vl_i].name == pl_name){
        return vl_i;
      }
    }
    return -1;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_scenarioNameIndex
  // 
  //  Purpose:
  //    Retrieves the index of the scenario type with the specified name.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_scenarioNameIndex(
    in charstring pl_name)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if(""==pl_name){return -1;}
    var integer vl_size := sizeof(v_LGenBase_scenarioTypes);
    for(var integer vl_i := 0; vl_i < vl_size; vl_i := vl_i + 1){
      if(v_LGenBase_scenarioTypes[vl_i].name == pl_name){
        return vl_i;
      }
    }
    return -1;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_scNameIndexInEG
  // 
  //  Purpose:
  //    Gets the index of the scenario in an entity group
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_scNameIndexInEG(in integer pl_eGrpIdx, in charstring pl_name)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_eGrpIdx),-1 < pl_eGrpIdx and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
    var integer vl_max := sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios);
    for(var integer vl_i := 0; vl_i < vl_max; vl_i := vl_i + 1){
      if(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[vl_i].name == pl_name){
        return vl_i;
      }
    }
    return -1;
  }  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_scNameInEG
  // 
  //  Purpose:
  //    Gets the name of the scenario in an entity group
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_scNameInEG(in integer pl_eGrpIdx, in integer pl_scIdx)
  runs on EPTF_LGenBase_Private_CT
  return charstring {
    f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_eGrpIdx),-1 < pl_eGrpIdx and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
    f_EPTF_Base_assert(%definitionId&": Invalid scenario index within the group: "&int2str(pl_scIdx),-1 < pl_scIdx and pl_scIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios));
    return v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].name;
  }  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_entityTypeIdxOfEG
  // 
  //  Purpose:
  //    Gets the index of the entity type of an entity group
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_entityTypeIdxOfEG(in integer pl_eGrpIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer {
    f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_eGrpIdx),-1 < pl_eGrpIdx and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
    return v_LGenBase_entityGroups[pl_eGrpIdx].eTypeIdx;
  }  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_entityTypeNameOfEG
  // 
  //  Purpose:
  //    Gets the name of the entity type of an entity group
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_entityTypeNameOfEG(in integer pl_eGrpIdx)
  runs on EPTF_LGenBase_Private_CT
  return charstring {
    f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_eGrpIdx),-1 < pl_eGrpIdx and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
    return v_LGenBase_entityTypes[v_LGenBase_entityGroups[pl_eGrpIdx].eTypeIdx].name;
  }  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_tcRelIdx
  // 
  //  Purpose:
  //    Gets the relative index of the traffic case in the scenario
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_tcRelIdx(in integer pl_tcAbsIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var integer vl_eGrpIdx := v_LGenBase_trafficCases[pl_tcAbsIdx].eGroupBackref
    var integer vl_scIdx := v_LGenBase_trafficCases[pl_tcAbsIdx].eScenarioBackRef
    var integer vl_max := sizeof(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].tcIdxList);
    for(var integer vl_i := 0; vl_i < vl_max; vl_i := vl_i + 1){
      if(pl_tcAbsIdx == v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].tcIdxList[vl_i])
      {
        return vl_i;
      }
    }
    return -1;
  }  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_tcOfScenario
  // 
  //  Purpose:
  //    Gets the index of the traffic case in the scenario
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_tcOfScenario(in EPTF_LGenBase_ScenarioOfGrp pl_sc, in charstring pl_name)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var integer vl_max := sizeof(pl_sc.tcIdxList);
    for(var integer vl_i := 0; vl_i < vl_max; vl_i := vl_i + 1){
      if(v_LGenBase_trafficCases[pl_sc.tcIdxList[vl_i]].privateName == pl_name)
      {
        return vl_i;
      }
    }
    return -1;
  }  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_tcNamesOfScenario
  // 
  //  Purpose:
  //    Retrieves the list of the names of the traffic cases of a scenario
  ///////////////////////////////////////////////////////////  
  public function f_EPTF_LGenBase_tcNamesOfScenario(
    in integer pl_eGrpIdx, 
    in integer pl_scIdx,
    out EPTF_CharstringList pl_tcNames)
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_eGrpIdx),-1 < pl_eGrpIdx and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
    f_EPTF_Base_assert(%definitionId&": Invalid scenario index within the group: "&int2str(pl_scIdx),-1 < pl_scIdx and pl_scIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios));
    pl_tcNames := {}
    for ( var integer vl_tc := 0; vl_tc < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList) ; vl_tc := vl_tc+1 )
    {
      pl_tcNames[vl_tc] := v_LGenBase_trafficCases[v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList[vl_tc]].privateName
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_tcUniqueNamesOfScenario
  // 
  //  Purpose:
  //    Retrieves the list of the unique names of the traffic cases of a scenario
  ///////////////////////////////////////////////////////////  
  public function f_EPTF_LGenBase_tcUniqueNamesOfScenario(
    in integer pl_eGrpIdx, 
    in integer pl_scIdx,
    out EPTF_CharstringList pl_tcNames)
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_eGrpIdx),-1 < pl_eGrpIdx and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
    f_EPTF_Base_assert(%definitionId&": Invalid scenario index within the group: "&int2str(pl_scIdx),-1 < pl_scIdx and pl_scIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios));
    pl_tcNames := {}
    for ( var integer vl_tc := 0; vl_tc < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList) ; vl_tc := vl_tc+1 )
    {
      pl_tcNames[vl_tc] := v_LGenBase_trafficCases[v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList[vl_tc]].privateName
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_tcIdxListOfScenario
  // 
  //  Purpose:
  //    Retrieves the list of the indexes of the traffic cases of a scenario
  ///////////////////////////////////////////////////////////  
  public function f_EPTF_LGenBase_tcIdxListOfScenario(
    in integer pl_eGrpIdx, 
    in integer pl_scIdx,
    out EPTF_IntegerList pl_tcIdxList)
  runs on EPTF_LGenBase_Private_CT{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_eGrpIdx),-1 < pl_eGrpIdx and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
      f_EPTF_Base_assert(%definitionId&": Invalid scenario index within the group: "&int2str(pl_scIdx),-1 < pl_scIdx and pl_scIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios));
    }
    pl_tcIdxList := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList
  }
  
  //////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEGrpIdxOfTc
  // 
  //  Purpose:
  //    Returns the entity group index that the traffic case belongs to   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getEGrpIdxOfTc(
    in integer pl_tcAbsIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return integer {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_tcAbsIdx > -1 and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases));
    }
    return v_LGenBase_trafficCases[pl_tcAbsIdx].eGroupBackref
  }
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getScIdxOfTc
  // 
  //  Purpose:
  //    Returns the scenario index that the traffic case belongs to   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getScIdxOfTc(
    in integer pl_tcAbsIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return integer {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_tcAbsIdx > -1 and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases));
    }
    return v_LGenBase_trafficCases[pl_tcAbsIdx].eScenarioBackRef
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcNameByTcIdx
  // 
  //  Purpose:
  //    Returns the name of the traffic case   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTcNameByTcIdx(
    in integer pl_tcAbsIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return charstring {
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_tcAbsIdx > -1 and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases));
    return v_LGenBase_trafficCases[pl_tcAbsIdx].privateName
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcUniqueNameByTcIdx
  // 
  //  Purpose:
  //    Returns the unique name of the traffic case (entity group name+scenario name+tc name)   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTcUniqueNameByTcIdx(
    in integer pl_tcAbsIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return charstring {
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_tcAbsIdx > -1 and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases));
    return v_LGenBase_trafficCases[pl_tcAbsIdx].uniqueName
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEnabledWeightListFromScenario
  // 
  //  Purpose:
  //    Function to copy traffic weights from TCs of a scenario in to  
  ///////////////////////////////////////////////////////////  
  public function f_EPTF_LGenBase_getEnabledWeightListFromScenario(
    in integer pl_eGrpIdx,
    in integer pl_scIdx) 
  runs on EPTF_LGenBase_Private_CT return EPTF_ProbabilityList {
    var integer vl_tcCount :=sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList) 
    var integer vl_tcIdx;
    var EPTF_ProbabilityList vl_wList
    //v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Not weighted scenario!:"
        &v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].name, 
        ispresent(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].weightedScData));
    }    
    for (var integer i:=0; i<vl_tcCount; i:=i+1) {
      
      vl_tcIdx := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList[i]
      if (not (v_LGenBase_trafficCases[vl_tcIdx].groupFinishConditionDetected.anythingFinished or
          v_LGenBase_trafficCases[vl_tcIdx].groupFinishConditionProcessed.anythingFinished) and
        v_LGenBase_trafficCases[vl_tcIdx].enabled and
        originating == v_LGenBase_trafficCases[vl_tcIdx].trafficType)
      {
        vl_wList[i] := v_LGenBase_trafficCases[vl_tcIdx].schedulerData.target.trafficWeight;
      } else {
        vl_wList[i] := 0.0
      }
    }
    return vl_wList;  
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_registerTcStartedCallback
  // 
  //  Purpose:
  //    Registers a callback function to notify users about stopping or starting a tc 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_registerTcStartedCallback(in EPTF_LGenBase_tcStartedOrStopped_FT pl_fn)
  runs on EPTF_LGenBase_Private_CT{
    v_LGenBase_tcStartedOrStoppedCallbacks[sizeof(v_LGenBase_tcStartedOrStoppedCallbacks)] := pl_fn;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_removeTrafficStartedFn
  // 
  //  Purpose:
  //    Removes the callback function registered by the <f_EPTF_LGenBase_registerTcStartedCallback> 
  ///////////////////////////////////////////////////////////
  private function f_EPTF_LGenBase_removeTcStartedCallback(in EPTF_LGenBase_tcStartedOrStopped_FT pl_fn)
  runs on EPTF_LGenBase_Private_CT
  {
    var integer vl_count := sizeof(v_LGenBase_tcStartedOrStoppedCallbacks);
    var integer vl_found := 0;
    while ( vl_found < vl_count and v_LGenBase_tcStartedOrStoppedCallbacks[vl_found] != pl_fn )
    {
      vl_found := vl_found + 1;
    }
    f_EPTF_Base_assert(%definitionId&": Invalid trafficStarted function!",vl_found < vl_count);
    var EPTF_LGenBase_tcStartedOrStopped_FTList vl_newList := {};
    for ( var integer vl_i := 0; vl_i < vl_found ; vl_i := vl_i+1 )
    {
      vl_newList[vl_i] := v_LGenBase_tcStartedOrStoppedCallbacks[vl_i];
    }
    for ( var integer vl_i := vl_found; vl_i < vl_count-1 ; vl_i := vl_i+1 )
    {
      vl_newList[vl_i] := v_LGenBase_tcStartedOrStoppedCallbacks[vl_i+1];
    }
  }
  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_registerScenarioStateChangedCallback
  // 
  //  Purpose:
  //    Registers a callback function to notify users about changing the state of a scenario 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_registerScenarioStateChangedCallback(in EPTF_LGenBase_scenarioStateChanged_FT pl_fn)
  runs on EPTF_LGenBase_Private_CT{
    v_LGenBase_scenarioStateChangedCallbacks[sizeof(v_LGenBase_scenarioStateChangedCallbacks)] := pl_fn;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_registerTcStateChangedCallback
  // 
  //  Purpose:
  //    Registers a callback function to notify users about the change of a tc 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_registerTcStateChangedCallback(in EPTF_LGenBase_tcStateChanged_FT pl_fn)
  runs on EPTF_LGenBase_Private_CT{
    v_LGenBase_tcStateChangedCallbacks[sizeof(v_LGenBase_tcStateChangedCallbacks)] := pl_fn;
  }
  
  group statisticalCalbbacks{  
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_registerTrafficStartedFn
    // 
    //  Purpose:
    //    Registers a callback function to notify users about starting a traffic on an entity 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_registerTrafficStartedFn(in EPTF_LGenBase_trafficStarted_FT pl_fn)
    runs on EPTF_LGenBase_Private_CT
    {
      v_LGenBase_trafficStarted_FTList[sizeof(v_LGenBase_trafficStarted_FTList)] := pl_fn;
    }
    
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeTrafficStartedFn
    // 
    //  Purpose:
    //    Removes the callback function registered by the <f_EPTF_LGenBase_registerTrafficStartedFn> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeTrafficStartedFn(in EPTF_LGenBase_trafficStarted_FT pl_fn)
    runs on EPTF_LGenBase_Private_CT
    {
      var integer vl_count := sizeof(v_LGenBase_trafficStarted_FTList);
      var integer vl_found := 0;
      while ( vl_found < vl_count and v_LGenBase_trafficStarted_FTList[vl_found] != pl_fn )
      {
        vl_found := vl_found + 1;
      }
      f_EPTF_Base_assert(%definitionId&": Invalid trafficStarted function!",vl_found < vl_count);
      var EPTF_LGenBase_trafficStarted_FTList vl_newList := {};
      for ( var integer vl_i := 0; vl_i < vl_found ; vl_i := vl_i+1 )
      {
        vl_newList[vl_i] := v_LGenBase_trafficStarted_FTList[vl_i];
      }
      for ( var integer vl_i := vl_found; vl_i < vl_count-1 ; vl_i := vl_i+1 )
      {
        vl_newList[vl_i] := v_LGenBase_trafficStarted_FTList[vl_i+1];
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_registerTrafficSuccessFn
    // 
    //  Purpose:
    //    Registers a callback function to notify users about starting a traffic on an entity 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_registerTrafficSuccessFn(in EPTF_LGenBase_tcStatChangedCallback_FT pl_fn)
    runs on EPTF_LGenBase_Private_CT
    {
      v_LGenBase_refreshSuccFnList[sizeof(v_LGenBase_refreshSuccFnList)] := pl_fn;
    }
    
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeTrafficSuccessFn
    // 
    //  Purpose:
    //    Removes the callback function registered by the <f_EPTF_LGenBase_registerTrafficSuccessFn> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeTrafficSuccessFn(in EPTF_LGenBase_tcStatChangedCallback_FT pl_fn)
    runs on EPTF_LGenBase_Private_CT
    {
      var integer vl_count := sizeof(v_LGenBase_refreshSuccFnList);
      var integer vl_found := 0;
      while ( vl_found < vl_count and v_LGenBase_refreshSuccFnList[vl_found] != pl_fn )
      {
        vl_found := vl_found + 1;
      }
      f_EPTF_Base_assert(%definitionId&": Invalid traffic success function to deregister!",vl_found < vl_count);
      var EPTF_LGenBase_tcStatChangedCallback_FTList vl_newList := {};
      for ( var integer vl_i := 0; vl_i < vl_found ; vl_i := vl_i+1 )
      {
        vl_newList[vl_i] := v_LGenBase_refreshSuccFnList[vl_i];
      }
      for ( var integer vl_i := vl_found; vl_i < vl_count-1 ; vl_i := vl_i+1 )
      {
        vl_newList[vl_i] := v_LGenBase_refreshSuccFnList[vl_i+1];
      }
      v_LGenBase_refreshSuccFnList := vl_newList;
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_registerTrafficFailedFn
    // 
    //  Purpose:
    //    Registers a callback function to notify users about starting a traffic on an entity 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_registerTrafficFailedFn(in EPTF_LGenBase_tcStatChangedCallback_FT pl_fn)
    runs on EPTF_LGenBase_Private_CT
    {
      v_LGenBase_refreshFailFnList[sizeof(v_LGenBase_refreshFailFnList)] := pl_fn;
    }
    
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeTrafficFailedFn
    // 
    //  Purpose:
    //    Removes the callback function registered by the <f_EPTF_LGenBase_registerTrafficFailedFn> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeTrafficFailedFn(in EPTF_LGenBase_tcStatChangedCallback_FT pl_fn)
    runs on EPTF_LGenBase_Private_CT
    {
      var integer vl_count := sizeof(v_LGenBase_refreshFailFnList);
      var integer vl_found := 0;
      while ( vl_found < vl_count and v_LGenBase_refreshFailFnList[vl_found] != pl_fn )
      {
        vl_found := vl_found + 1;
      }
      f_EPTF_Base_assert(%definitionId&": Invalid traffic failed function to deregister!",vl_found < vl_count);
      var EPTF_LGenBase_tcStatChangedCallback_FTList vl_newList := {};
      for ( var integer vl_i := 0; vl_i < vl_found ; vl_i := vl_i+1 )
      {
        vl_newList[vl_i] := v_LGenBase_refreshFailFnList[vl_i];
      }
      for ( var integer vl_i := vl_found; vl_i < vl_count-1 ; vl_i := vl_i+1 )
      {
        vl_newList[vl_i] := v_LGenBase_refreshFailFnList[vl_i+1];
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_registerTrafficErrorFn
    // 
    //  Purpose:
    //    Registers a callback function to notify users about starting a traffic on an entity 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_registerTrafficErrorFn(in EPTF_LGenBase_tcStatChangedCallback_FT pl_fn)
    runs on EPTF_LGenBase_Private_CT
    {
      v_LGenBase_refreshErrorFnList[sizeof(v_LGenBase_refreshErrorFnList)] := pl_fn;
    }
    
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeTrafficErrorFn
    // 
    //  Purpose:
    //    Removes the callback function registered by the <f_EPTF_LGenBase_registerTrafficErrorFn> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeTrafficErrorFn(in EPTF_LGenBase_tcStatChangedCallback_FT pl_fn)
    runs on EPTF_LGenBase_Private_CT
    {
      var integer vl_count := sizeof(v_LGenBase_refreshErrorFnList);
      var integer vl_found := 0;
      while ( vl_found < vl_count and v_LGenBase_refreshErrorFnList[vl_found] != pl_fn )
      {
        vl_found := vl_found + 1;
      }
      f_EPTF_Base_assert(%definitionId&": Invalid traffic error function to deregister!",vl_found < vl_count);
      var EPTF_LGenBase_tcStatChangedCallback_FTList vl_newList := {};
      for ( var integer vl_i := 0; vl_i < vl_found ; vl_i := vl_i+1 )
      {
        vl_newList[vl_i] := v_LGenBase_refreshErrorFnList[vl_i];
      }
      for ( var integer vl_i := vl_found; vl_i < vl_count-1 ; vl_i := vl_i+1 )
      {
        vl_newList[vl_i] := v_LGenBase_refreshErrorFnList[vl_i+1];
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_registerTrafficTimeoutFn
    // 
    //  Purpose:
    //    Registers a callback function to notify users about a traffic timed out on an entity 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_registerTrafficTimeoutFn(in EPTF_LGenBase_tcStatChangedCallback_FT pl_fn)
    runs on EPTF_LGenBase_Private_CT
    {
      v_LGenBase_refreshTimeoutFnList[sizeof(v_LGenBase_refreshTimeoutFnList)] := pl_fn;
    }
    
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeTrafficTimeoutFn
    // 
    //  Purpose:
    //    Removes the callback function registered by the <f_EPTF_LGenBase_registerTrafficTimeoutFn> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeTrafficTimeoutFn(in EPTF_LGenBase_tcStatChangedCallback_FT pl_fn)
    runs on EPTF_LGenBase_Private_CT
    {
      var integer vl_count := sizeof(v_LGenBase_refreshTimeoutFnList);
      var integer vl_found := 0;
      while ( vl_found < vl_count and v_LGenBase_refreshTimeoutFnList[vl_found] != pl_fn )
      {
        vl_found := vl_found + 1;
      }
      f_EPTF_Base_assert(%definitionId&": Invalid traffic timeout function to deregister!",vl_found < vl_count);
      var EPTF_LGenBase_tcStatChangedCallback_FTList vl_newList := {};
      for ( var integer vl_i := 0; vl_i < vl_found ; vl_i := vl_i+1 )
      {
        vl_newList[vl_i] := v_LGenBase_refreshTimeoutFnList[vl_i];
      }
      for ( var integer vl_i := vl_found; vl_i < vl_count-1 ; vl_i := vl_i+1 )
      {
        vl_newList[vl_i] := v_LGenBase_refreshTimeoutFnList[vl_i+1];
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_registerSetTransactionTimeFn
    // 
    //  Purpose:
    //    Registers a callback function to notify users about the length
    //    of the traffic of an entity 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_registerSetTransactionTimeFn(in EPTF_LGenBase_setTransactionTimeStatValue_FT pl_fn)
    runs on EPTF_LGenBase_Private_CT
    {
      v_LGenBase_setTransactionTimeStatValueFnList[sizeof(v_LGenBase_setTransactionTimeStatValueFnList)] := pl_fn;
    }
    
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeSetTransactionTimeFn
    // 
    //  Purpose:
    //    Removes the callback function registered by the <f_EPTF_LGenBase_registerTrafficSetTransactionTimeFn> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeSetTransactionTimeFn(in EPTF_LGenBase_setTransactionTimeStatValue_FT pl_fn)
    runs on EPTF_LGenBase_Private_CT
    {
      var integer vl_count := sizeof(v_LGenBase_setTransactionTimeStatValueFnList);
      var integer vl_found := 0;
      while ( vl_found < vl_count and v_LGenBase_setTransactionTimeStatValueFnList[vl_found] != pl_fn )
      {
        vl_found := vl_found + 1;
      }
      f_EPTF_Base_assert(%definitionId&": Invalid traffic SetTransactionTime function to deregister!",vl_found < vl_count);
      var EPTF_LGenBase_setTransactionTimeStatValue_FTList vl_newList := {};
      for ( var integer vl_i := 0; vl_i < vl_found ; vl_i := vl_i+1 )
      {
        vl_newList[vl_i] := v_LGenBase_setTransactionTimeStatValueFnList[vl_i];
      }
      for ( var integer vl_i := vl_found; vl_i < vl_count-1 ; vl_i := vl_i+1 )
      {
        vl_newList[vl_i] := v_LGenBase_setTransactionTimeStatValueFnList[vl_i+1];
      }
    }
    
  }  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmTimerIsRunning
  // 
  //  Purpose:
  //    Retrieves whether an FSM timer is running. 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setGroupFinishConditionMask(
    in EPTF_LGenBase_ConditionTrue pl_groupFinishConditionMask
  )
  runs on EPTF_LGenBase_Private_CT{
    v_LGenBase_groupFinishConditionMask := pl_groupFinishConditionMask
  }
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmTimerIsRunning
  // 
  //  Purpose:
  //    Retrieves whether an FSM timer is running. 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmTimerIsRunning(
    in integer pl_eAbsIdx,
    in integer pl_fsmCtxIdx,
    in integer pl_timerIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId& "Invalid timer",
        -1 < pl_timerIdx and 
        pl_timerIdx < sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fsmCtxIdx].timerData));
    }
    return v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fsmCtxIdx].timerData[pl_timerIdx]>-1 and
    f_EPTF_SchedulerComp_eventIsValid(
      v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fsmCtxIdx].timerData[pl_timerIdx]); 
  }  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getCharstringParamValue
  // 
  //  Purpose:
  //    Retrieves a custom parameter string defined in the <EPTF_LGenBase_TcMgmt_TcOfScenario2>
  //    or <EPTF_LGenBase_TcMgmt_TcOfScenario3> declarator of the traffic case. 
  //
  //  Return Value:
  //    Returns false if there is no custom parameter with the specified identifiers
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getCharstringParamValue(
    in charstring pl_appName,
    in charstring pl_name,
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName,
    out charstring pl_param)
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    var integer vl_tcIdx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName);
    return f_EPTF_LGenBase_getCharstringParamValueByIdx(pl_appName, pl_name, vl_tcIdx, pl_param);
  }  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getCharstringParamValueByIdx
  // 
  //  Purpose:
  //    Retrieves a custom parameter string defined in the <EPTF_LGenBase_TcMgmt_TcOfScenario2>
  //    or <EPTF_LGenBase_TcMgmt_TcOfScenario3> declarator of the traffic case by its idx. 
  //
  //  Detailed Comments:
  //    See also <f_EPTF_LGenBase_getCharstringParamValue>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getCharstringParamValueByIdx(
    in charstring pl_appName,
    in charstring pl_name,
    in integer pl_tcIdx,
    out charstring pl_param)
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_tcIdx > -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    } 
    var integer vl_par := -1;
    if(f_EPTF_str2int_HashMap_Find(v_LGenBase_trafficCases[pl_tcIdx].paramHashMap,
        pl_appName&
        tsp_LGenBase_nameSeparator&
        pl_name,
        vl_par)){
      pl_param := v_LGenBase_trafficCases[pl_tcIdx].customParams[vl_par].pValue;
      return true;
    }
    return false;
  }  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getNextRangeParam
  // 
  //  Purpose:
  //    Internal function to get the next range value 
  ///////////////////////////////////////////////////////////
  friend function f_EPTF_LGenBase_getNextRangeParam(
    inout EPTF_LGenBase_TcDescriptor pl_tc,
    in integer pl_tcIdx,
    out EPTF_IntegerList pl_ret
  )
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_sizeofRanges := pl_tc.v_sizeofRanges;
    if(0 == vl_sizeofRanges){//There are no paramranges.
      pl_ret := {pl_tcIdx};
      return;
    }
    pl_ret := {pl_tcIdx};
    var boolean vl_prev := true;
    var integer vl_actRange := vl_sizeofRanges - 1;
    if(-1 == pl_tc.rangePosInRange[0]){ //This can happen only before the first run
      for ( var integer vl_i := 0; vl_i < vl_actRange ; vl_i := vl_i+1 )
      {
        pl_tc.rangePosInRange[vl_i] := 0;
      }
    }
    while(vl_prev and vl_actRange >= 0){
      pl_tc.rangePosInRange[vl_actRange] := pl_tc.rangePosInRange[vl_actRange] + 1;
      if(pl_tc.rangePosInRange[vl_actRange] == pl_tc.paramRanges[vl_actRange].count){
        pl_tc.rangePosInRange[vl_actRange] := 0;
        vl_actRange := vl_actRange - 1;
      }else{
        vl_prev := false;
      }
    }
    var integer vl_i := 0; 
    while ( vl_i < vl_sizeofRanges and pl_tc.rangePosInRange[vl_i] == pl_tc.paramRanges[vl_i].count-1 )
    {
      vl_i := vl_i+1;
    }
    if(vl_i == vl_sizeofRanges){
      pl_tc.rangeLoops := pl_tc.rangeLoops + 1;
    }
    for ( var integer vl_range := 0; vl_range < vl_sizeofRanges ; vl_range := vl_range+1 )
    {
      pl_ret[vl_range+1] := pl_tc.rangePosInRange[vl_range]+pl_tc.paramRanges[vl_range].baseOffset;
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_entityCount
  // 
  //  Purpose:
  //    Public function to get the total number of entites on this LGen
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_entityCount()
  runs on EPTF_LGenBase_Private_CT
  return integer{
    return sizeof(v_LGenBase_entities);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEGrpOfEntity
  // 
  //  Purpose:
  //    Public function to get the index of the entity group containing the specified entity   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getEGrpOfEntity(
    in integer pl_eAbsIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if(pl_eAbsIdx > -1 and pl_eAbsIdx < sizeof(v_LGenBase_entities)){
      return v_LGenBase_entities[pl_eAbsIdx].eGrpBackIdx;
    }
    return -1
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEGrpECount
  // 
  //  Purpose:
  //    Public function to get the size of the entity group based on the index of the entity group
  //
  //  Detailed Comments:
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getEGrpECount(
    in integer pl_eGrpIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity group index.",pl_eGrpIdx > -1 and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
    }
    return v_LGenBase_entityGroups[pl_eGrpIdx].eCount;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEGrpCount
  // 
  //  Purpose:
  //    Public function to get the size of the entity group based on the index of the entity group
  //
  //  Detailed Comments:
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getEGrpCount()
  runs on EPTF_LGenBase_Private_CT
  return integer{
    return sizeof(v_LGenBase_entityGroups)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getScCountOfEGrp
  // 
  //  Purpose:
  //    Public function to get the size of the entity group based on the index of the entity group
  //
  //  Detailed Comments:
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getScCountOfEGrp(in integer pl_eGrpIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity group index.",pl_eGrpIdx > -1 and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
    }
    return sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcCountOfSc
  // 
  //  Purpose:
  //    Public function to get the size of the entity group based on the index of the entity group
  //
  //  Detailed Comments:
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTcCountOfSc(
    in integer pl_eGrpIdx,
    in integer pl_scIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity group index.",pl_eGrpIdx > -1 and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
      f_EPTF_Base_assert(%definitionId&": Invalid scenario index within the group: "&int2str(pl_scIdx),-1 < pl_scIdx and pl_scIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios));
    }
    return sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getScTrafficType
  // 
  //  Purpose:
  //    Returns the traffic type of the specified SC
  // 
  //  Detailed Comments:
  //    Calc function
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getScTrafficType( 
    in integer pl_eGrpIdx,
    in integer pl_scIdx)
  runs on EPTF_LGenBase_Private_CT
  return EPTF_LGenBase_TrafficType{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity group index.",pl_eGrpIdx > -1 and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
      f_EPTF_Base_assert(%definitionId&": Invalid scenario index within the group: "&int2str(pl_scIdx),-1 < pl_scIdx and pl_scIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios));
    }
    return v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].trafficType
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcTrafficType
  // 
  //  Purpose:
  //    Returns the traffic type of the specified TC
  // 
  //  Detailed Comments:
  //    Calc function
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTcTrafficType( 
    in integer pl_tcAbsIdx)
  runs on EPTF_LGenBase_Private_CT
  return EPTF_LGenBase_TrafficType{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_tcAbsIdx > -1 and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases));
    return v_LGenBase_trafficCases[pl_tcAbsIdx].trafficType
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getETypeCount
  // 
  //  Purpose:
  //    Public function to get the count of entity types
  //
  function f_EPTF_LGenBase_getETypeCount()
  runs on EPTF_LGenBase_Private_CT
  return integer{
    return sizeof(v_LGenBase_entityTypes)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getETypeCount
  // 
  //  Purpose:
  //    Public function to get the count of entity types
  //
  function f_EPTF_LGenBase_getETypeName(in integer pl_eTypeIdx)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    return v_LGenBase_entityTypes[pl_eTypeIdx].name
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getETypeMaxCountByIdx
  // 
  //  Purpose:
  //    Public function to get the maximal count of entities of the specified entity type
  //
  //  Detailed Comments:
  //    The return value is the less of the maximal counts of the
  //    behavior types of the specified entity type
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getETypeMaxCountByIdx(
    in integer pl_eTypeIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var integer vl_maxCount := -1;
    var integer vl_behavSize := sizeof(v_LGenBase_entityTypes[pl_eTypeIdx].behaviorTypeIdxList);
    for(var integer vl_behav := 0; vl_behav < vl_behavSize; vl_behav := vl_behav + 1){
      if(v_LGenBase_behaviorTypes[v_LGenBase_entityTypes[pl_eTypeIdx].behaviorTypeIdxList[vl_behav]].bMaxCount < vl_maxCount or 
        vl_maxCount < 0 )
      {
        vl_maxCount := v_LGenBase_behaviorTypes[v_LGenBase_entityTypes[pl_eTypeIdx].behaviorTypeIdxList[vl_behav]].bMaxCount;
      }
    }
    return vl_maxCount;
  }  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getETypeMaxCountByName
  // 
  //  Purpose:
  //    Public function to get the maximal count of entities of the specified entity type
  //
  //  Detailed Comments:
  //    The return value is the less of the maximal counts of the
  //    behavior types of the specified entity type
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getETypeMaxCountByName(
    in charstring pl_eTypeName)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var integer vl_eTypeIdx := f_EPTF_LGenBase_entityTypeNameIndex(pl_eTypeName); 
    return f_EPTF_LGenBase_getETypeMaxCountByIdx(vl_eTypeIdx);
  }  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getETypeAvailableByIdx
  // 
  //  Purpose:
  //    Public function to get the maximal available entities of the specified entity type
  //
  //  Detailed Comments:
  //    The return value is the less of the maximal amount of available entities of the
  //    behavior types of the specified entity type
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getETypeAvailableByIdx(
    in integer pl_eTypeIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var integer vl_maxCount := -1;
    var integer vl_behavSize := sizeof(v_LGenBase_entityTypes[pl_eTypeIdx].behaviorTypeIdxList);
    for(var integer vl_behav := 0; vl_behav < vl_behavSize; vl_behav := vl_behav + 1){
      var integer vl_max := v_LGenBase_behaviorTypes[v_LGenBase_entityTypes[pl_eTypeIdx].behaviorTypeIdxList[vl_behav]].bMaxCount;
      var integer vl_current := v_LGenBase_behaviorTypes[v_LGenBase_entityTypes[pl_eTypeIdx].behaviorTypeIdxList[vl_behav]].bCurrCount;
      var integer vl_count := -1;
      if(-1 < vl_max){
        vl_count := vl_max - vl_current
      }
      if(vl_maxCount < 0  or (vl_count > -1 and vl_count < vl_maxCount))
      {
        vl_maxCount := vl_count;
      }
    }
    return vl_maxCount;
  }  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getETypeAvailableByName
  // 
  //  Purpose:
  //    Public function to get the maximal available entities of the specified entity type
  //
  //  Detailed Comments:
  //    The return value is the less of the maximal amount of available entities of the
  //    behavior types of the specified entity type
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getETypeAvailableByName(
    in charstring pl_eTypeName)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var integer vl_eTypeIdx := f_EPTF_LGenBase_entityTypeNameIndex(pl_eTypeName); 
    return f_EPTF_LGenBase_getETypeAvailableByIdx(vl_eTypeIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEGrpBaseOffset
  // 
  //  Purpose:
  //    Public function to get the base offset of the entity group containing the specified entity   
  //
  //  Detailed Comments:
  //    The entities are stored in a linear list. The absolut index of an entity
  //    is its position in this list. 
  //    The list of the entities of the same entity group is continuous.
  //    The base offset of the entity group is the index of the
  //    first entity of the entity group.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getEGrpBaseOffset(
    in integer pl_eGrpIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity group index.",pl_eGrpIdx > -1 and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
    }
    return v_LGenBase_entityGroups[pl_eGrpIdx].eOffset;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEGrpOfEntity
  // 
  //  Purpose:
  //    Retrieves the index of the entity group containing the specified entity
  //    and the relative index of the entity in the entity group. See also <f_EPTF_LGenBase_getEGrpBaseOffset>.   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getEIdxs(
    in integer pl_eAbsIdx,
    out integer pl_eGrpIdx,
    out integer pl_eRelIdx)
  runs on EPTF_LGenBase_Private_CT{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity index.",pl_eAbsIdx > -1 and pl_eAbsIdx < sizeof(v_LGenBase_entities));
    }
    pl_eGrpIdx := v_LGenBase_entities[pl_eAbsIdx].eGrpBackIdx;
    pl_eRelIdx := pl_eAbsIdx - v_LGenBase_entityGroups[pl_eGrpIdx].eOffset;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getERelIdx
  // 
  //  Purpose:
  //    Gets the relative index of the entity in its entity group. See also <f_EPTF_LGenBase_getEGrpBaseOffset>.   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getERelIdx(
    in integer pl_eAbsIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity index.",pl_eAbsIdx > -1 and pl_eAbsIdx < sizeof(v_LGenBase_entities));
    }
    var integer vl_eGrpIdx := v_LGenBase_entities[pl_eAbsIdx].eGrpBackIdx;
    return pl_eAbsIdx - v_LGenBase_entityGroups[vl_eGrpIdx].eOffset;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEAbsIdxOfTC
  // 
  //  Purpose:
  //    Gets the absolute index of the entity from its relative index and traffic case index.   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getEAbsIdxOfTC(
    in integer pl_eRelIdx,
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcIdx),-1 < pl_tcIdx and pl_tcIdx < sizeof(v_LGenBase_trafficCases))
      f_EPTF_Base_assert(%definitionId&": Invalid entity index.",-1 < pl_eRelIdx and pl_eRelIdx < sizeof(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList));
    }
    return v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_eRelIdx].entityIdx
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getFSMCtxIdx
  // 
  //  Purpose:
  //    Public function to get the FSM context index of the entity in a traffic case.   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getFSMCtxIdx(
    in integer pl_eAbsIdx,
    in integer pl_tcIdx,
    in integer pl_siblingIdx := 0)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var integer vl_eRelIdx := pl_eAbsIdx - v_LGenBase_entityGroups[v_LGenBase_entities[pl_eAbsIdx].eGrpBackIdx].eOffset;
    return f_EPTF_LGenBase_getEntityFSMCtxIdx(vl_eRelIdx, pl_tcIdx, pl_siblingIdx)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTypeIdxOfTc
  // 
  //  Purpose:
  //    Retrieves the FSM context index of the entity in a traffic case.   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTypeIdxOfTc(
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    return v_LGenBase_trafficCases[pl_tcIdx].tcTypeIdx;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getBehaviorCtx
  // 
  //  Purpose:
  //    Retrieves the behavior context of the entity.   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getBehaviorCtx(
    in integer pl_eAbsIdx,
    in integer pl_bIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return EPTF_IntegerList{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity index.",pl_eAbsIdx > -1 and pl_eAbsIdx < sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&": Invalid behavior index.",pl_bIdx > -1 and pl_bIdx < sizeof(v_LGenBase_entities[pl_eAbsIdx].bCtxList));
    }
    return v_LGenBase_entities[pl_eAbsIdx].bCtxList[pl_bIdx];
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getBehaviorCtxItem
  // 
  //  Purpose:
  //    Retrieves an element of the behavior context of the entity.   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getBehaviorCtxItem(
    in integer pl_eAbsIdx,
    in integer pl_bIdx,
    in integer pl_iIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return integer {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity index: "&
        int2str(pl_eAbsIdx)&" of "&int2str(sizeof(v_LGenBase_entities)),
        pl_eAbsIdx > -1 and pl_eAbsIdx < sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&": Invalid behavior index: "&
        int2str(pl_bIdx)&" of "&int2str(sizeof(v_LGenBase_entities[pl_eAbsIdx].bCtxList)),
        pl_bIdx > -1 and pl_bIdx < sizeof(v_LGenBase_entities[pl_eAbsIdx].bCtxList));
      f_EPTF_Base_assert(%definitionId&": Invalid behavior context item index: "&
        int2str(pl_iIdx)&" of "&int2str(sizeof(v_LGenBase_entities[pl_eAbsIdx].bCtxList[pl_bIdx])),
        pl_iIdx > -1 and pl_iIdx < sizeof(v_LGenBase_entities[pl_eAbsIdx].bCtxList[pl_bIdx]));
    }
    return v_LGenBase_entities[pl_eAbsIdx].bCtxList[pl_bIdx][pl_iIdx];
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setBehaviorCtx
  // 
  //  Purpose:
  //    Sets the behavior context of the entity.   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setBehaviorCtx(
    in integer pl_eAbsIdx,
    in integer pl_bIdx,
    in EPTF_IntegerList pl_newVal
  )
  runs on EPTF_LGenBase_Private_CT
  {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity index.",pl_eAbsIdx > -1 and pl_eAbsIdx < sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&": Invalid behavior index.",pl_bIdx > -1 and pl_bIdx < sizeof(v_LGenBase_entities[pl_eAbsIdx].bCtxList));
    }
    v_LGenBase_entities[pl_eAbsIdx].bCtxList[pl_bIdx] := pl_newVal;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setBehaviorCtxItem
  // 
  //  Purpose:
  //    Sets an element of the behavior context of the entity.   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setBehaviorCtxItem(
    in integer pl_eAbsIdx,
    in integer pl_bIdx,
    in integer pl_iIdx,
    in integer pl_newVal
  )
  runs on EPTF_LGenBase_Private_CT
  {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity index.",pl_eAbsIdx > -1 and pl_eAbsIdx < sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&": Invalid behavior index.",pl_bIdx > -1 and pl_bIdx < sizeof(v_LGenBase_entities[pl_eAbsIdx].bCtxList));
      //f_EPTF_Base_assert(%definitionId&": Invalid behavior context item index.",pl_iIdx > -1 and pl_iIdx < sizeof(v_LGenBase_entities[pl_eAbsIdx].bCtxList[pl_bIdx]));
    }
    v_LGenBase_entities[pl_eAbsIdx].bCtxList[pl_bIdx][pl_iIdx] := pl_newVal;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_trafficCaseIdNames
  // 
  //  Purpose:
  //    Retrieves the *charstring* identifiers of a traffic case, such as
  //    the name of its entity group, scenario, and its own name.   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_trafficCaseIdNames(
    in integer pl_tcAbsIdx,
    out charstring pl_eGrpName,
    out charstring pl_scName,
    out charstring pl_tcName
  )
  runs on EPTF_LGenBase_Private_CT{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_tcAbsIdx > -1 and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases));
    }
    pl_eGrpName := v_LGenBase_entityGroups[v_LGenBase_trafficCases[pl_tcAbsIdx].eGroupBackref].name;
    pl_scName := v_LGenBase_entityGroups[v_LGenBase_trafficCases[pl_tcAbsIdx].eGroupBackref].scenarios[v_LGenBase_trafficCases[pl_tcAbsIdx].eScenarioBackRef].name;
    pl_tcName := v_LGenBase_trafficCases[pl_tcAbsIdx].privateName;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_scenarioIdNames
  // 
  //  Purpose:
  //    Retrieves the *charstring* identifiers of a scenario, such as
  //    the name of its entity group and the scenario.   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_scenarioIdNames(
    in integer pl_eGrpIdx,
    in integer pl_scIdx,
    out charstring pl_eGrpName,
    out charstring pl_scName
  )
  runs on EPTF_LGenBase_Private_CT{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_eGrpIdx),-1 < pl_eGrpIdx and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
      f_EPTF_Base_assert(%definitionId&": Invalid scenario index: "&int2str(pl_scIdx),-1 < pl_scIdx and pl_scIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios));
    }
    pl_eGrpName := v_LGenBase_entityGroups[pl_eGrpIdx].name;
    pl_scName := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].name;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_trafficCaseId
  // 
  //  Purpose:
  //    Returns the index of the traffic case 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_trafficCaseId(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName
  )
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var integer vl_eGrpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_eGrpName);
    f_EPTF_Base_assert(%definitionId&": Invalid entity group name: "&pl_eGrpName,-1 != vl_eGrpIdx);
    var integer vl_scIdx := f_EPTF_LGenBase_scNameIndexInEG(vl_eGrpIdx, pl_scName);
    f_EPTF_Base_assert(%definitionId&": Invalid scenario name: "&pl_scName,-1 != vl_scIdx);
    var integer vl_tcIdx := f_EPTF_LGenBase_tcOfScenario(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx], pl_tcName);
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case name: "&pl_tcName,-1 != vl_tcIdx);
    var integer vl_tcAbsIdx := v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].tcIdxList[vl_tcIdx];
    return vl_tcAbsIdx;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_trafficCaseAbsIdx
  // 
  //  Purpose:
  //    Returns the absolut index of the traffic case from its relative identitfiers 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_trafficCaseAbsIdx(
    in integer pl_eGrpIdx,
    in integer pl_scIdx,
    in integer pl_tcIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_eGrpIdx),-1 < pl_eGrpIdx and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
      f_EPTF_Base_assert(%definitionId&": Invalid scenario index: "&int2str(pl_scIdx),-1 < pl_scIdx and pl_scIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios));
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcIdx),-1 < pl_tcIdx and pl_tcIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList));
    }
    return v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList[pl_tcIdx];
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_scenarioAbsIdx
  // 
  //  Purpose:
  //    Returns the absolut index of the traffic case from its relative identitfiers 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_scenarioAbsIdx(
    in integer pl_eGrpIdx,
    in integer pl_scIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_eGrpIdx),-1 < pl_eGrpIdx and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
      f_EPTF_Base_assert(%definitionId&": Invalid scenario index: "&int2str(pl_scIdx),-1 < pl_scIdx and pl_scIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios));
    }
    //v_LGenBase_scenarios
    return v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].absIdx;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_scenarioAbsIdxByName
  // 
  //  Purpose:
  //    Returns the absolut index of the traffic case from its relative identitfiers 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_scenarioAbsIdxByName(
    in charstring pl_eGrpName,
    in charstring pl_scName
  )
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var integer vl_eGrpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_eGrpName);
    var integer vl_scIdx := f_EPTF_LGenBase_scNameIndexInEG(vl_eGrpIdx, pl_scName);
    //v_LGenBase_scenarios
    return v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].absIdx;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_scenarioAbsIdx
  // 
  //  Purpose:
  //    Returns the absolut index of the traffic case from its relative identitfiers 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_scenarioRelIdx(
    in integer pl_sAbsIdx,
    out integer pl_eGrpIdx,
    out integer pl_scRelIdx
  )
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_sAbsIdx),-1 < pl_sAbsIdx and pl_sAbsIdx < f_EPTF_FBQ_getLengthOfQueue(v_LGenBase_scenarios));
    pl_eGrpIdx := f_EPTF_FBQ_getQueueData(pl_sAbsIdx, v_LGenBase_scenarios, c_EPTF_LGenBase_scenarioEGOffset) 
    pl_scRelIdx := f_EPTF_FBQ_getQueueData(pl_sAbsIdx, v_LGenBase_scenarios, c_EPTF_LGenBase_scenarioSCOffset) 
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTCEnabled
  // 
  //  Purpose:
  //    Returns the enabled state of the traffic case 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTCEnabled(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName
  )
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    return f_EPTF_LGenBase_getTCEnabledByIdx(f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName));
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTCEnabledByIdx
  // 
  //  Purpose:
  //    Returns the enabled state of the traffic case 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTCEnabledByIdx(
    in integer pl_tcAbsIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_tcAbsIdx > -1 and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases));
    }
    return v_LGenBase_trafficCases[pl_tcAbsIdx].enabled;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTCStartDelayByName
  // 
  //  Purpose:
  //    Returns the start delay of the traffic case 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTCStartDelayByName(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName,
    out float pl_delay)
  runs on EPTF_LGenBase_Private_CT
  return boolean {
    var integer vl_eGrpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_eGrpName);
    if(-1 < vl_eGrpIdx){
      var integer vl_scIdx := f_EPTF_LGenBase_scNameIndexInEG(vl_eGrpIdx, pl_scName);
      if(-1 < vl_scIdx){
        var integer vl_tcIdx := f_EPTF_LGenBase_tcOfScenario(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx], pl_tcName);
        if(-1 < vl_tcIdx){
          var integer vl_tcAbsIdx := v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].tcIdxList[vl_tcIdx];
          return f_EPTF_LGenBase_getTCStartDelayByIdx(vl_tcAbsIdx,pl_delay);
        }
      }
    }
    return false
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTCStartDelayByIdx
  // 
  //  Purpose:
  //    Returns the start delay of the traffic case 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTCStartDelayByIdx(
    in integer pl_tcIdx,
    out float pl_delay)
  runs on EPTF_LGenBase_Private_CT return boolean {
    if(pl_tcIdx > -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases)) {
      pl_delay := v_LGenBase_trafficCases[pl_tcIdx].startDelay;
      return true;
    }
    else {
      return false;
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getParamMin
  //
  //  Purpose:
  //    Returns the min. value of a parameter range of a traffic case   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getParamMin(
    in integer pl_tcAbsIdx,
    in integer pl_rangeIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_tcAbsIdx > -1 and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases));
      f_EPTF_Base_assert(%definitionId&": Invalid range index.",pl_rangeIdx > -1 and pl_rangeIdx < sizeof(v_LGenBase_trafficCases[pl_tcAbsIdx].paramRanges));
    }
    return v_LGenBase_trafficCases[pl_tcAbsIdx].paramRanges[pl_rangeIdx].baseOffset;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getParamMax
  //
  //  Purpose:
  //    Returns the max. value of a parameter range of a traffic case   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getParamMax(
    in integer pl_tcAbsIdx,
    in integer pl_rangeIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_tcAbsIdx > -1 and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases));
      f_EPTF_Base_assert(%definitionId&": Invalid range index.",pl_rangeIdx > -1 and pl_rangeIdx < sizeof(v_LGenBase_trafficCases[pl_tcAbsIdx].paramRanges));
    }
    return v_LGenBase_trafficCases[pl_tcAbsIdx].paramRanges[pl_rangeIdx].baseOffset + v_LGenBase_trafficCases[pl_tcAbsIdx].paramRanges[pl_rangeIdx].count - 1;
  }
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getParamCount
  //
  //  Purpose:
  //    Returns the number of  values in a parameter range of a traffic case   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getParamCount(
    in integer pl_tcAbsIdx,
    in integer pl_rangeIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_tcAbsIdx > -1 and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases));
      f_EPTF_Base_assert(%definitionId&": Invalid range index.",pl_rangeIdx > -1 and pl_rangeIdx < sizeof(v_LGenBase_trafficCases[pl_tcAbsIdx].paramRanges));
    }
    return v_LGenBase_trafficCases[pl_tcAbsIdx].paramRanges[pl_rangeIdx].count;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getParamRangesCount
  //
  //  Purpose:
  //    Returns the number of parameter ranges of a traffic case   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getParamRangesCount(
    in integer pl_tcAbsIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (pl_tcAbsIdx > -1 and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases)){
      return sizeof(v_LGenBase_trafficCases[pl_tcAbsIdx].paramRanges);
    }
    return -1;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getParamName
  //
  //  Purpose:
  //    Returns the name of a parameter range of a traffic case   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getParamName(
    in integer pl_tcAbsIdx,
    in integer pl_rangeIdx)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_tcAbsIdx > -1 and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases));
      f_EPTF_Base_assert(%definitionId&": Invalid range index.",pl_rangeIdx > -1 and pl_rangeIdx < sizeof(v_LGenBase_trafficCases[pl_tcAbsIdx].paramRanges));
    }
    return v_LGenBase_trafficCases[pl_tcAbsIdx].paramRanges[pl_rangeIdx].name;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_stateOfScenario
  // 
  //  Purpose:
  //    Calculates the state of a scenario from the states of its traffic cases   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_stateOfScenario(
    in integer pl_eGrpIdx,
    in integer pl_scIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return EPTF_LGenBase_tcState{
    var EPTF_IntegerList vl_stateList := {}
    vl_stateList[c_EPTF_LGenBase_tcStateCount-1] := 0;
    for ( var integer vl_i := c_EPTF_LGenBase_firstTcState; vl_i < c_EPTF_LGenBase_tcStateCount ; vl_i := vl_i+1 ){
      vl_stateList[vl_i] := 0;
    }
    var integer vl_tcCount :=sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList);
    for ( var integer vl_tcIdx := 0; vl_tcIdx < vl_tcCount ; vl_tcIdx := vl_tcIdx+1 )
    {
      var integer vl_temp := v_LGenBase_trafficCases[v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList[vl_tcIdx]].state;
      if(c_EPTF_LGenBase_tcStateRunning == vl_temp){
        //If one of the traffic cases is running, running
        return c_EPTF_LGenBase_tcStateRunning;
      }
      vl_stateList[vl_temp] := vl_stateList[vl_temp] + 1;
    }
    if(0 < vl_stateList[c_EPTF_LGenBase_tcStatePaused]){
      return c_EPTF_LGenBase_tcStatePaused;
    }
    if(0 < vl_stateList[c_EPTF_LGenBase_tcStateAborting]){
      return c_EPTF_LGenBase_tcStateAborting;
    }
    if(0 < vl_stateList[c_EPTF_LGenBase_tcStateStopping]){
      return c_EPTF_LGenBase_tcStateStopping;
    }
    if(0 < vl_stateList[c_EPTF_LGenBase_tcStateAborted]){
      return c_EPTF_LGenBase_tcStateAborted;
    }
    if(0 < vl_stateList[c_EPTF_LGenBase_tcStateStopped]){
      return c_EPTF_LGenBase_tcStateStopped;
    }
    if(0 < vl_stateList[c_EPTF_LGenBase_tcStateFinished]){
      return c_EPTF_LGenBase_tcStateFinished;
    }
    if(0 < vl_stateList[c_EPTF_LGenBase_tcStateTerminated]){
      return c_EPTF_LGenBase_tcStateTerminated;
    }
    return c_EPTF_LGenBase_tcStateIdle;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_tcIdxOfStep
  // 
  //  Purpose:
  //    Retrieves the traffic cases index from a test step argument   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_tcIdxOfStep(in EPTF_LGenBase_TestStepArgs pl_ptr)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    //TODO assert  eIdx, fCtxIdx
    return f_EPTF_LGenBase_tcIdxOfFSM(pl_ptr.eIdx,pl_ptr.refContext.fCtxIdx)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_tcIdxOfFSM
  // 
  //  Purpose:
  //    Retrieves the traffic cases index of an FSM context   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_tcIdxOfFSM(
    in integer pl_eIdx,
    in integer pl_fCtxIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity index: "&int2str(pl_eIdx), -1 <pl_eIdx and pl_eIdx < sizeof(v_LGenBase_entities))
      f_EPTF_Base_assert(%definitionId&": Invalid FSM context index: "&int2str(pl_eIdx), -1 < pl_fCtxIdx and pl_fCtxIdx < sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList))
    }
    return v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tcIdx
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_templateSetIdxOfStep
  // 
  //  Purpose:
  //    Retrieves the template set index belongs to the traffic case of test step   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_templateSetIdxOfStep(in EPTF_LGenBase_TestStepArgs pl_ptr)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    return f_EPTF_LGenBase_templateSetIdxOfTc(f_EPTF_LGenBase_tcIdxOfStep(pl_ptr));
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_templateSetIdxOfTc
  // 
  //  Purpose:
  //    Retrieves the template set index belongs to a traffic case   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_templateSetIdxOfTc(in integer p_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (p_tcIdx<0 or p_tcIdx>=sizeof(v_LGenBase_trafficCases))
    {
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Bad traffic case index: "& int2str(p_tcIdx))
      return -1;      
    }
    return v_LGenBase_trafficCases[p_tcIdx].templateSetIdx;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmVarIdOfStat
  // 
  //  Purpose:
  //    Retrieves the EPTF_Variable index of the statistics   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmVarIdOfStat(
    in charstring pl_statName,
    in integer pl_eIdx,
    in integer pl_fCtxIdx,
    in EPTF_LGenBase_FsmObjectScope pl_scope)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid scope of FSM statistic: "&log2str( pl_scope ), c_EPTF_LGenBase_fsmObjectScopeFirst <= pl_scope and pl_scope <= c_EPTF_LGenBase_fsmObjectScopeLast)
      f_EPTF_Base_assert(%definitionId&": Invalid entity index: "&int2str(pl_eIdx), -1 <pl_eIdx and pl_eIdx < sizeof(v_LGenBase_entities))
      f_EPTF_Base_assert(%definitionId&": Invalid FSM context index: "&int2str(pl_eIdx), -1 < pl_fCtxIdx and pl_fCtxIdx < sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList))
    }
    select( pl_scope ){
      case ( c_EPTF_LGenBase_fsmObjectScopeFSM ){
        return f_EPTF_LGenBase_fsmVarIdOfFSMStat(pl_statName, pl_eIdx, pl_fCtxIdx);
      }
      case ( c_EPTF_LGenBase_fsmObjectScopeSiblingFSM ){
        var integer vl_tcIdx := v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tcIdx;
        if (c_EPTF_Common_debugSwitch){
          f_EPTF_Base_assert(%definitionId&": Invalid TC index "&
            int2str(vl_tcIdx)&" in FSM#"&int2str(pl_fCtxIdx)&" of entity #"&int2str(pl_eIdx),
            -1 < vl_tcIdx and vl_tcIdx < sizeof(v_LGenBase_trafficCases))
        }
        var integer vl_eOffset := v_LGenBase_entityGroups[v_LGenBase_entities[pl_eIdx].eGrpBackIdx].eOffset
        return f_EPTF_LGenBase_fsmVarIdOfSiblingStat(pl_statName, vl_tcIdx, pl_eIdx-vl_eOffset)
      }
      case ( c_EPTF_LGenBase_fsmObjectScopeTC ){
        var integer vl_tcIdx := v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tcIdx;
        if (c_EPTF_Common_debugSwitch){
          f_EPTF_Base_assert(%definitionId&": Invalid TC index "&
            int2str(vl_tcIdx)&" in FSM#"&int2str(pl_fCtxIdx)&" of entity #"&int2str(pl_eIdx),
            -1 < vl_tcIdx and vl_tcIdx < sizeof(v_LGenBase_trafficCases))
        }
        return f_EPTF_LGenBase_fsmVarIdOfTCStat(pl_statName, vl_tcIdx)
      }
      case else{
        f_EPTF_Base_assert(%definitionId&": Invalid FSM variable scope: "&int2str(pl_scope),false);
      }
    }
    return -1;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmVarIdOfFSMStat
  // 
  //  Purpose:
  //    Retrieves the EPTF_Variable index of the statistics  with FSM scope   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmVarIdOfFSMStat(
    in charstring pl_statName,
    in integer pl_eIdx,
    in integer pl_fCtxIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity index: "&int2str(pl_eIdx), -1 <pl_eIdx and pl_eIdx < sizeof(v_LGenBase_entities))
      f_EPTF_Base_assert(%definitionId&": Invalid FSM context index: "&int2str(pl_eIdx), -1 < pl_fCtxIdx and pl_fCtxIdx < sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList))
    }
    var charstring vl_statName := f_EPTF_LGenBase_varNameOfFSMVar(pl_eIdx, pl_fCtxIdx, pl_statName);
    f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": The unique name of the statistic "&pl_statName&
      " of the FSM#"&int2str(pl_fCtxIdx)&" of entity #"&int2str(pl_eIdx)&" is: "&vl_statName)
    var charstring vl_varName := f_EPTF_StatHandlerClient_getStatVariableRef(vl_statName, self);
    f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Retrieving varID of variable "&vl_varName)
    return f_EPTF_Var_getId(vl_varName);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmVarIdOfTCStat
  // 
  //  Purpose:
  //    Retrieves the EPTF_Variable index of the statistics with TC scope   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmVarIdOfTCStat(
    in charstring pl_statName,
    in integer pl_tcAbsIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcAbsIdx),
        -1 < pl_tcAbsIdx and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases[pl_tcAbsIdx]))
    }
    var charstring vl_statName;
    vl_statName := f_EPTF_LGenBase_varNameOfTCVar(pl_tcAbsIdx, pl_statName);
    f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": The unique name of the statistic "&pl_statName&
      " of the TC "&int2str(pl_tcAbsIdx)&" is: '"&vl_statName&"'")
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid statistic name: "&pl_statName&
        " of the TC "&int2str(pl_tcAbsIdx),"" != vl_statName);
    }
    var charstring vl_varName := f_EPTF_StatHandlerClient_getStatVariableRef(vl_statName, self);
    f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Retrieving varID of variable "&vl_varName)
    return f_EPTF_Var_getId(vl_varName);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmVarIdOfSiblingStat
  // 
  //  Purpose:
  //    Retrieves the EPTF_Variable index of the statistics with SiblingFSM scope   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmVarIdOfSiblingStat(
    in charstring pl_statName,
    in integer pl_tcAbsIdx,
    in integer pl_eRelIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcAbsIdx),
        -1 < pl_tcAbsIdx and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases[pl_tcAbsIdx]))
    }
    var charstring vl_statName;
    vl_statName := f_EPTF_LGenBase_varNameOfSiblingFSMsVar(pl_tcAbsIdx, pl_eRelIdx, pl_statName);
    f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": The unique name of the statistic "&pl_statName&
      " of the TC "&int2str(pl_tcAbsIdx)&" is: '"&vl_statName&"'")
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid statistic name: "&pl_statName&
        " of the TC "&int2str(pl_tcAbsIdx),"" != vl_statName);
    }
    var charstring vl_varName := f_EPTF_StatHandlerClient_getStatVariableRef(vl_statName, self);
    f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Retrieving varID of variable "&vl_varName)
    return f_EPTF_Var_getId(vl_varName);
  }
  
  //TODO move to private functions
  private function f_EPTF_LGenBase_fsmVarIdFromStepData(
    in integer pl_eIdx,
    in integer pl_fsmCtxIdx,
    in integer pl_varIdxInFsm, //[0]
    in integer pl_scope //[1]
  )
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity index: "&int2str(pl_eIdx), -1 <pl_eIdx and pl_eIdx < sizeof(v_LGenBase_entities))
      f_EPTF_Base_assert(%definitionId&": Invalid FSM context index: "&int2str(pl_eIdx), -1 < pl_fsmCtxIdx and pl_fsmCtxIdx < sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList))
    }
    select( pl_scope ){
      case ( c_EPTF_LGenBase_fsmObjectScopeFSM ){
        if (c_EPTF_Common_debugSwitch){
          f_EPTF_Base_assert(%definitionId&": Invalid FSM variable index: "&int2str(pl_varIdxInFsm), -1 < pl_varIdxInFsm and pl_varIdxInFsm < sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fsmCtxIdx].varList))
        }
        return v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fsmCtxIdx].varList[pl_varIdxInFsm];
      }
      case ( c_EPTF_LGenBase_fsmObjectScopeTC ){
        var integer vl_tcIdx := f_EPTF_LGenBase_tcIdxOfFSM(pl_eIdx, pl_fsmCtxIdx)
        var integer vl_fsmSiblingIdx := v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fsmCtxIdx].siblingIdx
        var integer vl_varIdxInTc :=
        v_LGenBase_trafficCases[vl_tcIdx].varIdxInFsm[vl_fsmSiblingIdx][pl_varIdxInFsm]
        return f_EPTF_LGenBase_fsmVarIdOfTC(vl_tcIdx,vl_varIdxInTc)
      }
      case ( c_EPTF_LGenBase_fsmObjectScopeSiblingFSM ){
        var integer vl_tcIdx := f_EPTF_LGenBase_tcIdxOfFSM(pl_eIdx, pl_fsmCtxIdx);
        var integer vl_siblingIdx := v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fsmCtxIdx].siblingIdx;
        var integer vl_varIdxInEntityInfo := v_LGenBase_trafficCases[vl_tcIdx].siblingFsmVarIdxInFsm[vl_siblingIdx][pl_varIdxInFsm];
        //v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fsmCtxIdx].siblingVarIdxInEntityInfo[pl_varIdxInFsm]
        var integer vl_eRelIdx := pl_eIdx - v_LGenBase_entityGroups[v_LGenBase_trafficCases[vl_tcIdx].eGroupBackref].eOffset
        return
        v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_eRelIdx].siblingFsmVarList[vl_varIdxInEntityInfo];
        //return f_EPTF_LGenBase_fsmVarIdOfTC(vl_tcIdx,vl_varIdxInTc)
      }
      case else{
        f_EPTF_Base_assert(%definitionId&": Invalid FSM variable scope: "&int2str(pl_scope),false);
      }
    }
    return -1;
  }  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmVarIdFromStep
  // 
  //  Purpose:
  //    Retrieves the EPTF_Variable index referred by the step argument of the test step   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmVarIdFromStep(
    in EPTF_LGenBase_TestStepArgs pl_ptr)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid context argument: "&log2str(pl_ptr.refContext.fRefArgs), 1<sizeof(pl_ptr.refContext.fRefArgs))
      f_EPTF_Base_assert(%definitionId&": Invalid entity index: "&int2str(pl_ptr.eIdx), -1 <pl_ptr.eIdx and pl_ptr.eIdx < sizeof(v_LGenBase_entities))
      f_EPTF_Base_assert(%definitionId&": Invalid FSM context index: "&int2str(pl_ptr.eIdx), -1 < pl_ptr.refContext.fCtxIdx and pl_ptr.refContext.fCtxIdx < sizeof(v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList))
    }
    return f_EPTF_LGenBase_fsmVarIdFromStepData(
      pl_ptr.eIdx,
      pl_ptr.refContext.fCtxIdx,
      pl_ptr.refContext.fRefArgs[0],
      pl_ptr.refContext.fRefArgs[1])
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmVarIdOfTC
  // 
  //  Purpose:
  //    Retrieves the EPTF_Variable index referred by the step argument of the test step   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmVarIdOfTC(
    in integer pl_tcIdx,
    in integer pl_varIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcIdx), 
        -1 < pl_tcIdx and 
        pl_tcIdx < sizeof(v_LGenBase_trafficCases))
      f_EPTF_Base_assert(%definitionId&": Invalid FSM TC variable index: "&
        int2str(pl_varIdx)&
        " TC: "&v_LGenBase_trafficCases[pl_tcIdx].privateName&" , TC variable IDs: "&log2str(v_LGenBase_trafficCases[pl_tcIdx].varList), 
        -1 < pl_varIdx and 
        pl_varIdx < sizeof(v_LGenBase_trafficCases[pl_tcIdx].varList))
    }
    return v_LGenBase_trafficCases[pl_tcIdx].varList[pl_varIdx].varId;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmVarInitValueFromStep
  // 
  //  Purpose:
  //    Retrieves the initial value of the FSM variable referred 
  //    by the step argument of the test step   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmVarInitValueFromStep(
    in EPTF_LGenBase_TestStepArgs pl_ptr,
    out EPTF_Var_DirectContent pl_content)
  runs on EPTF_LGenBase_Private_CT{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid context argument: "&log2str(pl_ptr.refContext.fRefArgs), 1<sizeof(pl_ptr.refContext.fRefArgs))
      f_EPTF_Base_assert(%definitionId&": Invalid entity index: "&int2str(pl_ptr.eIdx), -1 <pl_ptr.eIdx and pl_ptr.eIdx < sizeof(v_LGenBase_entities))
      f_EPTF_Base_assert(%definitionId&": Invalid FSM context index: "&int2str(pl_ptr.eIdx), -1 < pl_ptr.refContext.fCtxIdx and pl_ptr.refContext.fCtxIdx < sizeof(v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList))
    }
    var integer vl_tableIdx := v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tableIdx;
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid FSM table index in FSM: "&int2str(vl_tableIdx),-1 < vl_tableIdx and vl_tableIdx < sizeof(v_LGenBase_fsmTables));
    }
    pl_content := v_LGenBase_fsmTables[v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tableIdx].varListArray[pl_ptr.refContext.fRefArgs[1]][pl_ptr.refContext.fRefArgs[0]].initValue
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmVarParamsFromStep
  // 
  //  Purpose:
  //    Retrieves the EPTF_Variable index referred by the step argument of the test step,
  //    and the additional 2 integer parameters   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmVarParamsFromStep(
    in EPTF_LGenBase_TestStepArgs pl_ptr,
    out integer pl_varId,
    out EPTF_Var_DirectContent pl_param)
  runs on EPTF_LGenBase_Private_CT{
    pl_varId := f_EPTF_LGenBase_fsmVarIdFromStep(pl_ptr)
    if(2 < sizeof(pl_ptr.refContext.fRefArgs)){
      if (c_EPTF_Common_debugSwitch){
        f_EPTF_Base_assert(%definitionId&": Invalid parameter index: "&int2str(pl_ptr.refContext.fRefArgs[2])&
          "",-1 < pl_ptr.refContext.fRefArgs[2] and pl_ptr.refContext.fRefArgs[2] < sizeof(v_LGenBase_fsmTables[v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tableIdx].paramValues));
      }
      pl_param := v_LGenBase_fsmTables[v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tableIdx].paramValues[pl_ptr.refContext.fRefArgs[2]];
    }else{
      pl_param := { unknownVal := {omit}}
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmStatMeasParamsFromStep
  // 
  //  Purpose:
  //    Retrieves the StatMeas index referred by the step argument of the test step,
  //    and the additional parameters   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmStatMeasParamsFromStep(
    in EPTF_LGenBase_TestStepArgs pl_ptr,
    out integer pl_statMeasId,
    out EPTF_Var_DirectContent pl_param)
  runs on EPTF_LGenBase_Private_CT{
    pl_statMeasId := f_EPTF_LGenBase_fsmStatMeasIdFromStep(pl_ptr)
    if(2 < sizeof(pl_ptr.refContext.fRefArgs)){
      if (c_EPTF_Common_debugSwitch){
        f_EPTF_Base_assert(%definitionId&": Invalid parameter index: "&int2str(pl_ptr.refContext.fRefArgs[2])&
          "",-1 < pl_ptr.refContext.fRefArgs[2] and pl_ptr.refContext.fRefArgs[2] < sizeof(v_LGenBase_fsmTables[v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tableIdx].paramValues));
      }
      pl_param := v_LGenBase_fsmTables[v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tableIdx].paramValues[pl_ptr.refContext.fRefArgs[2]];
    }else{
      pl_param := { unknownVal := {omit}}
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmVarIdListFromStep
  // 
  //  Purpose:
  //    Retrieves the EPTF_Variable index referred by the step argument of the test step   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmVarIdListFromStep(
    in EPTF_LGenBase_TestStepArgs pl_ptr,
    inout EPTF_IntegerList pl_vars)
  runs on EPTF_LGenBase_Private_CT{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid context argument: "&log2str(pl_ptr.refContext.fRefArgs), 0 < sizeof(pl_ptr.refContext.fRefArgs) and 0==sizeof(pl_ptr.refContext.fRefArgs) mod 2)
      f_EPTF_Base_assert(%definitionId&": Invalid entity index: "&int2str(pl_ptr.eIdx), -1 <pl_ptr.eIdx and pl_ptr.eIdx < sizeof(v_LGenBase_entities))
      f_EPTF_Base_assert(%definitionId&": Invalid FSM context index: "&int2str(pl_ptr.eIdx), -1 < pl_ptr.refContext.fCtxIdx and pl_ptr.refContext.fCtxIdx < sizeof(v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList))
    }
    var integer vl_varCount := sizeof(pl_ptr.refContext.fRefArgs) / 2;
    pl_vars := {};
    for ( var integer vl_i := 0; vl_i < vl_varCount ; vl_i := vl_i+1 )
    {
      var EPTF_LGenBase_FsmObjectScope vl_scope := pl_ptr.refContext.fRefArgs[vl_i*2+1];
      var integer vl_varRefIdx := pl_ptr.refContext.fRefArgs[vl_i*2];
      select( vl_scope ){
        case ( c_EPTF_LGenBase_fsmObjectScopeFSM ){
          if (c_EPTF_Common_debugSwitch){
            f_EPTF_Base_assert(%definitionId&": Invalid FSM variable index: "&int2str(vl_varRefIdx), -1 < vl_varRefIdx and vl_varRefIdx < sizeof(v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].varList))
          }
          pl_vars[vl_i] := v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].varList[vl_varRefIdx];
        }
        case ( c_EPTF_LGenBase_fsmObjectScopeTC ){
          pl_vars[vl_i] := f_EPTF_LGenBase_fsmVarIdOfTC(
            v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tcIdx,
            vl_varRefIdx)
        }
        case else{
          f_EPTF_Base_assert(%definitionId&": Invalid FSM variable scope: "&int2str(vl_scope),false);
        }
      }
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmStatisticNameOfStep
  // 
  //  Purpose:
  //    Retrieves the index of the statistics referred by the step argument of the test step   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmStatisticNameOfStep(in EPTF_LGenBase_TestStepArgs pl_ptr)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid step context argument: "&log2str(pl_ptr.refContext.fRefArgs), 0 < sizeof(pl_ptr.refContext.fRefArgs))
      f_EPTF_Base_assert(%definitionId&": Invalid entity index: "&int2str(pl_ptr.eIdx), -1 <pl_ptr.eIdx and pl_ptr.eIdx < sizeof(v_LGenBase_entities))
      f_EPTF_Base_assert(%definitionId&": Invalid FSM context index: "&int2str(pl_ptr.eIdx), -1 < pl_ptr.refContext.fCtxIdx and pl_ptr.refContext.fCtxIdx < sizeof(v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList))
    }
    var integer vl_tableIdx := v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tableIdx;
    var integer vl_scope := pl_ptr.refContext.fRefArgs[1];
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid statistics scope: "&int2str(vl_scope), c_EPTF_LGenBase_fsmObjectScopeFirst <= vl_scope and vl_scope <= c_EPTF_LGenBase_fsmObjectScopeLast);
    }
    var integer vl_statIdxInScopeInFsm := pl_ptr.refContext.fRefArgs[0];
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid statistics index: "
        &int2str(vl_statIdxInScopeInFsm), 
        -1 < vl_statIdxInScopeInFsm and vl_statIdxInScopeInFsm < sizeof(v_LGenBase_fsmTables[vl_tableIdx].statisticListArray[vl_scope]))
    }
    var charstring vl_ret := "";
    select( vl_scope ){
      case ( c_EPTF_LGenBase_fsmObjectScopeFSM ){
        vl_ret := f_EPTF_LGenBase_varNameOfFSMVar(
          pl_ptr.eIdx, 
          pl_ptr.refContext.fCtxIdx, 
          v_LGenBase_fsmTables[vl_tableIdx].statisticListArray[vl_scope][vl_statIdxInScopeInFsm].name);
      }
      case ( c_EPTF_LGenBase_fsmObjectScopeSiblingFSM){
        var integer vl_siblingIdx := v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].siblingIdx;
        var integer vl_tcIdx := f_EPTF_LGenBase_tcIdxOfFSM(pl_ptr.eIdx, pl_ptr.refContext.fCtxIdx);
        if (c_EPTF_Common_debugSwitch){
          f_EPTF_Base_assert(%definitionId&": Invalid FSM TC statistic index: "&int2str(vl_statIdxInScopeInFsm), 
            -1 < vl_statIdxInScopeInFsm and 
            vl_statIdxInScopeInFsm < sizeof(v_LGenBase_trafficCases[vl_tcIdx].siblingFsmStatHandlerIdxInFsm[vl_siblingIdx]))
        }
        var integer vl_statIdx := v_LGenBase_trafficCases[vl_tcIdx].siblingFsmStatHandlerIdxInFsm[vl_siblingIdx][vl_statIdxInScopeInFsm];
        var charstring vl_statName := v_LGenBase_trafficCases[vl_tcIdx].siblingStatHandlerStatList[vl_statIdx].statName;
        var integer vl_eBaseOffset := v_LGenBase_entityGroups[v_LGenBase_trafficCases[vl_tcIdx].eGroupBackref].eOffset;
        vl_ret := f_EPTF_LGenBase_varNameOfSiblingFSMsVar(vl_tcIdx, pl_ptr.eIdx-vl_eBaseOffset, vl_statName);
      }
      case ( c_EPTF_LGenBase_fsmObjectScopeTC ){
        var integer vl_siblingIdx := v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].siblingIdx;
        var integer vl_tcIdx := f_EPTF_LGenBase_tcIdxOfFSM(pl_ptr.eIdx, pl_ptr.refContext.fCtxIdx);
        if (c_EPTF_Common_debugSwitch){
          f_EPTF_Base_assert(%definitionId&": Invalid FSM TC statistic index: "&int2str(vl_statIdxInScopeInFsm), 
            -1 < vl_statIdxInScopeInFsm and 
            vl_statIdxInScopeInFsm < sizeof(v_LGenBase_trafficCases[vl_tcIdx].statHandlerIdxInFsm[vl_siblingIdx]))
        }
        var integer vl_statIdx := v_LGenBase_trafficCases[vl_tcIdx].statHandlerIdxInFsm[vl_siblingIdx][vl_statIdxInScopeInFsm];
        vl_ret := f_EPTF_LGenBase_varNameOfTCVar(
          v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tcIdx,
          v_LGenBase_trafficCases[vl_tcIdx].statHandlerStatList[vl_statIdx].statName);
      }
      case else{
        f_EPTF_Base_assert(%definitionId&": Invalid FSM object scope: "&int2str(pl_ptr.refContext.fRefArgs[1]),false);
      }
    }
    return vl_ret; 
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_charstringValOfStep
  // 
  //  Purpose:
  //    Retrieves the charstring value referred by the step argument of the test step   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_charstringValOfStep(in EPTF_LGenBase_TestStepArgs pl_ptr)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    var integer vl_argIdx := pl_ptr.refContext.fRefArgs[0];
    var integer vl_tableIdx := v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tableIdx
    return f_EPTF_LGenBase_charstringValOfStepByIdx(vl_argIdx, vl_tableIdx);
  }
  
  private function f_EPTF_LGenBase_charstringValOfStepByIdx(
    in integer pl_argIdx,
    in integer pl_tableIdx)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    if(pl_argIdx >= sizeof(v_LGenBase_fsmTables[pl_tableIdx].paramValues)){
      f_EPTF_LGenBase_loggingError(%definitionId&": Invalid step argument. The referred index is greater than the argument list.");
    }
    if(not ischosen(v_LGenBase_fsmTables[pl_tableIdx].paramValues[pl_argIdx].charstringVal)){
      f_EPTF_LGenBase_loggingError(%definitionId&": Invalid step argument. The referred value is not charstring.");
    }
    return v_LGenBase_fsmTables[pl_tableIdx].paramValues[pl_argIdx].charstringVal;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_verdictOfStep
  // 
  //  Purpose:
  //    Retrieves the verdicttype value and a charstring reason
  //    referred by the step argument of the test step   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_verdictOfStep(
    in EPTF_LGenBase_TestStepArgs pl_ptr,
    out verdicttype pl_verdict,
    out charstring pl_reason)
  runs on EPTF_LGenBase_Private_CT{
    pl_reason := ""
    var integer vl_argIdx := pl_ptr.refContext.fRefArgs[0];
    var integer vl_tableIdx := v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tableIdx
    if(vl_argIdx >= sizeof(v_LGenBase_fsmTables[vl_tableIdx].verdictList)){
      f_EPTF_LGenBase_loggingError(%definitionId&": Invalid step argument. The referred index is greater than the verdict list.");
    }
    pl_verdict := v_LGenBase_fsmTables[vl_tableIdx].verdictList[vl_argIdx]
    if(-1 < pl_ptr.refContext.fRefArgs[1]){
      pl_reason := f_EPTF_LGenBase_charstringValOfStepByIdx(pl_ptr.refContext.fRefArgs[1], vl_tableIdx);
    }
  }
  
  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_varNameOfFSMVar
  // 
  //  Purpose:
  //    Retrieves the name of the variable declared in an FSM table with FSM scope   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_varNameOfFSMVar(
    in integer pl_eIdx,
    in integer pl_fsmIdx,
    in charstring pl_varName)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    return 
    c_EPTF_LGenBase_fsmVarScopePrefixes[c_EPTF_LGenBase_fsmObjectScopeFSM]&
    f_EPTF_LGenBase_getEntityName(pl_eIdx)&
    tsp_LGenBase_nameSeparator&
    v_LGenBase_fsmTables[v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fsmIdx].tableIdx].name&
    tsp_LGenBase_nameSeparator&
    int2str(pl_fsmIdx)&
    tsp_LGenBase_nameSeparator&
    pl_varName
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_varNameOfSiblingFSMsVar
  // 
  //  Purpose:
  //    Retrieves the name of the variable declared in an FSM table with FSM scope   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_varNameOfSiblingFSMsVar(
    in integer pl_tcIdx,
    in integer pl_eRelIdx,
    in charstring pl_varName)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcIdx), -1 <pl_tcIdx and pl_tcIdx < sizeof(v_LGenBase_trafficCases))
    }
    var charstring vl_tcName := v_LGenBase_trafficCases[pl_tcIdx].uniqueName
    return 
    c_EPTF_LGenBase_fsmVarScopePrefixes[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM]&
    vl_tcName&
    tsp_LGenBase_nameSeparator&
    log2str(pl_eRelIdx)&
    tsp_LGenBase_nameSeparator&
    pl_varName
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmStatMeasIdFromStep
  // 
  //  Purpose:
  //    Retrieves the EPTF_StatMeasure_Statistics index referred by the step argument of the test step   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmStatMeasIdFromStep(
    in EPTF_LGenBase_TestStepArgs pl_ptr)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid context argument: "&log2str(pl_ptr.refContext.fRefArgs), 1<sizeof(pl_ptr.refContext.fRefArgs))
      f_EPTF_Base_assert(%definitionId&": Invalid entity index: "&int2str(pl_ptr.eIdx), -1 <pl_ptr.eIdx and pl_ptr.eIdx < sizeof(v_LGenBase_entities))
      f_EPTF_Base_assert(%definitionId&": Invalid FSM context index: "&int2str(pl_ptr.refContext.fCtxIdx), -1 < pl_ptr.refContext.fCtxIdx and pl_ptr.refContext.fCtxIdx < sizeof(v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList))
    }
    select( pl_ptr.refContext.fRefArgs[1] ){
      case ( c_EPTF_LGenBase_fsmObjectScopeFSM ){
        if (c_EPTF_Common_debugSwitch){
          f_EPTF_Base_assert(%definitionId&": Invalid FSM measured statistic index: "&int2str(pl_ptr.refContext.fRefArgs[0]),
            -1 < pl_ptr.refContext.fRefArgs[0] and 
            pl_ptr.refContext.fRefArgs[0] < sizeof(v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].statMeasStatList))
        }
        return v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].statMeasStatList[pl_ptr.refContext.fRefArgs[0]];
      }
      case ( c_EPTF_LGenBase_fsmObjectScopeSiblingFSM ){
        var integer vl_tcIdx := v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tcIdx;
        var integer vl_tableIdx := v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tableIdx
        if (c_EPTF_Common_debugSwitch){
          f_EPTF_Base_assert(%definitionId&": There is no traffic case for the referred FSM SiblingFSM measured statistic. FSM table: "&
            v_LGenBase_fsmTables[vl_tableIdx].name&
            " Reported event: "&log2str(pl_ptr.reportedEvent),
            -1 < vl_tcIdx)
          f_EPTF_Base_assert(%definitionId&": Invalid FSM SiblingFSM measured statistic index: "&
            int2str(pl_ptr.refContext.fRefArgs[0])&
            "\nTC: "&v_LGenBase_trafficCases[vl_tcIdx].privateName
            &"\nFSM table: "&v_LGenBase_fsmTables[vl_tableIdx].name,
            -1 < pl_ptr.refContext.fRefArgs[0] and 
            pl_ptr.refContext.fRefArgs[0] < sizeof(v_LGenBase_fsmTables[vl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM]))
        }
        var integer vl_siblingIdx := v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].siblingIdx;
        var integer vl_idxInEntity := v_LGenBase_trafficCases[vl_tcIdx].siblingFsmStatMeasIdxInFsm[vl_siblingIdx][pl_ptr.refContext.fRefArgs[0]]
        var integer vl_eOffset := v_LGenBase_entityGroups[v_LGenBase_trafficCases[vl_tcIdx].eGroupBackref].eOffset
        return v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[pl_ptr.eIdx-vl_eOffset].siblingFsmStatMeasList[vl_idxInEntity]
      }
      case ( c_EPTF_LGenBase_fsmObjectScopeTC ){
        var integer vl_tcIdx := v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tcIdx;
        var integer vl_tableIdx := v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tableIdx
        if (c_EPTF_Common_debugSwitch){
          f_EPTF_Base_assert(%definitionId&": There is no traffic case for the referred FSM TC measured statistic. FSM table: "&
            v_LGenBase_fsmTables[vl_tableIdx].name&
            " Reported event: "&log2str(pl_ptr.reportedEvent),
            -1 < vl_tcIdx)
          f_EPTF_Base_assert(%definitionId&": Invalid FSM TC measured statistic index: "&
            int2str(pl_ptr.refContext.fRefArgs[0])&
            "\nTC: "&v_LGenBase_trafficCases[vl_tcIdx].privateName
            &"\nFSM table: "&v_LGenBase_fsmTables[vl_tableIdx].name,
            -1 < pl_ptr.refContext.fRefArgs[0] and 
            pl_ptr.refContext.fRefArgs[0] < sizeof(v_LGenBase_fsmTables[vl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC]))
        }
        var integer vl_siblingIdx := v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].siblingIdx;
        var integer vl_idxInTc := v_LGenBase_trafficCases[vl_tcIdx].statMeasIdxInFsm[vl_siblingIdx][pl_ptr.refContext.fRefArgs[0]]
        return v_LGenBase_trafficCases[vl_tcIdx].statMeasStatList[vl_idxInTc].statId;
      }
      case else{
        f_EPTF_Base_assert(%definitionId&": Invalid FSM measured statistic scope: "&int2str(pl_ptr.refContext.fRefArgs[1]),false);
      }
    }
    return -1;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmStatMeasIdOfFSM
  // 
  //  Purpose:
  //    Retrieves the EPTF_StatMeasure_Statistics index of the measured statistic of an FSM    
  // 
  //  Detailed comments:
  //    The function doesn't presume that the scope of the measured statistic
  //    is FSM. Both scopes are valid 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmStatMeasIdOfFSM(
    in integer pl_eIdx,
    in integer pl_fIdx,
    in charstring pl_statName)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity index: "&int2str(pl_eIdx), -1 <pl_eIdx and pl_eIdx < sizeof(v_LGenBase_entities))
      f_EPTF_Base_assert(%definitionId&": Invalid FSM context index: "&int2str(pl_fIdx), -1 < pl_fIdx and pl_fIdx < sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList))
    }
    //Find the declaration
    var integer vl_refIdx
    var boolean vl_statExists := f_EPTF_str2int_HashMap_Find(
      v_LGenBase_fsmTables[v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].tableIdx].statMeasNamesHash,
      pl_statName,
      vl_refIdx)
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": The measured statistic name "&pl_statName&
        " does not exist in FSM "&
        v_LGenBase_fsmTables[v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].tableIdx].name,
        vl_statExists)
    }
    select(v_LGenBase_fsmTables[v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].tableIdx].statMeasXRefs[vl_refIdx].scope){
      case(c_EPTF_LGenBase_fsmObjectScopeFSM){
        return v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].statMeasStatList[
          v_LGenBase_fsmTables[v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].tableIdx].statMeasXRefs[vl_refIdx].idxInScope]
      }
      case(c_EPTF_LGenBase_fsmObjectScopeTC){
        var integer vl_tcIdx := v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].tcIdx;
        return v_LGenBase_trafficCases[vl_tcIdx].statMeasStatList[
          v_LGenBase_fsmTables[v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].tableIdx].statMeasXRefs[vl_refIdx].idxInScope].statId;
      }
      case else{
        f_EPTF_Base_assert(%definitionId&": Invalid FSM measured statistic scope: "&int2str(v_LGenBase_fsmTables[v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].tableIdx].statMeasXRefs[vl_refIdx].scope),false);
        return -1
      }
    }
    return -1; // never executed, just to remove compilation warning
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmStatMeasIdOfTC
  // 
  //  Purpose:
  //    Retrieves the EPTF_StatMeasure_Statistics index of the measured statistic of an FSM    
  // 
  //  Errors:
  //    The function can be used to retrieve only measured statistics 
  //    with scope TC. In case of scope TC the function asserts
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmStatMeasIdOfTC(
    in integer pl_tcIdx,
    in charstring pl_statName)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcIdx), -1 <pl_tcIdx and pl_tcIdx < sizeof(v_LGenBase_trafficCases))
    }
    //Find the declaration
    for ( var integer vl_stat := 0; vl_stat < sizeof(v_LGenBase_trafficCases[pl_tcIdx].statMeasStatList) ; vl_stat := vl_stat+1 )
    {
      var integer vl_tableIdx := v_LGenBase_trafficCases[pl_tcIdx].fsmList[v_LGenBase_trafficCases[pl_tcIdx].statMeasStatList[vl_stat].siblingFsmIdx].fsmTypeIdx;
      var integer vl_statIdxInTable := v_LGenBase_trafficCases[pl_tcIdx].statMeasStatList[vl_stat].idxInFsm
      var charstring vl_name := v_LGenBase_fsmTables[vl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_statIdxInTable].name
      if(pl_statName == vl_name){
        return v_LGenBase_trafficCases[pl_tcIdx].statMeasStatList[vl_stat].statId;
      }
    }
    return -1
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmStatMeasIdOfSibling
  // 
  //  Purpose:
  //    Retrieves the EPTF_StatMeasure_Statistics index of the measured statistic of a sibling FSM    
  // 
  //  Errors:
  //    The function can be used to retrieve only measured statistics 
  //    with scope TC. In case of scope TC the function asserts
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmStatMeasIdOfSibling(
    in integer pl_tcIdx,
    in integer pl_eRelIdx,
    in charstring pl_statName)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcIdx), -1 <pl_tcIdx and pl_tcIdx < sizeof(v_LGenBase_trafficCases))
    }
    //Find the declaration
    log("pl_statName: ",pl_statName,
      "\nsiblingStatMeasStatList: ",v_LGenBase_trafficCases[pl_tcIdx].siblingStatMeasStatList,
      "\n",v_LGenBase_fsmTables)
    for ( var integer vl_stat := 0; vl_stat < sizeof(v_LGenBase_trafficCases[pl_tcIdx].siblingStatMeasStatList) ; vl_stat := vl_stat+1 ){
      var integer vl_siblingIdx := v_LGenBase_trafficCases[pl_tcIdx].siblingStatMeasStatList[vl_stat].siblingFsmIdx
      var integer vl_tableIdx := v_LGenBase_trafficCases[pl_tcIdx].fsmList[vl_siblingIdx].fsmTypeIdx;
      var integer vl_idxInTable := v_LGenBase_trafficCases[pl_tcIdx].siblingStatMeasStatList[vl_stat].idxInFsm
      if(v_LGenBase_fsmTables[vl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_idxInTable].name == pl_statName){
        return v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_eRelIdx].siblingFsmStatMeasList[vl_stat]
      }       
    }
    return -1
  }
  
  //TODO comment
  public function f_EPTF_LGenBase_siblingIdxInTc(
    in integer pl_tcIdx,
    in charstring pl_name)
  runs on EPTF_LGenBase_Private_CT return integer
  {
    for ( var integer i := 0; i < sizeof(v_LGenBase_trafficCases[pl_tcIdx].fsmList) ; i := i+1 )
    {
      if (v_LGenBase_trafficCases[pl_tcIdx].fsmList[i].siblingName == pl_name) {
        return i;
      }
    }
    return -1; // not found
  }
  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_checkFsmSource
  // 
  //  Purpose:
  //    Checks whether the eventSource of a teststep has correct values 
  //
  //  Detailed comments:
  //    -
  ///////////////////////////////////////////////////////////
  friend function f_EPTF_LGenBase_checkFsmSource(in charstring pl_id, in EPTF_LGenBase_TestStepArgs pl_args)
  runs on EPTF_LGenBase_Private_CT
  {
    f_EPTF_Base_assert(pl_id&" Source FSM should have a value", 
      ispresent(pl_args.reportedEvent.event.source));
    f_EPTF_Base_assert(pl_id&" Invalid source entity index",  
      (pl_args.reportedEvent.event.source.eIdx>=0 and pl_args.reportedEvent.event.source.eIdx<sizeof(v_LGenBase_entities)));
    f_EPTF_Base_assert(pl_id&" Source FSM should have a context index",  
      ispresent(pl_args.reportedEvent.event.source.fsmCtxIdx));
    f_EPTF_Base_assert(pl_id&" Invalid source FSM context index",  
      (pl_args.reportedEvent.event.source.fsmCtxIdx>=0 and pl_args.reportedEvent.event.source.fsmCtxIdx<sizeof(v_LGenBase_entities[pl_args.reportedEvent.event.source.eIdx].fsmCtxList)));
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmEventToSiblingFromStep
  // 
  //  Purpose:
  //    Retrieves the indexes of the entity, the fsm context, the behavior, the input and a variable referred by the EventToSibling step argument of the test step
  //
  //  Detailed comments:
  //    The type of the step argument in the FSM declaration must be
  //    <EPTF_LGenBase_EventToSibling>   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmEventToSiblingFromStep(
    in EPTF_LGenBase_TestStepArgs pl_ptr,
    out integer pl_eIdx,
    out integer pl_fsmCtxIdx,
    out integer pl_behaviorIdx,
    out integer pl_inputIdx,
    out integer pl_varId)
  runs on EPTF_LGenBase_Private_CT
  {
    pl_eIdx := pl_ptr.eIdx
    pl_behaviorIdx := pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventToSiblingBehavior]
    pl_inputIdx := pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventToSiblingInput]
    if(isbound(pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventToSiblingVarId0]) and
      -1 < pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventToSiblingVarId0]){
      pl_varId := f_EPTF_LGenBase_fsmVarIdFromStepData(
        pl_eIdx, pl_ptr.refContext.fCtxIdx, 
        pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventToSiblingVarId0],
        pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventToSiblingVarId1])
    }else{
      pl_varId := -1
    }
    var integer vl_siblingIdxOfCurrentFSM := 
    v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].siblingIdx
    var integer vl_tcIdx := f_EPTF_LGenBase_tcIdxOfStep(pl_ptr)
    var integer vl_targetSiblingIdx := 
    v_LGenBase_trafficCases[vl_tcIdx].referredFsmIdxsInSiblings[vl_siblingIdxOfCurrentFSM][pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventToSiblingRefFSM]]
    pl_fsmCtxIdx := f_EPTF_LGenBase_fsmCtxIdxOfSibling(pl_eIdx, vl_tcIdx, vl_targetSiblingIdx)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmCtxIdxOfSibling
  // 
  //  Purpose:
  //    Retrieves the FSM context index of an entity representing a
  //    sibling FSM in a traffic case. Based on the absolute index
  //    of the entity.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmCtxIdxOfSibling(
    in integer pl_eAbsIdx,
    in integer pl_tcIdx,
    in integer pl_siblingIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer
  {
    if(c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcIdx),
        -1 < pl_tcIdx and sizeof(v_LGenBase_trafficCases)> pl_tcIdx)
    }
    var integer vl_offset := v_LGenBase_entityGroups[v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref].eOffset
    var integer vl_eRelIdx := pl_eAbsIdx-vl_offset
    return f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc(vl_eRelIdx, pl_tcIdx, pl_siblingIdx);
  }  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc
  // 
  //  Purpose:
  //    Retrieves the FSM context index of an entity representing a
  //    sibling FSM in a traffic case. Based on the relative index
  //    of the entity.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc(
    in integer pl_eRelIdx,
    in integer pl_tcIdx,
    in integer pl_siblingIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer
  {
    if(c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcIdx),
        -1 < pl_tcIdx and sizeof(v_LGenBase_trafficCases)> pl_tcIdx)
      f_EPTF_Base_assert(%definitionId&": The specified entity#"&int2str(pl_eRelIdx)&
        " is not the member of the specified traffic case "&
        v_LGenBase_trafficCases[pl_tcIdx].uniqueName,
        -1 < pl_eRelIdx and sizeof(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList)>= pl_eRelIdx)
    }
    if(isbound(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_eRelIdx].siblingFsmCtxList[pl_siblingIdx])){
      return v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_eRelIdx].siblingFsmCtxList[pl_siblingIdx];
    }else{
      return -1;
    }
  }  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmReplyEventFromStep
  // 
  //  Purpose:
  //    Retrieves the indexes of the behavior, the input and a variable referred by the replyEvent step argument of the test step
  //
  //  Detailed comments:
  //    The type of the step argument in the FSM declaration must be
  //    <EPTF_LGenBase_EventToSibling>   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmReplyEventFromStep(
    in EPTF_LGenBase_TestStepArgs pl_ptr,
    out integer pl_behaviorIdx,
    out integer pl_inputIdx,
    out integer pl_varId)
  runs on EPTF_LGenBase_Private_CT
  {
    if (c_EPTF_Common_debugSwitch) { f_EPTF_LGenBase_checkFsmSource(%definitionId, pl_ptr) };
    pl_behaviorIdx := pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxReplyEventBehavior]
    pl_inputIdx := pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxReplyEventInput]
    if(isbound(pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxReplyEventVarId0]) and
      -1 < pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxReplyEventVarId0]){
      pl_varId := f_EPTF_LGenBase_fsmVarIdFromStepData(
        pl_ptr.eIdx, pl_ptr.refContext.fCtxIdx, 
        pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxReplyEventVarId0],
        pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxReplyEventVarId1])
    }else{
      pl_varId := -1
    }
  }
  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmEventToTcFromStep
  // 
  //  Purpose:
  //    Retrieves the indexes of the entity, the fsm context, the behavior, the input and a variable referred by the EventToTC step argument of the test step
  //
  //  Detailed comments:
  //    The type of the step argument in the FSM declaration must be
  //    <EPTF_LGenBase_EventToTc>   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmEventToTcFromStep(
    in EPTF_LGenBase_TestStepArgs pl_ptr,
    out integer pl_eIdx,
    out integer pl_fsmCtxIdx,
    out integer pl_behaviorIdx,
    out integer pl_inputIdx,
    out integer pl_varId)
  runs on EPTF_LGenBase_Private_CT
  {
    pl_eIdx := pl_ptr.eIdx;
    pl_behaviorIdx := pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventToTCBehavior]
    pl_inputIdx := pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventToTCInput]
    if(isbound(pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventToTCVarId0]) and
      -1 < pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventToTCVarId0]){
      pl_varId := f_EPTF_LGenBase_fsmVarIdFromStepData(
        pl_eIdx, pl_ptr.refContext.fCtxIdx, 
        pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventToTCVarId0],
        pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventToTCVarId1])
    }else{
      pl_varId := -1
    }
    var integer vl_tcIdx := f_EPTF_LGenBase_tcIdxOfStep(pl_ptr)
    var integer vl_targetSiblingIdx := 
    v_LGenBase_trafficCases[vl_tcIdx].referredTCIdxsInSiblings[pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventToTCRefFSM]][0];
    //Always dispatch to the first FSM
    pl_fsmCtxIdx := f_EPTF_LGenBase_fsmCtxIdxOfSibling(pl_eIdx, vl_targetSiblingIdx, 0)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_fsmEventOfFsmToSiblingFromStep
  // 
  //  Purpose:
  //    Retrieves the indexes of the entity, the fsm context, the behavior, the input and a variable referred by the EventOfFsmToSibling step argument of the test step
  //
  //  Detailed comments:
  //    The type of the step argument in the FSM declaration must be
  //    <EPTF_LGenBase_EventToSibling>   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_fsmEventOfFsmToSiblingFromStep(
    in EPTF_LGenBase_TestStepArgs pl_ptr,
    out integer pl_eIdx,
    out integer pl_fsmCtxIdx,
    out integer pl_behaviorIdx,
    out integer pl_inputIdx,
    out integer pl_varId)
  runs on EPTF_LGenBase_Private_CT
  {
    pl_eIdx := pl_ptr.eIdx
    //pl_behaviorIdx := pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventOfFsmToSiblingBehavior]
    
    pl_behaviorIdx :=  f_EPTF_LGenBase_behaviorTypeNameIndex(v_LGenBase_fsmTables[v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tableIdx].name);
    
    pl_inputIdx := pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventOfFsmToSiblingInput]
    if(isbound(pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventOfFsmToSiblingVarId0]) and
      -1 < pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventOfFsmToSiblingVarId0]){
      pl_varId := f_EPTF_LGenBase_fsmVarIdFromStepData(
        pl_eIdx, pl_ptr.refContext.fCtxIdx, 
        pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventOfFsmToSiblingVarId0],
        pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventOfFsmToSiblingVarId1])
    }else{
      pl_varId := -1
    }
    var integer vl_siblingIdxOfCurrentFSM := 
    v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].siblingIdx
    var integer vl_tcIdx := f_EPTF_LGenBase_tcIdxOfStep(pl_ptr)
    var integer vl_targetSiblingIdx := 
    v_LGenBase_trafficCases[vl_tcIdx].referredFsmIdxsInSiblings[vl_siblingIdxOfCurrentFSM][pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventOfFsmToSiblingRefFSM]]
    pl_fsmCtxIdx := f_EPTF_LGenBase_fsmCtxIdxOfSibling(pl_eIdx, vl_tcIdx, vl_targetSiblingIdx)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_eventOfFsmFromStep
  // 
  //  Purpose:
  //    Retrieves the indexs referred by the step argument of the test step
  //
  //  Detailed comments:
  //    The type of the step argument in the FSM declaration must be
  //    <EPTF_LGenBase_EventOfFsm>   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_eventOfFsmFromStep(
    in EPTF_LGenBase_TestStepArgs pl_ptr,
    out integer pl_behaviorIdx,
    out integer pl_inputIdx,
    out integer pl_varId)
  runs on EPTF_LGenBase_Private_CT
  {
    if (c_EPTF_Common_debugSwitch) { f_EPTF_LGenBase_checkFsmSource(%definitionId, pl_ptr) };
    pl_behaviorIdx :=  f_EPTF_LGenBase_behaviorTypeNameIndex(v_LGenBase_fsmTables[v_LGenBase_entities[pl_ptr.eIdx].fsmCtxList[pl_ptr.refContext.fCtxIdx].tableIdx].name);
    //    pl_behaviorIdx := pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxReplyEventBehavior]
    pl_inputIdx := pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventOfFsmInput]
    if(isbound(pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventOfFsmVarId0]) and
      -1 < pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventOfFsmVarId0]){
      pl_varId := f_EPTF_LGenBase_fsmVarIdFromStepData(
        pl_ptr.eIdx, pl_ptr.refContext.fCtxIdx, 
        pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventOfFsmVarId0],
        pl_ptr.refContext.fRefArgs[c_EPTF_LGenBase_stepArgsIdxEventOfFsmVarId1])
    }else{
      pl_varId := -1
    }
  }
  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_varNameOfTCVar
  // 
  //  Purpose:
  //    Retrieves the name of the variable declared in an FSM table with TC scope   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_varNameOfTCVar(
    in integer pl_tcIdx,
    in charstring pl_varName)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    return c_EPTF_LGenBase_fsmVarPrefix&
    c_EPTF_LGenBase_fsmVarScopePrefixes[c_EPTF_LGenBase_fsmObjectScopeTC]&
    v_LGenBase_trafficCases[pl_tcIdx].uniqueName&
    tsp_LGenBase_nameSeparator&
    pl_varName
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getScenarioTypeTcCount
  // 
  //  Purpose:
  //    Retrieves the count of traffic cases in the specified scenario type   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getScenarioTypeTcCount(
    in integer pl_scTypeIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid scenario type index.",pl_scTypeIdx > -1 and pl_scTypeIdx < sizeof(v_LGenBase_scenarioTypes));
    return sizeof(v_LGenBase_scenarioTypes[pl_scTypeIdx].tcList)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_scenarioName
  // 
  //  Purpose:
  //    Retrieves the name of the specified scenario   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_scenarioName(
    in integer pl_eGrpIdx, 
    in integer pl_scIdx) 
  runs on EPTF_LGenBase_Private_CT 
  return charstring {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_eGrpIdx),-1 < pl_eGrpIdx and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
      f_EPTF_Base_assert(%definitionId&": Invalid scenario index: "&int2str(pl_scIdx),-1 < pl_scIdx and pl_scIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios));
    }
    return v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].name;
  } 
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_entityGroupName
  // 
  //  Purpose:
  //    Returns the name of an entity group
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_entityGroupName(in integer pl_eGrpIdx)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    f_EPTF_Base_assert(%definitionId&": Invalid entity group index.",pl_eGrpIdx > -1 and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
    return v_LGenBase_entityGroups[pl_eGrpIdx].name;
  }
  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getNamePrefix
  // 
  //  Purpose:
  //    Retrieves the prefix for the names related to the specified TC   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getNamePrefix(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName
  )
  return charstring{
    return pl_eGrpName&tsp_LGenBase_nameSeparator&pl_scName&tsp_LGenBase_nameSeparator&pl_tcName&tsp_LGenBase_nameSeparator;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getScNamePrefix
  // 
  //  Purpose:
  //    Returns the prefix for the specified scenario
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getScNamePrefix(
    in charstring pl_eGrpName,
    in charstring pl_scName
  )
  return charstring{
    return pl_eGrpName&tsp_LGenBase_nameSeparator&pl_scName&tsp_LGenBase_nameSeparator;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBaseStats_getTCName
  // 
  //  Purpose:
  //    Retrieves the unique name of the specified TC   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBaseStats_getTCName(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName
  )
  return charstring{
    return pl_eGrpName&tsp_LGenBase_nameSeparator&pl_scName&tsp_LGenBase_nameSeparator&pl_tcName;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_isWeightedScenarioType
  // 
  //  Purpose:
  //    Sends <c_EPTF_LGenBase_inputIdx_testMgmt_stopTC> to the
  //    entities in the traffic case 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_isWeightedScenarioType(
    in integer plScTypeIdx)
  runs on EPTF_LGenBase_Private_CT return boolean{
    return (ispresent(v_LGenBase_scenarioTypes[plScTypeIdx].weightedScData))
  }  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_isWeightedScenario
  // 
  //  Purpose:
  //    Sends <c_EPTF_LGenBase_inputIdx_testMgmt_stopTC> to the
  //    entities in the traffic case 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_isWeightedScenario(
    in integer pl_eGrpIdx,
    in integer pl_scInGrpIdx)
  runs on EPTF_LGenBase_Private_CT return boolean{
    return (ispresent(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].weightedScData))
  }  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEntityName
  // 
  //  Purpose:
  //    Returns the name of the specified entity
  // 
  //  Parameters:
  //    pl_eIdx - *in* *integer* - the absolute index of the entity 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getEntityName(in integer pl_eIdx)
  runs on EPTF_LGenBase_Private_CT 
  return charstring{
    return v_LGenBase_entityNamePrefix&int2str(pl_eIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getNameOfEntityOfGrp
  // 
  //  Purpose:
  //    Returns the name of the specified entity
  // 
  //  Parameters:
  //    pl_eGrpIdx - *in* *integer* - the relative index of the entity 
  //    pl_eRelIdx - *in* *integer* - the absolute index of the entity 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getNameOfEntityOfGrp(
    in integer pl_eGrpIdx,
    in integer pl_eRelIdx)
  runs on EPTF_LGenBase_Private_CT 
  return charstring{
    f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_eGrpIdx),-1 < pl_eGrpIdx and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
    var integer vl_eAbsIdx := v_LGenBase_entityGroups[pl_eGrpIdx].eOffset+pl_eRelIdx;
    f_EPTF_Base_assert(%definitionId&": Invalid entity index.",vl_eAbsIdx > -1 and vl_eAbsIdx < sizeof(v_LGenBase_entities));
    return f_EPTF_LGenBase_getEntityName(vl_eAbsIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getFsmNameOfTc
  // 
  //  Purpose:
  //    Retrieves the name of the fsm with the specified
  //    traffic case index.   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getFsmNameOfTc(
    in integer pl_tcAbsIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return charstring {
    return f_EPTF_LGenBase_getFsmName(f_EPTF_LGenBase_getFsmIdxOfTc(pl_tcAbsIdx));
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getFsmIdxOfTc
  // 
  //  Purpose:
  //    Retrieves the index of the fsm with the specified
  //    traffic case index.   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getFsmIdxOfTc(
    in integer pl_tcAbsIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return integer {
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_tcAbsIdx > -1 and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases));
    return v_LGenBase_trafficCases[pl_tcAbsIdx].fsmIdx
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getFsmIndexByCtxIdx
  // 
  //  Purpose:
  //    Retrieves the index of the fsm with the specified
  //    entity index and FSM context index.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getFsmIndexByCtxIdx(
    in integer pl_eidx, in integer pl_fsmctxidx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid entity index: "&int2str(pl_eidx),-1 < pl_eidx and pl_eidx < sizeof(v_LGenBase_entities));
    f_EPTF_Base_assert(%definitionId&": Invalid FSM context index: "&int2str(pl_fsmctxidx),-1 < pl_fsmctxidx and pl_fsmctxidx < sizeof(v_LGenBase_entities[pl_eidx].fsmCtxList));
    
    return v_LGenBase_entities[pl_eidx].fsmCtxList[pl_fsmctxidx].tableIdx;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getFsmNameByCtxIdx
  // 
  //  Purpose:
  //    Retrieves the name of the fsm with the specified
  //    entity index and FSM context index.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getFsmNameByCtxIdx(
    in integer pl_eidx, in integer pl_fsmctxidx)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    return f_EPTF_LGenBase_getFsmName(f_EPTF_LGenBase_getFsmIndexByCtxIdx(pl_eidx, pl_fsmctxidx));
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getFsmIndexByStepArgs
  // 
  //  Purpose:
  //    Retrieves the index of the fsm with the specified
  //    test step arguments.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getFsmIndexByStepArgs(
    in EPTF_LGenBase_TestStepArgs pl_args)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    return f_EPTF_LGenBase_getFsmIndexByCtxIdx(pl_args.eIdx, pl_args.refContext.fCtxIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getFsmNameByStepArgs
  // 
  //  Purpose:
  //    Retrieves the name of the fsm with the specified
  //    test step arguments.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getFsmNameByStepArgs(
    in EPTF_LGenBase_TestStepArgs pl_args)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    return f_EPTF_LGenBase_getFsmName(f_EPTF_LGenBase_getFsmIndexByStepArgs(pl_args));
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getFsmStateIdxByCtxIdx
  // 
  //  Purpose:
  //    Retrieves the index of the FSM state referred by the
  //    specified entity index and FSM context index. 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getFsmStateIdxByCtxIdx(
    in integer pl_eidx, in integer pl_fsmctxidx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    if ((-1 < pl_eidx and pl_eidx < sizeof(v_LGenBase_entities))
      and
      (-1 < pl_fsmctxidx and pl_fsmctxidx < sizeof(v_LGenBase_entities[pl_eidx].fsmCtxList))){
      return v_LGenBase_entities[pl_eidx].fsmCtxList[pl_fsmctxidx].stateIdx
    }
    else{
      //Invalid entity index or Invalid FSM context index
      return -1;
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getFsmStateNameByCtxIdx
  // 
  //  Purpose:
  //    Retrieves the name of the FSM state referred by the
  //    specified entity index and FSM context index.   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getFsmStateNameByCtxIdx(
    in integer pl_eidx, in integer pl_fsmctxidx)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    var integer vl_fsmIdx := f_EPTF_LGenBase_getFsmIndexByCtxIdx(pl_eidx, pl_fsmctxidx);
    var integer vl_stateIdx := f_EPTF_LGenBase_getFsmStateIdxByCtxIdx(pl_eidx, pl_fsmctxidx);
    if (vl_stateIdx == -1){
      return "";
    }
    else{
      return v_LGenBase_fsmTables[vl_fsmIdx].stateList[vl_stateIdx];
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getFsmStateIdxByStepArgs
  // 
  //  Purpose:
  //    Retrieves the index of the FSM state referred 
  //    by the specified test step arguments. 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getFsmStateIdxByStepArgs(
    in EPTF_LGenBase_TestStepArgs pl_args)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    return f_EPTF_LGenBase_getFsmStateIdxByCtxIdx(pl_args.eIdx, pl_args.refContext.fCtxIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getFsmStateNameByStepArgs
  // 
  //  Purpose:
  //    Retrieves the name of the FSM state referred
  //    by the specified test step arguments.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getFsmStateNameByStepArgs(
    in EPTF_LGenBase_TestStepArgs pl_args)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    return f_EPTF_LGenBase_getFsmStateNameByCtxIdx(pl_args.eIdx, pl_args.refContext.fCtxIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getFsmName
  // 
  //  Purpose:
  //    Retrieves the name of the fsm with the specified index.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getFsmName(
    in integer pl_idx)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    f_EPTF_Base_assert(%definitionId&": Invalid FSM index: "&int2str(pl_idx),-1 < pl_idx and pl_idx < sizeof(v_LGenBase_fsmTables));
    return v_LGenBase_fsmTables[pl_idx].name;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setFsmDebugLight
  // 
  //  Purpose:
  //    Sets DebugLight for an FSM table.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setFsmDebugLight(
    in integer pl_idx,
    in boolean pl_enable)
  runs on EPTF_LGenBase_Private_CT
  {
    f_EPTF_Base_assert(%definitionId&": Invalid FSM index: "&int2str(pl_idx),-1 < pl_idx and pl_idx < sizeof(v_LGenBase_fsmTables));
    v_LGenBase_fsmTables[pl_idx].debugLight := pl_enable;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getFsmDebugLight
  // 
  //  Purpose:
  //    Gets DebugLight of an FSM table.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getFsmDebugLight(
    in integer pl_idx)
  runs on EPTF_LGenBase_Private_CT
  return boolean
  {
    f_EPTF_Base_assert(%definitionId&": Invalid FSM index: "&int2str(pl_idx),-1 < pl_idx and pl_idx < sizeof(v_LGenBase_fsmTables));
    return v_LGenBase_fsmTables[pl_idx].debugLight;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getNameOfExpiredTimer
  // 
  //  Purpose:
  //    Retrieves the name of the fsm with the specified index.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getNameOfExpiredTimer(
    in EPTF_LGenBase_TestStepArgs pl_args)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    var integer vl_timerIdx;
    if (sizeof(pl_args.stepArgs) > 0){
      vl_timerIdx := pl_args.stepArgs[0];
    }
    else{
      vl_timerIdx := -1;
    }
    var integer vl_fsmIdx := f_EPTF_LGenBase_getFsmIndexByStepArgs(pl_args);
    
    if (vl_fsmIdx > -1 and vl_fsmIdx < sizeof(v_LGenBase_fsmTables)
      and
      vl_timerIdx > -1 and vl_timerIdx < sizeof(v_LGenBase_fsmTables[vl_fsmIdx].timerList)){
      return v_LGenBase_fsmTables[vl_fsmIdx].timerList[vl_timerIdx].name;
    }
    else
    {
      return ""; 
    }
  }  
  
  ///////////////////////////////////////////////////////////
  //	Function:  f_EPTF_LGenBase_getAppDataItemOfEntityCtx
  //
  //	Purpose:
  //		Get the appData.behavior.item value of an Entity Context 
  //	Detailed comment:
  //
  ///////////////////////////////////////////////////////////   
  public function f_EPTF_LGenBase_getAppDataItemOfEntityCtx(
  	in integer pl_eAbsIdx,
  	in integer pl_bIdx,
    in integer pl_itemIdx)	
  runs on EPTF_LGenBase_Private_CT return integer
  {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": invalid entity abs. index:"&int2str(pl_eAbsIdx), pl_eAbsIdx>=0 and pl_eAbsIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&": invalid behavior type  index:"&int2str(pl_bIdx), pl_bIdx>=0 
        and pl_bIdx<sizeof(v_LGenBase_behaviorTypes));
      f_EPTF_Base_assert(%definitionId&": behavior type index for appdata is non-existent:"&int2str(pl_bIdx)&" for  entity "&int2str(pl_eAbsIdx), 
        pl_bIdx>=0 and pl_bIdx<sizeof(v_LGenBase_entities[pl_eAbsIdx].appData));
      f_EPTF_Base_assert(%definitionId&": invalid appdata item index:"&int2str(pl_itemIdx)&" for behavior type index "&int2str(pl_bIdx)&" for  entity "&int2str(pl_eAbsIdx), 
        pl_itemIdx>=0  and isbound(v_LGenBase_entities[pl_eAbsIdx].appData[pl_bIdx])
        and isbound(v_LGenBase_entities[pl_eAbsIdx].appData[pl_bIdx][pl_itemIdx])
        and pl_itemIdx<sizeof(v_LGenBase_entities[pl_eAbsIdx].appData[pl_bIdx]));
    }    
    return v_LGenBase_entities[pl_eAbsIdx].appData[pl_bIdx][pl_itemIdx];
  }

  ///////////////////////////////////////////////////////////
  //	Function:  f_EPTF_LGenBase_setAppDataItemOfEntityCtx
  //
  //	Purpose:
  //		set the appData.behavior.item value of an Entity Context 
  //	Detailed comment:
  //
  ///////////////////////////////////////////////////////////  
  public function f_EPTF_LGenBase_setAppDataItemOfEntityCtx(
  	in integer pl_eAbsIdx,
  	in integer pl_bIdx,
    in integer pl_itemIdx,
  	in integer pl_itemValue)
  runs on EPTF_LGenBase_Private_CT 
  {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": invalid entity abs. index:"&int2str(pl_eAbsIdx), pl_eAbsIdx>=0 and pl_eAbsIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&": invalid behavior type  index:"&int2str(pl_bIdx), pl_bIdx>=0 
        and pl_bIdx<sizeof(v_LGenBase_behaviorTypes));
      f_EPTF_Base_assert(%definitionId&": invalid appdata item index:"&int2str(pl_itemIdx)&" for behavior type index "&int2str(pl_bIdx)&" for  entity "&int2str(pl_eAbsIdx), 
        pl_itemIdx>=0);
    }    
    v_LGenBase_entities[pl_eAbsIdx].appData[pl_bIdx][pl_itemIdx] := pl_itemValue;
  }
  
  ///////////////////////////////////////////////////////////
  //	Function:  f_EPTF_LGenBase_getAppDataListOfEntityCtx
  //
  //	Purpose:
  //		Get the appData.behavior IntegerList of an Entity Context 
  //	Detailed comment:
  //
  ///////////////////////////////////////////////////////////  
  public function f_EPTF_LGenBase_getAppDataListOfEntityCtx(	
  	in integer pl_eAbsIdx,
  	in integer pl_bIdx,
  	out EPTF_IntegerList pl_list)
  runs on EPTF_LGenBase_Private_CT
  {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": invalid entity abs. index:"&int2str(pl_eAbsIdx), pl_eAbsIdx>=0 and pl_eAbsIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&": invalid behavior type  index:"&int2str(pl_bIdx), pl_bIdx>=0 
        and pl_bIdx<sizeof(v_LGenBase_behaviorTypes));
    }    
    if (isbound(v_LGenBase_entities[pl_eAbsIdx].appData[pl_bIdx])) {
      pl_list := v_LGenBase_entities[pl_eAbsIdx].appData[pl_bIdx];
    } else {
      pl_list := {};
    }
  }
  
  ///////////////////////////////////////////////////////////
  //	Function:  f_EPTF_LGenBase_setAppDataListOfEntityCtx
  //
  //	Purpose:
  //		Set the appData.behavior IntegerList of an Entity Context 
  //	Detailed comment:
  //
  ///////////////////////////////////////////////////////////  
  public function f_EPTF_LGenBase_setAppDataListOfEntityCtx(
  	in integer pl_eAbsIdx,
  	in integer pl_bIdx,
  	in EPTF_IntegerList pl_list)
  runs on EPTF_LGenBase_Private_CT 
  {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": invalid entity abs. index:"&int2str(pl_eAbsIdx), pl_eAbsIdx>=0 and pl_eAbsIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&": invalid behavior type  index:"&int2str(pl_bIdx), pl_bIdx>=0 
        and pl_bIdx<sizeof(v_LGenBase_behaviorTypes));
    }
    v_LGenBase_entities[pl_eAbsIdx].appData[pl_bIdx] := pl_list;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getAppDataListOfFsmCtx
  // 
  //  Purpose:
  //    Returns the whole application data assigned to the FSM context
  //
  //  Detailed comment:
  //    Be careful using this function during load generation, because
  //    retrieving a record of integers can be slow   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getAppDataListOfFsmCtx(
    in integer pl_eAbsIdx, 
    in integer pl_fCtxIdx, 
    in integer pl_bIdx)
  runs on EPTF_LGenBase_Private_CT
  return EPTF_IntegerList 
  {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": invalid entity abs. index:"&int2str(pl_eAbsIdx), pl_eAbsIdx>=0 and pl_eAbsIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&": invalid FSM ctx index:"&int2str(pl_fCtxIdx)&" referred for  entity "&int2str(pl_eAbsIdx), pl_fCtxIdx>=0 
        and pl_fCtxIdx<sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList));
      f_EPTF_Base_assert(%definitionId&": invalid behavior type  index:"&int2str(pl_bIdx), pl_bIdx>=0 
        and pl_bIdx<sizeof(v_LGenBase_behaviorTypes));
    }    
    if (isbound(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].appData[pl_bIdx])) {
      return v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].appData[pl_bIdx]
    } else {
      return {}
    }
    
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setAppDataListOfFsmCtx
  // 
  //  Purpose:
  //    Sets the whole application data assigned to the FSM context   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setAppDataListOfFsmCtx(in integer pl_eAbsIdx, in integer pl_fCtxIdx, in integer pl_bIdx, in EPTF_IntegerList pl_list) //Beware! Slow!
  runs on EPTF_LGenBase_Private_CT 
  {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": invalid entity abs. index:"&int2str(pl_eAbsIdx), pl_eAbsIdx>=0 and pl_eAbsIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&": invalid FSM ctx index:"&int2str(pl_fCtxIdx)&" referred for  entity "&int2str(pl_eAbsIdx), pl_fCtxIdx>=0 
        and pl_fCtxIdx<sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList));
      f_EPTF_Base_assert(%definitionId&": invalid behavior type  index:"&int2str(pl_bIdx), pl_bIdx>=0 
        and pl_bIdx<sizeof(v_LGenBase_behaviorTypes));
    }
    v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].appData[pl_bIdx] := pl_list
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getAppDataItemOfFsmCtx
  // 
  //  Purpose:
  //    Returns an element of the application data assigned to the FSM context   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getAppDataItemOfFsmCtx(
    in integer pl_eAbsIdx,
    in integer pl_fCtxIdx,
    in integer pl_bIdx,
    in integer pl_itemIdx)
  runs on EPTF_LGenBase_Private_CT return integer 
  {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": invalid entity abs. index:"&int2str(pl_eAbsIdx), pl_eAbsIdx>=0 and pl_eAbsIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&": invalid FSM ctx index:"&int2str(pl_fCtxIdx)&" referred for  entity "&int2str(pl_eAbsIdx), pl_fCtxIdx>=0 
        and pl_fCtxIdx<sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList));
      f_EPTF_Base_assert(%definitionId&": invalid behavior type  index:"&int2str(pl_bIdx), pl_bIdx>=0 
        and pl_bIdx<sizeof(v_LGenBase_behaviorTypes));
      f_EPTF_Base_assert(%definitionId&": behavior type index for appdata is non-existent:"&int2str(pl_bIdx)&" referred for FSM ctx index:"&int2str(pl_fCtxIdx)&" for  entity "&int2str(pl_eAbsIdx), 
        pl_bIdx>=0 and pl_bIdx<sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].appData));
      f_EPTF_Base_assert(%definitionId&": invalid appdata item index:"&int2str(pl_itemIdx)&" for behavior type index "&int2str(pl_bIdx)&" referred for FSM ctx index:"&int2str(pl_fCtxIdx)&" for  entity "&int2str(pl_eAbsIdx), 
        pl_itemIdx>=0  and isbound(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].appData[pl_bIdx])
        and isbound(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].appData[pl_bIdx][pl_itemIdx]) and pl_itemIdx<sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].appData[pl_bIdx]));
    }    
    return v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].appData[pl_bIdx][pl_itemIdx]
    
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getAppDataSizeOfFsmCtx
  // 
  //  Purpose:
  //    Returns an size of the application data assigned to the FSM context 
  //
  //  Detailed Comments:
  //    Returns 0 if the appData contains unbound elements, and the data can 
  //    not be retrieved by the function <f_EPTF_LGenBase_getAppDataListOfFsmCtx>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getAppDataSizeOfFsmCtx(
    in integer pl_eAbsIdx,
    in integer pl_fCtxIdx,
    in integer pl_bIdx)
  runs on EPTF_LGenBase_Private_CT return integer 
  {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": invalid entity abs. index:"&int2str(pl_eAbsIdx), pl_eAbsIdx>=0 and pl_eAbsIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&": invalid FSM ctx index:"&int2str(pl_fCtxIdx)&" referred for  entity "&int2str(pl_eAbsIdx), pl_fCtxIdx>=0 
        and pl_fCtxIdx<sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList));
      f_EPTF_Base_assert(%definitionId&": invalid behavior type  index:"&int2str(pl_bIdx), pl_bIdx>=0 
        and pl_bIdx<sizeof(v_LGenBase_behaviorTypes));
    }
    if (isbound(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].appData[pl_bIdx])) {
      return sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].appData[pl_bIdx])
    } else {
      return 0
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_isvalueAppDataItemOfFsmCtx
  // 
  //  Purpose:
  //    Returns an element of the application data assigned to the FSM context   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_isvalueAppDataItemOfFsmCtx(
    in integer pl_eAbsIdx,
    in integer pl_fCtxIdx,
    in integer pl_bIdx,
    in integer pl_itemIdx)
  runs on EPTF_LGenBase_Private_CT return boolean 
  {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": invalid entity abs. index:"&int2str(pl_eAbsIdx), pl_eAbsIdx>=0 and pl_eAbsIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&": invalid FSM ctx index:"&int2str(pl_fCtxIdx)&" referred for  entity "&int2str(pl_eAbsIdx), pl_fCtxIdx>=0 
        and pl_fCtxIdx<sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList));
      f_EPTF_Base_assert(%definitionId&": invalid behavior type  index:"&int2str(pl_bIdx), pl_bIdx>=0 
        and pl_bIdx<sizeof(v_LGenBase_behaviorTypes));
    }    
    return isbound(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].appData[pl_bIdx][pl_itemIdx])
    
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setAppDataItemOfFsmCtx
  // 
  //  Purpose:
  //    Sets an element of the application data assigned to the FSM context   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setAppDataItemOfFsmCtx(in integer pl_eAbsIdx, in integer pl_fCtxIdx, in integer pl_bIdx, in integer pl_itemIdx, in integer  pl_itemValue) 
  runs on EPTF_LGenBase_Private_CT 
  {
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": invalid entity abs. index:"&int2str(pl_eAbsIdx), pl_eAbsIdx>=0 and pl_eAbsIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&": invalid FSM ctx index:"&int2str(pl_fCtxIdx)&" referred for  entity "&int2str(pl_eAbsIdx), pl_fCtxIdx>=0 
        and pl_fCtxIdx<sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList));
      f_EPTF_Base_assert(%definitionId&": invalid behavior type  index:"&int2str(pl_bIdx), pl_bIdx>=0 
        and pl_bIdx<sizeof(v_LGenBase_behaviorTypes));
      //EGBOZIE:no need for valid itemix for set
      ///f_EPTF_Base_assert(%definitionId&": invalid appdata item index:"&int2str(pl_bIdx)&" referred for FSM ctx index:"&int2str(pl_fCtxIdx)&" for  entity "&int2str(pl_eAbsIdx), 
      //  pl_itemIdx>=0  and pl_itemIdx<sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].appData[pl_bIdx]));
    }    
    v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].appData[pl_bIdx][pl_itemIdx] := pl_itemValue
  }
  
  group appDataOfEG{
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_getAppDataListOfEG
    // 
    //  Purpose:
    //    Returns the whole application data assigned to the entity group
    //
    //  Detailed comment:
    //    Be careful using this function during load generation, because
    //    retrieving a record of integers can be slow   
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_getAppDataListOfEG(
      in integer pl_eGrpIdx, 
      in integer pl_bIdx,
      out EPTF_IntegerList pl_ret)
    runs on EPTF_LGenBase_Private_CT
    {
      if (c_EPTF_Common_debugSwitch){
        f_EPTF_Base_assert(%definitionId&": invalid entity group index:"&int2str(pl_eGrpIdx), pl_eGrpIdx>=0 and pl_eGrpIdx<sizeof(v_LGenBase_entityGroups));
        f_EPTF_Base_assert(%definitionId&": invalid behavior type  index:"&int2str(pl_bIdx), pl_bIdx>=0 
          and pl_bIdx<sizeof(v_LGenBase_behaviorTypes));
      }      
      if (isbound(v_LGenBase_entityGroups[pl_eGrpIdx].appData[pl_bIdx])) {
        pl_ret := v_LGenBase_entityGroups[pl_eGrpIdx].appData[pl_bIdx]
      }else{
        pl_ret := {}
      }      
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_setAppDataListOfEG
    // 
    //  Purpose:
    //    Sets the whole application data assigned to entity group   
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_setAppDataListOfEG(
      in integer pl_eGrpIdx, 
      in integer pl_bIdx,
      in EPTF_IntegerList pl_list) //Beware! Slow!
    runs on EPTF_LGenBase_Private_CT 
    {
      if (c_EPTF_Common_debugSwitch){
        f_EPTF_Base_assert(%definitionId&": invalid entity group index:"&int2str(pl_eGrpIdx), pl_eGrpIdx>=0 and pl_eGrpIdx<sizeof(v_LGenBase_entityGroups));
        f_EPTF_Base_assert(%definitionId&": invalid behavior type  index:"&int2str(pl_bIdx), pl_bIdx>=0 
          and pl_bIdx<sizeof(v_LGenBase_behaviorTypes));
      }
      v_LGenBase_entityGroups[pl_eGrpIdx].appData[pl_bIdx] := pl_list
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_getAppDataItemOfEG
    // 
    //  Purpose:
    //    Returns an element of the application data assigned to the entity group   
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_getAppDataItemOfEG(
      in integer pl_eGrpIdx, 
      in integer pl_bIdx,
      in integer pl_itemIdx)
    runs on EPTF_LGenBase_Private_CT return integer 
    {
      if (c_EPTF_Common_debugSwitch){
        f_EPTF_Base_assert(%definitionId&": invalid entity group index:"&int2str(pl_eGrpIdx), pl_eGrpIdx>=0 and pl_eGrpIdx<sizeof(v_LGenBase_entityGroups));
        f_EPTF_Base_assert(%definitionId&": invalid behavior type  index:"&int2str(pl_bIdx), pl_bIdx>=0 
          and pl_bIdx<sizeof(v_LGenBase_behaviorTypes));
        f_EPTF_Base_assert(%definitionId&": behavior type index for appdata is non-existent:"&int2str(pl_bIdx)&" referred for entity group "&int2str(pl_eGrpIdx), 
          pl_bIdx<sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].appData));
        f_EPTF_Base_assert(%definitionId&": invalid appdata item index:"&int2str(pl_itemIdx)&" for behavior type index "&int2str(pl_bIdx)&" referred for entity group "&int2str(pl_eGrpIdx), 
          pl_itemIdx>=0  and isbound(v_LGenBase_entityGroups[pl_eGrpIdx].appData[pl_bIdx][pl_itemIdx]));
      }
      return v_LGenBase_entityGroups[pl_eGrpIdx].appData[pl_bIdx][pl_itemIdx]
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_getAppDataSizeOfEG
    // 
    //  Purpose:
    //    Returns an size of the application data assigned to the entity group   
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_getAppDataSizeOfEG(
      in integer pl_eGrpIdx, 
      in integer pl_bIdx)
    runs on EPTF_LGenBase_Private_CT return integer 
    {
      if (c_EPTF_Common_debugSwitch){
        f_EPTF_Base_assert(%definitionId&": invalid entity group index:"&int2str(pl_eGrpIdx), pl_eGrpIdx>=0 and pl_eGrpIdx<sizeof(v_LGenBase_entityGroups));
        f_EPTF_Base_assert(%definitionId&": invalid behavior type  index:"&int2str(pl_bIdx), pl_bIdx>=0 
          and pl_bIdx<sizeof(v_LGenBase_behaviorTypes));
      }
      if (isbound(v_LGenBase_entityGroups[pl_eGrpIdx].appData[pl_bIdx])) {
        return sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].appData[pl_bIdx])
      } else {
        return 0
      }
    }
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_isvalueAppDataItemOfEG
    // 
    //  Purpose:
    //    Returns an element of the application data assigned to the entity group   
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_isvalueAppDataItemOfEG(
      in integer pl_eGrpIdx, 
      in integer pl_bIdx,
      in integer pl_itemIdx)
    runs on EPTF_LGenBase_Private_CT return boolean 
    {
      return isbound(v_LGenBase_entityGroups[pl_eGrpIdx].appData[pl_bIdx][pl_itemIdx])
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_setAppDataItemOfEG
    // 
    //  Purpose:
    //    Sets an element of the application data assigned to the entity group   
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_setAppDataItemOfEG(
      in integer pl_eGrpIdx, 
      in integer pl_bIdx,
      in integer pl_itemIdx,
      in integer  pl_itemValue) 
    runs on EPTF_LGenBase_Private_CT 
    {
      if (c_EPTF_Common_debugSwitch){
        f_EPTF_Base_assert(%definitionId&": invalid entity group index:"&int2str(pl_eGrpIdx), pl_eGrpIdx>=0 and pl_eGrpIdx<sizeof(v_LGenBase_entityGroups));
        f_EPTF_Base_assert(%definitionId&": invalid behavior type  index:"&int2str(pl_bIdx), pl_bIdx>=0 
          and pl_bIdx<sizeof(v_LGenBase_behaviorTypes));
      }
      v_LGenBase_entityGroups[pl_eGrpIdx].appData[pl_bIdx][pl_itemIdx] := pl_itemValue
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getStatisticsOfTcs
  // 
  //  Purpose:
  //    Retrieves the list of FSM statHandler statistics with TC scope   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getStatisticsOfTcs(out EPTF_LGenBase_StatisticListOfTCList pl_list)
  runs on EPTF_LGenBase_Private_CT{
    pl_list := {}
    for ( var integer vl_tc := 0; vl_tc < sizeof(v_LGenBase_trafficCases) ; vl_tc := vl_tc+1 ){
      pl_list[vl_tc] := c_EPTF_LGenBase_emptyStatisticListOfTC
      f_EPTF_LGenBase_trafficCaseIdNames(
        vl_tc,
        pl_list[vl_tc].entityGroup,
        pl_list[vl_tc].scenario,
        pl_list[vl_tc].tc)
      f_EPTF_LGenBase_tcStats(vl_tc, pl_list[vl_tc].stats)
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getStatisticsOfTcs
  // 
  //  Purpose:
  //    Retrieves an FSM table for debug purposes   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getFSMTable(in integer pl_Idx)
  runs on EPTF_LGenBase_Private_CT
  return EPTF_LGenBase_InternalFsmTable{
    return v_LGenBase_fsmTables[pl_Idx]
  }
  
}//GetSet

///////////////////////////////////////////////////////////
//  Group: DebugLogs
// 
//  Purpose:
//    Various debug log functions
//
//  Members:
group DebugLogs {
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_logEntity
  // 
  //  Purpose:
  //    Returns the name of the specified entity
  // 
  //  Parameters:
  //    pl_eIdx - *in* *integer* - the absolute index of the entity 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_logEntity(in integer pl_eIdx)
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_LGenBase_loggingDebugConfig(f_EPTF_LGenBase_getEntityName(pl_eIdx));
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_log
  // 
  //  Purpose:
  //    EPTF_LGenBase debug log of database
  //
  //  Parameters:
  //    -
  //
  //  Return Value:
  //    -
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_log() runs on EPTF_LGenBase_Private_CT{
    if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
      f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId, ": behaviorTypes:=", v_LGenBase_behaviorTypes))
      f_EPTF_LGenBase_loggingDebugConfig(log2str(": entities:=",v_LGenBase_entities))
      f_EPTF_LGenBase_loggingDebugConfig(log2str(": testSteps:=", v_LGenBase_testSteps))
      
      //f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId, ": fsmEventListeners:=", v_LGenBase_fsmEventListeners))
      
      f_EPTF_LGenBase_debugLogFsmEvents();
      //f_EPTF_LGenBase_debugLogFsmStates();
      f_EPTF_LGenBase_debugLogCompactFsmTables();
      f_EPTF_LGenBase_debugLogListeners();
      //  for (var integer i:=0; i<sizeof(v_LGenBase_trafficCases); i:=i+1){
      //    f_EPTF_LGenBase_logTrafficCase(i);
      //  }
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_debugLogFsmEvents
  // 
  //  Purpose:
  //    EPTF_LGenBase debuglog of FSM inputs
  //
  //  Parameters:
  //    -
  //
  //  Return Value:
  //    -
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_debugLogFsmEvents() 
  runs on EPTF_LGenBase_Private_CT {
    for (var integer b := 0; b<sizeof(v_LGenBase_behaviorTypes);b:=b+1){
      f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId, ":dumping FSM inputs of behavior type ", f_EPTF_LGenBase_bIdx2Str(b)))
      for (var integer i := 0; i<sizeof (v_LGenBase_fsmEvents[b]); i:=i+1){
        f_EPTF_LGenBase_loggingDebugConfig(log2str("==>Behavior(",f_EPTF_LGenBase_bIdx2Str(b),"):Event[",i,"]==", v_LGenBase_fsmEvents[b][i]))
      }
    }
  }
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_debugLogCompactFsmTables
  // 
  //  Purpose:
  //    EPTF_LGenBase debuglog of FSM tables
  //
  //  Parameters:
  //    -
  //
  //  Return Value:
  //    -
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_debugLogCompactFsmTables() 
  runs on EPTF_LGenBase_Private_CT {
    for (var integer t := 0; t<sizeof(v_LGenBase_fsmTables);t:=t+1){
      f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId, ":dumping FSM[",t,"]:", v_LGenBase_fsmTables[t].name))
      f_EPTF_LGenBase_loggingDebugConfig("================================")   
      for (var integer s := 0; s<sizeof (v_LGenBase_fsmTables[t].stateList); s:=s+1){
        f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId,": stateList[",s,"]==",v_LGenBase_fsmTables[t].stateList[s]))
      }
      /*TODO
      for (var integer r := 0; r<sizeof (v_LGenBase_fsmTables[t].table); r:=r+1){
      var integer b := v_LGenBase_fsmTables[t].table[r].eventToListen.bIdx,
      i := v_LGenBase_fsmTables[t].table[r].eventToListen.iIdx;
      var charstring bName:= f_EPTF_LGenBase_bIdx2Str(b),
      iName := f_EPTF_LGenBase_iIdx2Str(b,i); 
      f_EPTF_LGenBase_loggingDebugConfig("--------------------------------");
      f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId, ": event[",i,"] of behavior ", bName, "==",iName
      , ", of type ", v_LGenBase_fsmTables[t].table[r].eventToListen.eventType))
      for (var integer c:=0;c<sizeof(v_LGenBase_fsmTables[t].table[r].cellRow); c:=c+1) {
      f_EPTF_LGenBase_loggingDebugConfig(log2str("==>state=",v_LGenBase_fsmTables[t].stateList[c],
      "\tcell[",r,"][",c,"]=(", v_LGenBase_fsmTables[t].table[r].cellRow[c].actionList
      ,",",v_LGenBase_fsmTables[t].table[r].cellRow[c].nextState,")"))
      }      
      }*/
      f_EPTF_LGenBase_loggingDebugConfig("--------------------------------");
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_debugLogListeners
  // 
  //  Purpose:
  //    EPTF_LGenBase debuglog of listeners' table
  //
  //  Parameters:
  //    -
  //
  //  Return Value:
  //    -
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_debugLogListeners() runs on EPTF_LGenBase_Private_CT {
    //TODO implement new one
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getStatisticsOfTcs
  // 
  //  Purpose:
  //    Retrieves an FSM table for debug purposes   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_debugLogTrafficCases()
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_LGenBase_loggingDebugConfig(log2str(v_LGenBase_trafficCases));
  }
  
}//group DebugLogs

///////////////////////////////////////////////////////////
//  Group: Conversion
// 
//  Purpose:
//    Conversion functions
///////////////////////////////////////////////////////////
group Conversion{
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_bIdx2Str
  // 
  //  Purpose:
  //    Reports names of behavior types, including the special interna; behavior
  //    types with negative indices
  //
  //  Parameters:
  //    -
  //
  //  Return Value:
  //    -
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //    Use it in order to avoid indexing <v_LGenBase_behaviorTypes> directly
  //    with potentially negative indices.
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_bIdx2Str(in integer pl_bIdx) 
  runs on EPTF_LGenBase_Private_CT return charstring {
    if(pl_bIdx>=0 and pl_bIdx<sizeof(v_LGenBase_behaviorTypes)) {
      return v_LGenBase_behaviorTypes[pl_bIdx].name
    } else {
      select (pl_bIdx) {
        case(c_EPTF_LGenBase_specialBIdx_timerTimeout) {return c_EPTF_LGenBase_specialBName_timerTimeout}
        case else {
          f_EPTF_Base_assert(%definitionId& " special behaviorType must be known",false)
          return "Oops, unknown behaviorType"//never used
        }
      }
    }
    return ""; // never executed, just to remove compilation warning
  } 
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_iIdx2Str
  // 
  //  Purpose:
  //    Reports names of events, including the special internal events
  //
  //  Parameters:
  //    -
  //
  //  Return Value:
  //    -
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //    Use it in order to avoid indexing <v_LGenBase_behaviorTypes> directly
  //    with potentially negative indices.
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_iIdx2Str(in integer pl_bIdx,in integer pl_iIdx, in integer pl_fsmTableIdx := -1) 
  runs on EPTF_LGenBase_Private_CT return charstring {
    if(pl_bIdx>=0 and pl_bIdx<sizeof(v_LGenBase_behaviorTypes)) {
      return v_LGenBase_fsmEvents[pl_bIdx][pl_iIdx].name;
    } else {
      select (pl_bIdx) {
        case(c_EPTF_LGenBase_specialBIdx_timerTimeout) {
          var charstring vl_timerName
          if(-1 < pl_fsmTableIdx and pl_fsmTableIdx < sizeof(v_LGenBase_fsmTables) and
            -1 < pl_iIdx and pl_iIdx < sizeof(v_LGenBase_fsmTables[pl_fsmTableIdx].timerList)){
            vl_timerName := " "&v_LGenBase_fsmTables[pl_fsmTableIdx].timerList[pl_iIdx].name
          }else{
            vl_timerName := "["&int2str(pl_iIdx)&"]"
          }
          return "Timeout of the FSM timer"&vl_timerName}
        case else {
          f_EPTF_Base_assert(%definitionId& " special behaviorType must be known",false)
          return "Oops, unknown behaviorType"//never used
        }
      }
    }
    return ""; // never executed, just to remove compilation warning
  }

} // Conversion

///////////////////////////////////////////////////////////
//  Group: Validation
// 
//  Purpose:
//    Validation functions
///////////////////////////////////////////////////////////
group Validation{
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_validateIdxList
  // 
  //  Purpose:
  //    Validates whether an integer list
  //    contains only valid indexes of an other record of elements
  // 
  //  Parameters:
  //    pl_idxList - *in* <EPTF_IntegerList> The list of indexes 
  //    pl_size - *in* *integer* - the size of the record to which 
  //    the elements of the pl_idxList must point in.
  //
  //  Return Value:
  //    True if all the indexes are valid
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_validateIdxList(
    in EPTF_IntegerList pl_idxList, 
    in integer pl_size)
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    var integer vl_sizeof_pl_idxList := sizeof(pl_idxList);
    if(0 == pl_size and vl_sizeof_pl_idxList > 0){
      return false;
    }
    for(var integer vl_i := 0; vl_i < vl_sizeof_pl_idxList; vl_i := vl_i + 1){
      if(pl_idxList[vl_i] >= pl_size or 0 > pl_idxList[vl_i]){
        return false;
      }
    }
    return true;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_validateScenarioType
  // 
  //  Purpose:
  //    Internal function to validate scenario
  // 
  //  Detailed Comments:
  //    A scenario is a collection of traffic cases.
  //    However a traffic case can be the member of more than one scenario,
  //    finish actions of the traffic cases of a scenario 
  //    must not point out from the scenario i.e. they can start
  //    or stop traffic cases existing in the scenario.
  //    This internal function is called only as an assertion condition. 
  // 
  //  Return Value:
  //    True if the properties are valid
  ///////////////////////////////////////////////////////////
  friend function f_EPTF_LGenBase_validateScenarioType(inout EPTF_LGenBase_ScenarioTypeInternalDeclarator pl_scenario)
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    var integer vl_maxTc := sizeof(pl_scenario.tcList);
    if(0 == vl_maxTc){
      return false;
    }
    var boolean vl_weightedScenario := ispresent(pl_scenario.weightedScData);
    const charstring c_CheckScHashMapTmpName := "checkScHashMapTmp"
    //validate tc names and collect their idxs to a hashmap 
    var integer vl_hash := f_EPTF_str2int_HashMap_New(c_CheckScHashMapTmpName);
    for(var integer vl_tc := 0; vl_tc < vl_maxTc; vl_tc := vl_tc + 1){
      var charstring vl_tcPrivateName := pl_scenario.tcList[vl_tc].tcPrivateName;
      var charstring vl_tcTypeName := pl_scenario.tcList[vl_tc].tcTypeName;
      var integer vl_tcTypeIdx := f_EPTF_LGenBase_tcTypeNameIndex(vl_tcTypeName) 
      //TODO Test it
      if(-1 == vl_tcTypeIdx){
        if("" != vl_tcTypeName){
          f_EPTF_LGenBase_loggingError(%definitionId&": Invalid traffic case type name: "&pl_scenario.tcList[vl_tc].tcTypeName&
            " in traffic case "&pl_scenario.tcList[vl_tc].tcPrivateName&" of scenario "&
            pl_scenario.name);
        }
        if(0 == sizeof(pl_scenario.tcList[vl_tc].fsmList)){
          f_EPTF_LGenBase_loggingError(%definitionId&
            ": Both the traffic case type name and FSM list are empty in traffic case "&
            pl_scenario.tcList[vl_tc].tcPrivateName&"  of scenario "&
            pl_scenario.name);
        }
      }else{
        //The traffic case type is valid
        //Check the name of the main FSM, and the customEntitySucc2 fn
        if(0 < sizeof(pl_scenario.tcList[vl_tc].fsmList) and 
          pl_scenario.tcList[vl_tc].fsmList[0].fsmName != v_LGenBase_fsmTables[v_LGenBase_trafficCaseTypes[vl_tcTypeIdx].fsmIdx].name){
          f_EPTF_LGenBase_loggingError(%definitionId&
            ": The FSM name "&v_LGenBase_fsmTables[v_LGenBase_trafficCaseTypes[vl_tcTypeIdx].fsmIdx].name&
            " of TC type "&v_LGenBase_trafficCaseTypes[vl_tcTypeIdx].name&
            " and the first FSM "&pl_scenario.tcList[vl_tc].fsmList[0].fsmName&
            " in the fsmList in traffic case "&pl_scenario.tcList[vl_tc].tcPrivateName&" of scenario "&
            pl_scenario.name&" are different.");
        }
        if("" != pl_scenario.tcList[vl_tc].customEntitySucc){
          var EPTF_LGenBase_evaluateSuccess4EntityAtEntityGroup2_FT vl_ft :=
          f_EPTF_LGenBase_getEntitySucc2(pl_scenario.tcList[vl_tc].customEntitySucc)
          
          if(null != v_LGenBase_trafficCaseTypes[vl_tcTypeIdx].customEntitySucc2 and
            vl_ft != v_LGenBase_trafficCaseTypes[vl_tcTypeIdx].customEntitySucc2){
            f_EPTF_LGenBase_loggingError(%definitionId&
              ": The declaration of the traffic case type "&v_LGenBase_trafficCaseTypes[vl_tcTypeIdx].name&
              " contains a custom entity success function V2, which is "&log2str(v_LGenBase_trafficCaseTypes[vl_tcTypeIdx].customEntitySucc2)&
              " and the declaration of the traffic case "&pl_scenario.tcList[vl_tc].tcPrivateName&" of scenario "&
              pl_scenario.name&" contains a different one: "&log2str(vl_ft));
          }
        }
      }
      var integer vl_fsmListSize := sizeof(pl_scenario.tcList[vl_tc].fsmList)
      for ( var integer vl_i := 0; vl_i < vl_fsmListSize ; vl_i := vl_i+1 ){
        var integer vl_fsmTypeIdx := f_EPTF_LGenBase_fsmNameIndex(pl_scenario.tcList[vl_tc].fsmList[vl_i].fsmName)
        if(0 > vl_fsmTypeIdx){
          f_EPTF_LGenBase_loggingError(%definitionId&": Invalid FSM type name: "&pl_scenario.tcList[vl_tc].fsmList[vl_i].fsmName&
            " in fsmList of traffic case "&pl_scenario.tcList[vl_tc].tcPrivateName&" of scenario "&
            pl_scenario.name);
        }
        pl_scenario.tcList[vl_tc].fsmList[vl_i].fsmTypeIndex := vl_fsmTypeIdx
        pl_scenario.tcList[vl_tc].fsmList[vl_i].fsmName := v_LGenBase_fsmTables[vl_fsmTypeIdx].name
        //Check referred FSMs
        var integer vl_refSize := sizeof(v_LGenBase_fsmTables[vl_fsmTypeIdx].referredFsmList)
        for ( var integer vl_refFsm := 0; vl_refFsm < vl_refSize ; vl_refFsm := vl_refFsm+1 ){
          //Is this FSM present in the TC list?
          //var integer
        }
        
      }
      f_EPTF_str2int_HashMap_Insert(vl_hash, vl_tcPrivateName, vl_tc);
      if(vl_weightedScenario and not ischosen(pl_scenario.tcList[vl_tc].target.trafficWeight)){
        f_EPTF_str2int_HashMap_Delete(c_CheckScHashMapTmpName);
        f_EPTF_LGenBase_loggingError(%definitionId&"The scenario "&pl_scenario.name&" is weighted, but the wieght of the tc "&vl_tcPrivateName&" is not set. Target data: "&
          log2str( pl_scenario.tcList[vl_tc].target ));
        return false;
      }
      if(not vl_weightedScenario and 
        not ischosen(pl_scenario.tcList[vl_tc].target.cpsToReach) and
        terminating != pl_scenario.trafficType) //FIXME
      {
        f_EPTF_str2int_HashMap_Delete(c_CheckScHashMapTmpName);
        f_EPTF_LGenBase_loggingError(%definitionId&"The scenario "&pl_scenario.name&" is not weighted, but the target of the tc "&vl_tcPrivateName&" is not set. Target data: "&
          log2str( pl_scenario.tcList[vl_tc].target ));
        return false;
      }
    }
    var boolean vl_ok := true
    //check actions
    for ( var integer vl_tc := 0; vl_tc < sizeof(pl_scenario.tcList) and vl_ok; vl_tc := vl_tc+1 )
    {
      var charstring vl_tcPrivateName := pl_scenario.tcList[vl_tc].tcPrivateName;
      if(ispresent(pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.entitiesFinished)){
        vl_ok := f_EPTF_LGenBase_checkGroupActionsInSc(
          vl_hash,
          pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.entitiesFinished.actions,
          vl_tcPrivateName,
          pl_scenario.name)
      }
      if(ispresent(pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.availableEntitiesFinished)){
        vl_ok := f_EPTF_LGenBase_checkGroupActionsInSc(
          vl_hash,
          pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.availableEntitiesFinished.actions,
          vl_tcPrivateName,
          pl_scenario.name)
      }
      if(ispresent(pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.execTime)){
        if(not f_EPTF_LGenBase_checkGroupActionsInSc(
            vl_hash,
            pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.execTime.actions,
            vl_tcPrivateName,
            pl_scenario.name)){
          vl_ok := false;
        }
      }
      if(ispresent(pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.nrOfExecStart)){
        if(not f_EPTF_LGenBase_checkGroupActionsInSc(
            vl_hash,
            pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.nrOfExecStart.actions,
            vl_tcPrivateName,
            pl_scenario.name)){
          vl_ok := false;
        }
      }
      if(ispresent(pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.nrOfFails)){
        if(not f_EPTF_LGenBase_checkGroupActionsInSc(
            vl_hash,
            pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.nrOfFails.actions,
            vl_tcPrivateName,
            pl_scenario.name)){
          vl_ok := false;
        }
      }
      if(ispresent(pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.nrOfErrors)){
        if(not f_EPTF_LGenBase_checkGroupActionsInSc(
            vl_hash,
            pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.nrOfErrors.actions,
            vl_tcPrivateName,
            pl_scenario.name)){
          vl_ok := false;
        }
      }
      if(ispresent(pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.nrOfTimeouts)){
        if(not f_EPTF_LGenBase_checkGroupActionsInSc(
            vl_hash,
            pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.nrOfTimeouts.actions,
            vl_tcPrivateName,
            pl_scenario.name)){
          vl_ok := false;
        }
      }
      if(ispresent(pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.nrOfRangeLoop)){
        if(not f_EPTF_LGenBase_checkGroupActionsInSc(
            vl_hash,
            pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.nrOfRangeLoop.actions,
            vl_tcPrivateName,
            pl_scenario.name)){
          vl_ok := false;
        }
      }
      if(ispresent(pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.nrOfSuccesses)){
        if(not f_EPTF_LGenBase_checkGroupActionsInSc(
            vl_hash,
            pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.nrOfSuccesses.actions,
            vl_tcPrivateName,
            pl_scenario.name)){
          vl_ok := false;
        }
      }
      if(ispresent(pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.anythingFinished)){
        if(not f_EPTF_LGenBase_checkGroupActionsInSc(
            vl_hash,
            pl_scenario.tcList[vl_tc].trafficStartFinishConditionsAndActions.anythingFinished.actions,
            vl_tcPrivateName,
            pl_scenario.name)){
          vl_ok := false;
        }
      }
      
      if(not f_EPTF_LGenBase_checkGroupActionsInSc(
          vl_hash,
          pl_scenario.tcList[vl_tc].trafficFinishedActions,
          vl_tcPrivateName,
          pl_scenario.name)){
        vl_ok := false;
      }
      
      if(not f_EPTF_LGenBase_checkEntityActionsInSc(
          vl_hash,
          pl_scenario.tcList[vl_tc].entityFinishActions,
          vl_tcPrivateName,
          pl_scenario.name)){
        vl_ok := false;
      }
    }
    f_EPTF_str2int_HashMap_Delete(c_CheckScHashMapTmpName);
    return vl_ok;
  }
} // Validation

///////////////////////////////////////////////////////////
//  Group: PrivateFunctions
// 
//  Purpose:
//    Private functions. Don't call them from outside of EPTF_LGenBase_CT
///////////////////////////////////////////////////////////
group PrivateFunctions{
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_validateScenarioType
  // 
  //  Purpose:
  //    Internal function to validate scenario
  ///////////////////////////////////////////////////////////
  private function f_EPTF_LGenBase_getEntitySucc2(
    in charstring pl_fnName)
  runs on EPTF_LGenBase_Private_CT
  return EPTF_LGenBase_evaluateSuccess4EntityAtEntityGroup2_FT{
    var integer vl_fnIdx := f_EPTF_LGenBase_functionNameIndex(pl_fnName);
    if(-1 == vl_fnIdx){
      f_EPTF_LGenBase_loggingError(%definitionId&": Invalid custom entity success function: "&pl_fnName);
    }
    if(not ischosen(v_LGenBase_functions[vl_fnIdx].evaluateSuccess4EntityAtEntityGroup2)){
      f_EPTF_LGenBase_loggingError(%definitionId&": Invalid custom entity success function type: "&pl_fnName);
    }
    return v_LGenBase_functions[vl_fnIdx].evaluateSuccess4EntityAtEntityGroup2;
  }
  
  private function f_EPTF_LGenBase_tcStats(
    in integer pl_tcIdx,
    inout EPTF_LGenBase_StatisticOfTCList pl_stats)
  runs on EPTF_LGenBase_Private_CT{
    pl_stats := {}
    var integer vl_fsmTableId := v_LGenBase_trafficCases[pl_tcIdx].fsmIdx
    //v_LGenBase_fsmTables[vl_fsmTableId].
    var integer vl_count := sizeof(v_LGenBase_fsmTables[vl_fsmTableId].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC]);
    for ( var integer vl_i := 0; vl_i < vl_count ; vl_i := vl_i+1 )
    {
      var integer vl_statIdx := sizeof(pl_stats)
      pl_stats[vl_statIdx].declaredName :=
      v_LGenBase_fsmTables[vl_fsmTableId].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name
      pl_stats[vl_statIdx].statMethod :=
      v_LGenBase_fsmTables[vl_fsmTableId].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].statMethod
      pl_stats[vl_statIdx].statName :=
      f_EPTF_LGenBase_varNameOfTCVar(pl_tcIdx, v_LGenBase_trafficCases[pl_tcIdx].statHandlerStatList[vl_i].statName);
      pl_stats[vl_statIdx].statResetValue :=
      v_LGenBase_fsmTables[vl_fsmTableId].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].statResetValue
    }
  }
  ///////////////////////////////////////////////////////////
  //  Group: DeclaratorConverters
  // 
  //  Purpose:
  //    Convert data types to common formats
  ///////////////////////////////////////////////////////////
  group DeclaratorConverters{
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_convertTcGroupFinishActions
    // 
    //  Purpose:
    //    Internal function to check and convert string references
    //    to indexes
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_addConvertedTcGroupFinishActions( 
      in EPTF_LGenBase_ScenarioOfGrp pl_sc,
      inout EPTF_LGenBase_TcMgmt_GroupActionsDescList pl_desc,
      in EPTF_LGenBase_TcMgmt_GroupActionsList pl_decl
    )
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_base := sizeof(pl_desc);
      var integer vl_faSize := sizeof(pl_decl); 
      for ( var integer vl_i := 0; vl_i < vl_faSize ; vl_i := vl_i+1 )
      {
        select( true )
        {
          case ( ischosen(pl_decl[vl_i].disableAllTc) )
          {
            pl_desc[vl_base+vl_i].disableAllTc := 
            pl_decl[vl_i].disableAllTc; 
          }
          case ( ischosen(pl_decl[vl_i].enableAllTc) )
          {
            pl_desc[vl_base+vl_i].enableAllTc := 
            pl_decl[vl_i].enableAllTc; 
          }
          case ( ischosen(pl_decl[vl_i].generateGenericEvent) )
          {
            pl_desc[vl_base+vl_i].generateGenericEvent := 
            pl_decl[vl_i].generateGenericEvent; 
          }
          case ( ischosen(pl_decl[vl_i].customFinishFunction) )
          {
            var integer vl_fnIdx := f_EPTF_LGenBase_functionNameIndex(pl_decl[vl_i].customFinishFunction);
            f_EPTF_Base_assert(%definitionId&": Invalid customFinishFunction: "&pl_decl[vl_i].customFinishFunction,
              -1 != vl_fnIdx);
            f_EPTF_Base_assert(%definitionId&": Invalid customFinishFunction.",
              ischosen(v_LGenBase_functions[vl_fnIdx].customFinishFunction));
            pl_desc[vl_base+vl_i].customFinishFunction :=
            v_LGenBase_functions[vl_fnIdx].customFinishFunction;
          }
          case ( ischosen(pl_decl[vl_i].enableTc) )
          {
            var EPTF_LGenBase_TcMgmt_Action_EnableTc4GroupDesc vl_en;
            var integer vl_tcRelIdx := f_EPTF_LGenBase_tcOfScenario(pl_sc, pl_decl[vl_i].enableTc.tcName);
            f_EPTF_Base_assert(%definitionId&": Invalid traffic case name: "&pl_decl[vl_i].enableTc.tcName&
              " in scenario "&pl_sc.name&" . Scenario: "&log2str(pl_sc),
              -1 != vl_tcRelIdx);
            vl_en.tcIdx := pl_sc.tcIdxList[vl_tcRelIdx];
            vl_en.aMode := pl_decl[vl_i].enableTc.aMode;
            pl_desc[vl_base+vl_i].enableTc := vl_en;
          }
          case ( ischosen(pl_decl[vl_i].disableTc) )
          {
            var EPTF_LGenBase_TcMgmt_Action_DisableTcDesc vl_en;
            vl_en.tcIdx := f_EPTF_LGenBase_tcOfScenario(pl_sc, pl_decl[vl_i].disableTc.tcName);
            f_EPTF_Base_assert(%definitionId&": Invalid traffic case name: "&pl_decl[vl_i].disableTc.tcName,
              -1 != vl_en.tcIdx);
            pl_desc[vl_base+vl_i].disableTc := vl_en;
          }
          case ( ischosen(pl_decl[vl_i].testFinished) )
          {
            pl_desc[vl_base+vl_i].testFinished := 
            pl_decl[vl_i].testFinished; 
          }
          case else
          {
            //Asyncronous code change
            f_EPTF_Base_assert(%definitionId&": Invalid group finish action.",false);
          }
        }
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_logDuplicatedDef
    // 
    //  Purpose:
    //    Merges the error message about a conversion error 
    //    appeared in <f_EPTF_LGenBase_convertTcOfScenarioTypeDeclarator2Internal> 
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_logDuplicatedDef(
      in charstring pl_fn,
      in charstring pl_defName,
      in charstring pl_tcName,
      in charstring pl_scName,
      in charstring pl_new,
      in charstring pl_prev)
    runs on EPTF_Base_CT{
      f_EPTF_Common_error(%definitionId&": Error: "&pl_fn&": The "&pl_defName&" is already defined in tc "&pl_tcName&
        " of scenario "&pl_scName&
        ". The previous one: "&pl_prev&
        " The new one: "&pl_new)
      f_EPTF_Base_stop()
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_logDuplicatedDef2ndLevel
    // 
    //  Purpose:
    //    Merges the error message about a conversion error 
    //    appeared in <f_EPTF_LGenBase_convertTcOfScenarioTypeDeclarator2Internal> 
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_logDuplicatedDef2ndLevel(
      in charstring pl_fn,
      in charstring pl_defName,
      in charstring pl_2ndDefName,
      in charstring pl_tcName,
      in charstring pl_scName,
      in charstring pl_new,
      in charstring pl_prev)
    runs on EPTF_Base_CT{
      f_EPTF_Common_error(%definitionId&": Error: "&pl_fn&": The "&pl_defName&" of "&
        pl_2ndDefName&" is already defined in tc "&pl_tcName&
        " of scenario "&pl_scName&
        ". The previous one: "&pl_prev&
        " The new one: "&pl_new)
      f_EPTF_Base_stop()
    }
    
  }//group PrivateFunctions, DeclaratorConverters
  
  ///////////////////////////////////////////////////////////
  //  Group: internalDeclarators
  // 
  //  Purpose:
  //    internal declarators for traffic case, scenario declarations
  ///////////////////////////////////////////////////////////  
  group internalDeclarators{
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_declareTrafficCaseTypeInternal
    // 
    //  Purpose:
    //    Declaring a traffic case from the internal traffic case declarator
    ///////////////////////////////////////////////////////////  
    friend function f_EPTF_LGenBase_declareTrafficCaseTypeInternal(in EPTF_LGenBase_TrafficCaseTypeInternalDeclarator pl_tcType)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
        f_EPTF_LGenBase_loggingDebugConfig(%definitionId&": The declared traffic case type is: "&log2str(pl_tcType))
      }
      var EPTF_LGenBase_TcTypeDescriptor vl_desc;
      f_EPTF_LGenBase_fillTcTypeDescriptor(pl_tcType, vl_desc)
      var integer vl_idx := sizeof(v_LGenBase_trafficCaseTypes);
      v_LGenBase_trafficCaseTypes[vl_idx] := vl_desc;
      return vl_idx; 
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_declareScenarioTypeInternal
    // 
    //  Purpose:
    //    Declaring a scenario from the internal scenario declarator
    ///////////////////////////////////////////////////////////    
    friend function f_EPTF_LGenBase_declareScenarioTypeInternal(
      inout EPTF_LGenBase_ScenarioTypeInternalDeclarator pl_scenario)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      if(not f_EPTF_LGenBase_validateScenarioType(pl_scenario)){
        return -1;
      }
      var boolean vl_groupFinishConditionsExist := false;
      var boolean vl_phaseFinishConditionsExist := false;    
      var EPTF_LGenBase_ScenarioType vl_sc := c_EPTF_LGenBase_emptyScenarioType;   
      vl_sc.name := pl_scenario.name;
      vl_sc.enabled := pl_scenario.enabled;
      vl_sc.weightedScData := omit;
      vl_sc.phaseData :=  omit;
      vl_sc.conditionsFromTc := pl_scenario.conditionsFromTC;
      vl_sc.tcList := pl_scenario.tcList;        
      vl_sc.trafficType := pl_scenario.trafficType        
      var integer vl_tcMax := sizeof(pl_scenario.tcList);
      for(var integer vl_i := 0; vl_i < vl_tcMax; vl_i := vl_i + 1){ // both normal & weighted
        vl_groupFinishConditionsExist := 
        ispresent(pl_scenario.tcList[vl_i].trafficStartFinishConditionsAndActions.customFinish) or
        ispresent(pl_scenario.tcList[vl_i].trafficStartFinishConditionsAndActions.entitiesFinished) or
        ispresent(pl_scenario.tcList[vl_i].trafficStartFinishConditionsAndActions.availableEntitiesFinished) or
        ispresent(pl_scenario.tcList[vl_i].trafficStartFinishConditionsAndActions.execTime) or
        ispresent(pl_scenario.tcList[vl_i].trafficStartFinishConditionsAndActions.nrOfExecStart) or
        ispresent(pl_scenario.tcList[vl_i].trafficStartFinishConditionsAndActions.nrOfFails) or
        ispresent(pl_scenario.tcList[vl_i].trafficStartFinishConditionsAndActions.nrOfErrors) or
        ispresent(pl_scenario.tcList[vl_i].trafficStartFinishConditionsAndActions.nrOfTimeouts) or
        ispresent(pl_scenario.tcList[vl_i].trafficStartFinishConditionsAndActions.nrOfRangeLoop) or
        ispresent(pl_scenario.tcList[vl_i].trafficStartFinishConditionsAndActions.nrOfSuccesses) or
        ispresent(pl_scenario.tcList[vl_i].trafficStartFinishConditionsAndActions.anythingFinished)
      }   
      
      if (ispresent(pl_scenario.weightedScData)) { // weighted scenario declared
        vl_sc.weightedScData := c_EPTF_LGenBase_emptyWeightedScData;
        vl_sc.weightedScData := pl_scenario.weightedScData;
        
        for(var integer vl_i := 0; vl_i < vl_tcMax; vl_i := vl_i + 1){
          vl_sc.tcList[vl_i].target.trafficWeight:= pl_scenario.tcList[vl_i].target.trafficWeight;
          if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
            f_EPTF_LGenBase_loggingDebugConfig(%definitionId&": The created tc of scenario:"&log2str(vl_sc.tcList[vl_i]))
            f_EPTF_LGenBase_loggingDebugConfig(%definitionId&": The declaretion:"&log2str(pl_scenario.tcList[vl_i]))
          }
        }   
      } else { // normal scenario declared
        
        for(var integer vl_i := 0; vl_i < vl_tcMax; vl_i := vl_i + 1){
          vl_sc.tcList[vl_i].startDelay := pl_scenario.tcList[vl_i].startDelay;
          if(terminating == vl_sc.trafficType and not ischosen(vl_sc.tcList[vl_i].target.cpsToReach)){
            vl_sc.tcList[vl_i].target.cpsToReach := 0.0
          }else{
            vl_sc.tcList[vl_i].target.cpsToReach := pl_scenario.tcList[vl_i].target.cpsToReach;
          }
          vl_sc.tcList[vl_i].scheduler := pl_scenario.tcList[vl_i].scheduler; 
          if(ispresent(pl_scenario.tcList[vl_i].scheduler)) {
            /*if(ischosen(pl_scenario.tcList[vl_i].scheduler.preDefinedName)){
            vl_sc.tcList[vl_i].scheduler := f_EPTF_LGenBase_BurstFuncName2Char(pl_scenario.tcList[vl_i].scheduler.preDefinedName); 
            } else {
            vl_sc.tcList[vl_i].scheduler := pl_scenario.tcList[vl_i].scheduler.userDefinedName;
            }*/
          } else {
            vl_sc.tcList[vl_i].scheduler := omit;
          }       
          if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
            f_EPTF_LGenBase_loggingDebugConfig(%definitionId&": The created tc of scenario:"&log2str(vl_sc.tcList[vl_i]))
            f_EPTF_LGenBase_loggingDebugConfig(%definitionId&": The declaretion:"&log2str(pl_scenario.tcList[vl_i]))
          }
        }
      }
      
      if(ispresent(pl_scenario.phaseListName)) { // phaselist declared
        vl_sc.phaseData := c_EPTF_LGenBase_emptyPhaseData;
        vl_sc.phaseData.phaseListName := pl_scenario.phaseListName;
        var EPTF_LGenBase_PhaseList_Declarator  vl_phaseList_decl;
        
        if( f_EPTF_LGenBase_PhaseList_get_byName(pl_scenario.phaseListName, vl_phaseList_decl)) {
          vl_sc.phaseData.actualPhase := vl_phaseList_decl.phases[0].name; //starting phase
          
          for(var integer vl_j := 0; vl_j < sizeof(vl_phaseList_decl.phases); vl_j := vl_j + 1){
            vl_sc.phaseData.phaseList[vl_j].name := vl_phaseList_decl.phases[vl_j].name;
            vl_sc.phaseData.phaseList[vl_j].enabled := vl_phaseList_decl.phases[vl_j].enabled;
            vl_sc.phaseData.phaseList[vl_j].actualState := IDLE;
            vl_sc.phaseData.phaseList[vl_j].conditionList := omit;
            if(ispresent(pl_scenario.phaseFinishConditions)) {
              vl_phaseFinishConditionsExist := true;
              var integer vl_m := 0; // using this if the same phase exist more than one in the declarator
              for(var integer vl_k := vl_m; vl_k < sizeof(pl_scenario.phaseFinishConditions); vl_k := vl_k + 1){
                // saving phase finish conditions
                if( vl_phaseList_decl.phases[vl_j].name == pl_scenario.phaseFinishConditions[vl_k].phase) {
                  //todo enabled??
                  for(var integer vl_l := 0; vl_l < sizeof(pl_scenario.phaseFinishConditions[vl_k].conditions); vl_l := vl_l + 1){
                    
                    vl_sc.phaseData.phaseList[vl_j].conditionList[vl_l].condition := pl_scenario.phaseFinishConditions[vl_k].conditions[vl_l];
                    vl_sc.phaseData.phaseList[vl_j].conditionList[vl_l].finished := false;
                    vl_m := vl_m + 1;
                  }
                }
              }
            }
            
            vl_sc.phaseData.phaseList[vl_j].actionList := omit;
            if(ispresent(pl_scenario.phaseStateChangeActions)) {
              var integer vl_m := 0; // using this if the same phase exist more than one in the declarator
              for(var integer vl_k := 0; vl_k < sizeof(pl_scenario.phaseStateChangeActions); vl_k := vl_k + 1){
                // saving phase actions	  
                if( vl_phaseList_decl.phases[vl_j].name == pl_scenario.phaseStateChangeActions[vl_k].phase) {
                  //todo enabled??
                  vl_sc.phaseData.phaseList[vl_j].actionList[vl_m].state := pl_scenario.phaseStateChangeActions[vl_k].state;
                  vl_sc.phaseData.phaseList[vl_j].actionList[vl_m].actions := pl_scenario.phaseStateChangeActions[vl_k].actions;
                  vl_m := vl_m + 1; 
                }
              }
            } 		 
          }
          
        } else {
          // phaseListName not found
          f_EPTF_LGenBase_loggingError(%definitionId&": Invalid PhaseList Name. Maybe phaseList declared with different name. "&pl_scenario.phaseListName);
        }
        
      } else {
        // phaseListName is omitted      
        if((ispresent(pl_scenario.phaseFinishConditions)) or (ispresent(pl_scenario.phaseStateChangeActions))) { 
          //phase data exist, but no phaselist name
          f_EPTF_LGenBase_loggingError(%definitionId&": PhaseData exists, but PhaseList Name not declared. ");
        }	     
        //no phase data, no phaselist name -> no phases, do nothing
      }
      
      if(vl_groupFinishConditionsExist and vl_phaseFinishConditionsExist) {
        f_EPTF_LGenBase_loggingWarning(%definitionId&": Both Group Finish Conditions and Phase Finish Conditions exists. Handle with care!");
      } 
      
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
        f_EPTF_LGenBase_loggingDebugConfig(%definitionId&": The declaration:"&log2str(vl_sc)) 
      }      
      var integer vl_ret := sizeof(v_LGenBase_scenarioTypes);
      v_LGenBase_scenarioTypes[vl_ret] := vl_sc;
      return vl_ret;
    }//f_EPTF_LGenBase_declareScenarioType3
  } // group internalDeclarators
  
  private function f_EPTF_LGenBase_checkScenarioType(
    in EPTF_LGenBase_ScenarioTypeInternalDeclarator pl_dest)
  runs on EPTF_Base_CT{
    if(terminating == pl_dest.trafficType){
      if(ispresent(pl_dest.weightedScData)){
        f_EPTF_Common_error("Error: "&%definitionId&": The terminating scenario type "&pl_dest.name&
          " must not contain weighted scenario data.")
        f_EPTF_Base_stop()
      }
      if(ispresent(pl_dest.phaseListName) or
        ispresent(pl_dest.phaseFinishConditions) or
        ispresent(pl_dest.phaseStateChangeActions)){
        f_EPTF_Common_error("Error: "&%definitionId&": The terminating scenario type "&pl_dest.name&
          " should not contain phases data.")
        f_EPTF_Base_stop()
      }
      //TODO check traffic case declarators
    }
  } // group internalDeclarators
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_checkGroupActionsInSc
  // 
  //  Purpose:
  //    Checking group actions in the scenario
  ///////////////////////////////////////////////////////////  
  private function f_EPTF_LGenBase_checkGroupActionsInSc(
    in integer pl_tcNameHash,
    in EPTF_LGenBase_TcMgmt_GroupActionsList pl_actions,
    in charstring pl_tcPrivateName,
    in charstring pl_scenarioName)
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    var integer vl_temp;
    for ( var integer vl_action := 0; vl_action < sizeof(pl_actions) ; vl_action := vl_action+1 ){
      select( true ){
        case (ischosen(pl_actions[vl_action].disableTc)){
          if(not f_EPTF_str2int_HashMap_Find(pl_tcNameHash, pl_actions[vl_action].disableTc.tcName, vl_temp)){
            f_EPTF_LGenBase_loggingError(%definitionId&
              "The group finish action nr. "&int2str(vl_action)&
              " (disableTc) of the tc "&pl_tcPrivateName&
              " of scenario "&pl_scenarioName&" points to an invalid tc: "&
              pl_actions[vl_action].disableTc.tcName);
            f_EPTF_str2int_HashMap_DumpByID(pl_tcNameHash);
            f_EPTF_Base_stopAll()
            return false;
          }
        }
        case (ischosen(pl_actions[vl_action].enableTc)){
          if(not f_EPTF_str2int_HashMap_Find(pl_tcNameHash, pl_actions[vl_action].enableTc.tcName, vl_temp)){
            f_EPTF_LGenBase_loggingError(%definitionId&
              "The group finish action nr. "&int2str(vl_action)&
              " (enableTc) of the tc "&pl_tcPrivateName&
              " of scenario "&pl_scenarioName&" points to an invalid tc: "&
              pl_actions[vl_action].enableTc.tcName);
            f_EPTF_str2int_HashMap_DumpByID(pl_tcNameHash);
            f_EPTF_Base_stopAll()
            return false;
          }
        }
      }
    }
    return true;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_checkEntityActionsInSc
  // 
  //  Purpose:
  //    Checking entity actions in the scenario
  ///////////////////////////////////////////////////////////  
  private function f_EPTF_LGenBase_checkEntityActionsInSc(
    in integer pl_tcNameHash,
    in EPTF_LGenBase_TcMgmt_EntityActionsList pl_actions,
    in charstring pl_tcName,
    in charstring pl_scenarioName)
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    var integer vl_temp;
    for ( var integer vl_action := 0; vl_action < sizeof(pl_actions) ; vl_action := vl_action+1 ){
      select( true ){
        case (ischosen(pl_actions[vl_action].disableEntity4Tc)){
          if(not f_EPTF_str2int_HashMap_Find(pl_tcNameHash, pl_actions[vl_action].disableEntity4Tc.tcName, vl_temp)){
            f_EPTF_LGenBase_loggingError(%definitionId&
              "The entity finish action nr. "&int2str(vl_action)&
              " (disableEntity4Tc) of the tc "&pl_tcName&
              " of scenario "&pl_scenarioName&" points to an invalid tc: "&
              pl_actions[vl_action].disableEntity4Tc.tcName);
            return false;
          }
        }
        case (ischosen(pl_actions[vl_action].enableEntity4Tc)){
          if(not f_EPTF_str2int_HashMap_Find(pl_tcNameHash, pl_actions[vl_action].enableEntity4Tc.tcName, vl_temp)){
            f_EPTF_LGenBase_loggingError(%definitionId&
              "The entity finish action nr. "&int2str(vl_action)&
              " (enableEntity4Tc) of the tc "&pl_tcName&
              " of scenario "&pl_scenarioName&" points to an invalid tc: "&
              pl_actions[vl_action].enableEntity4Tc.tcName);
            return false;
          }
        }
      }
    }
    return true;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_convertEntityFinishConditionsInternalDeclarator2Desc
  // 
  //  Purpose:
  //    Converting entity finish conditions into internal structure
  ///////////////////////////////////////////////////////////  
  friend function f_EPTF_LGenBase_convertEntityFinishConditionsInternalDeclarator2Desc(
    in EPTF_LGenBase_ScenarioOfGrp pl_sc,
    in EPTF_LGenBase_EntityFinishConditionsInternalDeclarator pl_decl,
    out EPTF_LGenBase_EntityFinishConditionsDesc pl_desc)
  runs on EPTF_LGenBase_Private_CT{
    if(ispresent(pl_decl.nrOfExecStart)){
      pl_desc.nrOfExecStart := pl_decl.nrOfExecStart 
    }
    if(ispresent(pl_decl.nrOfFails)){
      pl_desc.nrOfFails := pl_decl.nrOfFails 
    }
    if(ispresent(pl_decl.nrOfErrors)){
      pl_desc.nrOfErrors := pl_decl.nrOfErrors 
    }
    if(ispresent(pl_decl.nrOfTimeouts)){
      pl_desc.nrOfTimeouts := pl_decl.nrOfTimeouts 
    }
    if(ispresent(pl_decl.nrOfSuccesses)){
      pl_desc.nrOfSuccesses := pl_decl.nrOfSuccesses 
    }
    if(ispresent(pl_decl.customFinishCondition)){
      f_EPTF_LGenBase_getCustomFinishConditionFunctionRef(
        pl_decl.customFinishCondition, 
        pl_desc.customFinishCondition)
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_convertTcEntityFinishActions2Desc
  // 
  //  Purpose:
  //    Private function to check and convert string references
  //    to indexes
  ///////////////////////////////////////////////////////////
  friend function f_EPTF_LGenBase_convertTcEntityFinishActions2Desc( 
    in EPTF_LGenBase_ScenarioOfGrp pl_sc,
    in EPTF_LGenBase_TcMgmt_EntityActionsList pl_decl,
    out EPTF_LGenBase_TcMgmt_EntityActionsDescList pl_desc
  )
  runs on EPTF_LGenBase_Private_CT{
    pl_desc := {};
    var integer vl_faSize := sizeof(pl_decl);
    for ( var integer vl_i := 0; vl_i < vl_faSize ; vl_i := vl_i+1 )
    {
      select( pl_decl[vl_i] )
      {
        case ( {enableEntity4Tc := ?} )
        {
          var EPTF_LGenBase_TcMgmt_Action_EnableTc4EntityDesc vl_en;
          var integer vl_tcRelIdx := f_EPTF_LGenBase_tcOfScenario(pl_sc, pl_decl[vl_i].enableEntity4Tc.tcName);
          if(0 > vl_tcRelIdx){
            f_EPTF_LGenBase_loggingError(%definitionId&
              ": Invalid traffic case name: "&pl_decl[vl_i].enableEntity4Tc.tcName&
              " in scenario type "&pl_sc.name)
          }
          vl_en.tcIdx := pl_sc.tcIdxList[vl_tcRelIdx];
          vl_en.aMode := pl_decl[vl_i].enableEntity4Tc.aMode;
          pl_desc[vl_i].enableEntity4Tc := vl_en;
        }
        case ( {disableEntity4Tc:= ?} )
        {
          var EPTF_LGenBase_TcMgmt_Action_DisableTcDesc vl_en;
          var integer vl_tcRelIdx := f_EPTF_LGenBase_tcOfScenario(pl_sc, pl_decl[vl_i].disableEntity4Tc.tcName);
          if(0 > vl_tcRelIdx){
            f_EPTF_LGenBase_loggingError(%definitionId&
              ": Invalid traffic case name: "&pl_decl[vl_i].disableEntity4Tc.tcName&
              " in scenario type "&pl_sc.name)
          }
          vl_en.tcIdx := pl_sc.tcIdxList[vl_tcRelIdx];
          pl_desc[vl_i].disableEntity4Tc := vl_en;
        }
        case ( {generateFsmEvent:= ?} )
        {
          pl_desc[vl_i].generateFsmEvent := pl_decl[vl_i].generateFsmEvent;
        }
        case ( {customFinishFunction:= ?} )
        {
          var integer vl_fnIdx := f_EPTF_LGenBase_functionNameIndex(pl_decl[vl_i].customFinishFunction);
          f_EPTF_Base_assert(%definitionId&": Invalid customFinishFunction: "&pl_decl[vl_i].customFinishFunction,
            -1 != vl_fnIdx);
          f_EPTF_Base_assert(%definitionId&": Invalid customFinishFunction: "&pl_decl[vl_i].customFinishFunction,
            ischosen(v_LGenBase_functions[vl_fnIdx].customFinishFunction));
          pl_desc[vl_i].customFinishFunction :=
          v_LGenBase_functions[vl_fnIdx].customFinishFunction;
        }
        case else
        {
          f_EPTF_Base_assert(%definitionId&": Invalid entity finish action.",false);
        }
      }
    }
  }//f_EPTF_LGenBase_convertTcEntityFinishActions2Desc 
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_convertTrafficStartFinishConditionsInternalDeclarator2Desc
  // 
  //  Purpose:
  //    Converting traffic finish conditions into internal structure
  ///////////////////////////////////////////////////////////  
  friend function f_EPTF_LGenBase_convertTrafficStartFinishConditionsInternalDeclarator2Desc(
    in EPTF_LGenBase_ScenarioOfGrp pl_sc,
    in EPTF_LGenBase_TrafficStartFinishConditionsInternalDeclarator pl_decl,
    inout EPTF_LGenBase_TrafficStartFinishConditionsAndActionsDesc pl_dest
  )
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_size := sizeof(pl_decl);
    if(0 < vl_size){
      pl_dest := c_EPTF_LGenBase_emptyTrafficStartFinishConditionsAndActionsDesc
    }
    if(ispresent(pl_decl.customFinish)){
      if ( pl_decl.customFinish.functionName == "" ){
        pl_dest.customFinishConditionFuncRef := omit;
      }else{
        f_EPTF_LGenBase_getCustomFinishConditionFunctionRef(
          pl_decl.customFinish.functionName,
          pl_dest.customFinishConditionFuncRef.functionRef)
        f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList(
          pl_sc,
          pl_decl.customFinish.actions,
          pl_dest.customFinishConditionFuncRef.actions)
      }
    }
    if(ispresent(pl_decl.entitiesFinished)){
      f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList(
        pl_sc,
        pl_decl.entitiesFinished.actions,
        pl_dest.entitiesFinished.actions)
    }
    if(ispresent(pl_decl.availableEntitiesFinished)){
      f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList(
        pl_sc,
        pl_decl.availableEntitiesFinished.actions,
        pl_dest.availableEntitiesFinished.actions)
    }
    if(ispresent(pl_decl.execTime)){
      f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList(
        pl_sc,
        pl_decl.execTime.actions,
        pl_dest.execTime.actions)
      pl_dest.execTime.time := pl_decl.execTime.time;
    }
    if(ispresent(pl_decl.nrOfExecStart)){
      f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList(
        pl_sc,
        pl_decl.nrOfExecStart.actions,
        pl_dest.nrOfExecStart.actions)
      pl_dest.nrOfExecStart.count := pl_decl.nrOfExecStart.count;
    }
    if(ispresent(pl_decl.nrOfFails)){
      f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList(
        pl_sc,
        pl_decl.nrOfFails.actions,
        pl_dest.nrOfFails.actions)
      pl_dest.nrOfFails.count := pl_decl.nrOfFails.count;
    }
    if(ispresent(pl_decl.nrOfErrors)){
      f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList(
        pl_sc,
        pl_decl.nrOfErrors.actions,
        pl_dest.nrOfErrors.actions)
      pl_dest.nrOfErrors.count := pl_decl.nrOfErrors.count;
    }
    if(ispresent(pl_decl.nrOfTimeouts)){
      f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList(
        pl_sc,
        pl_decl.nrOfTimeouts.actions,
        pl_dest.nrOfTimeouts.actions)
      pl_dest.nrOfTimeouts.count := pl_decl.nrOfTimeouts.count;
    }
    if(ispresent(pl_decl.nrOfRangeLoop)){
      f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList(
        pl_sc,
        pl_decl.nrOfRangeLoop.actions,
        pl_dest.nrOfRangeLoop.actions)
      pl_dest.nrOfRangeLoop.count := pl_decl.nrOfRangeLoop.count
    }
    if(ispresent(pl_decl.nrOfSuccesses)){
      f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList(
        pl_sc,
        pl_decl.nrOfSuccesses.actions,
        pl_dest.nrOfSuccesses.actions)
      pl_dest.nrOfSuccesses.count := pl_decl.nrOfSuccesses.count
    }
    if(ispresent(pl_decl.anythingFinished)){
      f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList(
        pl_sc,
        pl_decl.anythingFinished.actions,
        pl_dest.anythingFinished.actions)
    }
  }    
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList
  // 
  //  Purpose:
  //    Converting group actions into internal structure
  ///////////////////////////////////////////////////////////  
  friend function f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList(
    in EPTF_LGenBase_ScenarioOfGrp pl_sc,
    in EPTF_LGenBase_TcMgmt_GroupActionsList pl_source,
    out EPTF_LGenBase_TcMgmt_GroupActionsDescList pl_dest)
  runs on EPTF_LGenBase_Private_CT{
    pl_dest := {};
    for ( var integer vl_i := 0; vl_i < sizeof(pl_source) ; vl_i := vl_i+1 ){
      select( true ){
        case ( ischosen(pl_source[vl_i].disableAllTc) ){
          pl_dest[vl_i].disableAllTc := pl_source[vl_i].disableAllTc
        }
        case ( ischosen(pl_source[vl_i].disableTc) ){
          var integer vl_tcRelIdx := f_EPTF_LGenBase_tcOfScenario(pl_sc, pl_source[vl_i].disableTc.tcName);
          f_EPTF_Base_assert(%definitionId&": Invalid traffic case "&pl_source[vl_i].disableTc.tcName&
            " in disableTc action in scenario "&pl_sc.uniqueName,
            -1 < vl_tcRelIdx and vl_tcRelIdx < sizeof(pl_sc.tcIdxList));
          pl_dest[vl_i].disableTc.tcIdx := pl_sc.tcIdxList[vl_tcRelIdx]
        }
        case ( ischosen(pl_source[vl_i].enableAllTc) ){
          pl_dest[vl_i].enableAllTc := pl_source[vl_i].enableAllTc
        }
        case ( ischosen(pl_source[vl_i].enableTc) ){
          var integer vl_tcRelIdx := f_EPTF_LGenBase_tcOfScenario(pl_sc, pl_source[vl_i].enableTc.tcName);
          f_EPTF_Base_assert(%definitionId&": Invalid traffic case "&pl_source[vl_i].enableTc.tcName&
            " in enableTc action in scenario "&pl_sc.uniqueName,
            -1 < vl_tcRelIdx and vl_tcRelIdx < sizeof(pl_sc.tcIdxList));
          pl_dest[vl_i].enableTc.tcIdx := pl_sc.tcIdxList[vl_tcRelIdx];
          pl_dest[vl_i].enableTc.aMode := pl_source[vl_i].enableTc.aMode;
        }
        case ( ischosen(pl_source[vl_i].generateGenericEvent) ){
          pl_dest[vl_i].generateGenericEvent := pl_source[vl_i].generateGenericEvent
        }
        case ( ischosen(pl_source[vl_i].testFinished) ){
          pl_dest[vl_i].testFinished := pl_source[vl_i].testFinished
        }
        case ( ischosen(pl_source[vl_i].customFinishFunction) ){
          var integer vl_fnIdx := f_EPTF_LGenBase_functionNameIndex(pl_source[vl_i].customFinishFunction);
          f_EPTF_Base_assert(%definitionId&": Invalid customFinishFunction: "&pl_source[vl_i].customFinishFunction,
            -1 != vl_fnIdx);
          f_EPTF_Base_assert(%definitionId&": Invalid customFinishFunction: "&pl_source[vl_i].customFinishFunction,
            ischosen(v_LGenBase_functions[vl_fnIdx].customFinishFunction));
          pl_dest[vl_i].customFinishFunction :=
          v_LGenBase_functions[vl_fnIdx].customFinishFunction;
        }
        case else
        {
          f_EPTF_Base_assert(%definitionId&": Invalid group action type: "&log2str(pl_source[vl_i]),false)
        }
      }
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_areETypesCompatible
  // 
  //  Purpose:
  //    Private function to check whether the entity group contains all the 
  //    entity types referred by the traffic case
  //
  ///////////////////////////////////////////////////////////
  friend function f_EPTF_LGenBase_areETypesCompatible(
    in integer pl_etEg,
    in integer pl_etTc
  )
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    //Collect the behavior types of the eg
    var boolean vl_ret := true;
    var integer vl_btHash := f_EPTF_int2int_HashMap_New("tc2eg behavior checker");
    var integer vl_btCount := sizeof(v_LGenBase_entityTypes[pl_etEg].behaviorTypeIdxList);
    for ( var integer vl_i := 0; vl_i < vl_btCount ; vl_i := vl_i+1 )
    {
      f_EPTF_int2int_HashMap_Insert(vl_btHash, v_LGenBase_entityTypes[pl_etEg].behaviorTypeIdxList[vl_i], vl_i)
    }
    //Check the behavior types of the entity type of the tc
    vl_btCount := sizeof(v_LGenBase_entityTypes[pl_etTc].behaviorTypeIdxList);
    var integer vl_i := 0; 
    while(vl_i < vl_btCount and vl_ret )
    {
      var integer vl_dummy;
      vl_ret := f_EPTF_int2int_HashMap_Find(
        vl_btHash, 
        v_LGenBase_entityTypes[pl_etTc].behaviorTypeIdxList[vl_i], 
        vl_dummy)
      vl_i := vl_i+1;
    }
    f_EPTF_int2int_HashMap_Delete("tc2eg behavior checker");
    return vl_ret;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_initEntityCtxs
  // 
  //  Purpose:
  //    Initializes behavior contexts of entities
  ///////////////////////////////////////////////////////////
  friend function f_EPTF_LGenBase_initEntityCtxs(
    in integer pl_eOffset,
    in integer pl_maxCount,
    //in charstring pl_eNamePrefix,
    in integer pl_eGrpBackRef := -1)
  runs on EPTF_LGenBase_Private_CT{
    for (var integer vl_i := pl_eOffset + pl_maxCount - 1; vl_i>=pl_eOffset; vl_i:=vl_i-1) {
      v_LGenBase_entities[vl_i]:= c_empty_LGenBase_EntityCtx;
      f_EPTF_FBQ_initFreeBusyQueue(v_LGenBase_entities[vl_i].fsmCtxQueue);
      //v_LGenBase_entities[vl_i].name := pl_eNamePrefix&int2str(vl_i);
      v_LGenBase_entities[vl_i].eGrpBackIdx := pl_eGrpBackRef;
      var integer vl_bCount := sizeof(v_LGenBase_behaviorTypes);
      for ( var integer vl_iB := 0; vl_iB < vl_bCount ; vl_iB := vl_iB+1 )
      {
        v_LGenBase_entities[vl_i].bCtxList[vl_iB]:={};
      }
    }
  }
  
  friend function f_EPTF_LGenBase_getCustomEntitySuccFn(
    in charstring pl_name,
    out EPTF_LGenBase_evaluateSuccess4EntityAtEntityGroup2_FT pl_fn)
  runs on EPTF_LGenBase_Private_CT{
    if(""!=pl_name){
      var integer vl_fnIdx := f_EPTF_LGenBase_functionNameIndex(pl_name);
      if(-1 == vl_fnIdx){
        f_EPTF_LGenBase_loggingError(%definitionId&": Invalid custom entity success function: "&pl_name);
      }
      if(not ischosen(v_LGenBase_functions[vl_fnIdx].evaluateSuccess4EntityAtEntityGroup2)){
        f_EPTF_LGenBase_loggingError(%definitionId&": Invalid custom entity success function type: "&pl_name);
      }
      pl_fn := v_LGenBase_functions[vl_fnIdx].evaluateSuccess4EntityAtEntityGroup2;
    }
  }
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_TrafficCaseTypeInternalDeclarator
  // 
  //  Purpose:
  //    Checkes the content of the traffic case declarator, and fills the
  //    internal storage
  ///////////////////////////////////////////////////////////
  private function f_EPTF_LGenBase_fillTcTypeDescriptor(
    in EPTF_LGenBase_TrafficCaseTypeInternalDeclarator pl_tc,
    out EPTF_LGenBase_TcTypeDescriptor pl_tcType
  )
  runs on EPTF_LGenBase_Private_CT{
    pl_tcType := c_EPTF_LGenBase_emptyTcTypeDescriptor;
    if(-1 < f_EPTF_LGenBase_tcTypeNameIndex(pl_tc.name)){
      f_EPTF_LGenBase_loggingError(%definitionId&": The traffic case name already exists: "&pl_tc.name);
    }
    pl_tcType.name := pl_tc.name;
    if("" == pl_tc.fsmName){
      f_EPTF_LGenBase_loggingError(%definitionId&": FMS name must not be empty.");
    }
    pl_tcType.fsmIdx := f_EPTF_LGenBase_fsmNameIndex(pl_tc.fsmName);
    if(-1 == pl_tcType.fsmIdx){
      f_EPTF_LGenBase_loggingError(%definitionId&": Invalid FSM name: "&pl_tc.fsmName);
    }
    if(""!=pl_tc.customEntitySucc and ""!= pl_tc.customEntitySuccPrev){
      f_EPTF_LGenBase_loggingError(%definitionId&": Both versions of custom entity success function are present: "&
        pl_tc.customEntitySucc&" and "&pl_tc.customEntitySuccPrev);
    }
    if(""!=pl_tc.customEntitySucc){
      f_EPTF_LGenBase_getCustomEntitySuccFn(pl_tc.customEntitySucc,pl_tcType.customEntitySucc2);
    }
    if("" != pl_tc.customEntitySuccPrev){
      var integer vl_fnIdx := f_EPTF_LGenBase_functionNameIndex(pl_tc.customEntitySuccPrev);
      f_EPTF_Base_assert(%definitionId&": Invalid custom entity success function: "&pl_tc.customEntitySuccPrev,
        -1 != vl_fnIdx);
      f_EPTF_Base_assert(%definitionId&": Invalid custom entity success function type: "&pl_tc.customEntitySuccPrev,
        ischosen(v_LGenBase_functions[vl_fnIdx].evaluateSuccess4EntityAtEntityGroup));
      pl_tcType.customEntitySuccPrev := v_LGenBase_functions[vl_fnIdx].evaluateSuccess4EntityAtEntityGroup;
    }
    pl_tcType.entityTypeIdx := f_EPTF_LGenBase_entityTypeNameIndex(pl_tc.entityType);
    f_EPTF_Base_assert(%definitionId&": Invalid entity type: "&pl_tc.entityType,-1 != pl_tcType.entityTypeIdx);
    pl_tcType.params := pl_tc.params;
    pl_tcType.entityFinishConditions := pl_tc.entityFinishConditions
    pl_tcType.trafficStartFinishConditions := pl_tc.trafficStartFinishConditionsAndFunctions 
  }//f_EPTF_LGenBase_fillTcTypeDescriptor  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_ParamedFsmTable_checkDuplicatedEventToListen
  // 
  //  Purpose:
  //    Checks if there is already a registered event listener with the same parameters 
  ///////////////////////////////////////////////////////////
  private function f_EPTF_LGenBase_ParamedFsmTable_checkDuplicatedEventToListen(
    in  EPTF_LGenBase_CompactFsmTableDeclarator pl_table)
  runs on EPTF_LGenBase_Private_CT{
    for(var integer i := 1; i < sizeof(pl_table.table); i := i + 1) {
      for(var integer j := 0; j < i; j := j + 1) {
        if(pl_table.table[i].eventToListen.bName == pl_table.table[j].eventToListen.bName and
          pl_table.table[i].eventToListen.iName == pl_table.table[j].eventToListen.iName) {
          f_EPTF_LGenBase_loggingWarning(%definitionId&": FSM table "& pl_table.name& " has duplicated listener for event ("&
            pl_table.table[i].eventToListen.bName& ", "& pl_table.table[i].eventToListen.iName& ").");
        }
      }
    }
  }//f_EPTF_LGenBase_ParamedFsmTable_checkDuplicatedEventToListen
  
  ///////////////////////////////////////////////////////////
  //  Group: processR3Declarators
  // 
  //  Purpose:
  //    functions for processing R3 declarators
  ///////////////////////////////////////////////////////////  
  group processR3Declarators{
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_processStateDeclarations
    // 
    //  Purpose:
    //    Copies the list of states if the list is empty 
    // 
    //  Errors & assertions:
    //    The stateList of the FSM must be empty
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_processStateDeclarations(
      in EPTF_LGenBase_FsmLocalStateList pl_states,
      in integer pl_nameHashmap,
      inout EPTF_LGenBase_InternalFsmTable pl_fsm)
    runs on EPTF_LGenBase_Private_CT{
      f_EPTF_LGenBase_loggingDebugConfig(%definitionId)
      f_EPTF_Base_assert(%definitionId&": The list of FSM states is already defined!",0 == sizeof(pl_fsm.stateList));
      var integer vl_stateCount := sizeof(pl_states)
      for ( var integer vl_i := 0; vl_i < vl_stateCount ; vl_i := vl_i+1 )
      {
        f_EPTF_str2int_HashMap_Insert(pl_nameHashmap, pl_states[vl_i], vl_i);
      }
      pl_fsm.stateList := pl_states;
    }//f_EPTF_LGenBase_processStateDeclarations
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_processStatHandlerDeclarations
    // 
    //  Purpose:
    //    Appends the list of statistics to the FSM 
    // 
    //  Errors & assertions:
    //    There mustn't be statistics with the same name
    //
    //  Detailed comments:
    //    The HashMap passed in parameter <pl_nameHashmap> must contain
    //    the names of all the previously declared FSM statistis of the FSM 
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_processStatHandlerDeclarations(
      in EPTF_LGenBase_FsmStatHandlerDeclaratorList pl_stats,
      inout EPTF_LGenBase_InternalFsmTable pl_fsm)
    runs on EPTF_LGenBase_Private_CT{
      for ( var integer vl_i := 0; vl_i < sizeof(pl_stats) ; vl_i := vl_i+1 )
      {
        f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Processing statistic declaration: "&log2str( pl_stats[vl_i] ))
        var integer vl_statXRefIdx := sizeof(pl_fsm.statisticXRefs);
        var integer vl_scope := enum2int(pl_stats[vl_i].scope)
        var integer vl_temp;
        if(f_EPTF_str2int_HashMap_Find(pl_fsm.statisticNamesHash, pl_stats[vl_i].name, vl_temp)){
          f_EPTF_LGenBase_loggingError(%definitionId&": The FSM statistic "&pl_stats[vl_i].name&" is already defined!");
        }
        var integer vl_actId := pl_fsm.statisticCounts[vl_scope];
        pl_fsm.statisticXRefs[vl_statXRefIdx]:={vl_scope, vl_actId}
        f_EPTF_str2int_HashMap_Insert(pl_fsm.statisticNamesHash, pl_stats[vl_i].name, vl_statXRefIdx);
        pl_fsm.statisticListArray[vl_scope][vl_actId] := c_EPTF_LGenBase_emptyFsmStatDescriptor
        pl_fsm.statisticListArray[vl_scope][vl_actId].name := pl_stats[vl_i].name;
        pl_fsm.statisticListArray[vl_scope][vl_actId].statMethod := pl_stats[vl_i].statMethod;
        pl_fsm.statisticListArray[vl_scope][vl_actId].statResetValue := pl_stats[vl_i].statResetValue;
        var integer vl_providerListCount := sizeof(pl_stats[vl_i].providers);
        for ( var integer vl_providerListIdx := 0; vl_providerListIdx < vl_providerListCount ; vl_providerListIdx := vl_providerListIdx+1 ){
          pl_fsm.statisticListArray[vl_scope][vl_actId].providerDeclarators[vl_providerListIdx] := pl_stats[vl_i].providers[vl_providerListIdx];
          select( true ){
            case ( ischosen(pl_stats[vl_i].providers[vl_providerListIdx].varList) ){
              for ( var integer vl_var := 0; vl_var < sizeof(pl_stats[vl_i].providers[vl_providerListIdx].varList) ; vl_var := vl_var+1 ){
                var integer vl_varIdx := -1;
                if(f_EPTF_str2int_HashMap_Find(pl_fsm.varNamesHash, 
                    pl_stats[vl_i].providers[vl_providerListIdx].varList[vl_var],
                    vl_varIdx)){
                  pl_fsm.statisticListArray[vl_scope][vl_actId].providers[vl_providerListIdx].varXrefList[vl_var] := vl_varIdx;
                }else{ 
                  f_EPTF_Base_assert(%definitionId&": Invalid provider variable "&pl_stats[vl_i].providers[vl_providerListIdx].varList[vl_var]&
                    "in declaration of statistic "&log2str(pl_stats[vl_i].name&
                      " of FSM "&pl_fsm.name),false);
                }
              }
            }
            case ( ischosen(pl_stats[vl_i].providers[vl_providerListIdx].statMeas) ){
              var integer vl_varIdx := -1;
              if(f_EPTF_str2int_HashMap_Find(pl_fsm.statMeasNamesHash, 
                  pl_stats[vl_i].providers[vl_providerListIdx].statMeas,
                  vl_varIdx)){
                pl_fsm.statisticListArray[vl_scope][vl_actId].providers[vl_providerListIdx].statMeasXref := vl_varIdx;
              }else{ 
                f_EPTF_Base_assert(%definitionId&": Invalid provider "&pl_stats[vl_i].providers[vl_providerListIdx].statMeas&
                  "in declaration of statistic "&log2str(pl_stats[vl_i].name&
                    " of FSM "&pl_fsm.name),false);
              }
            }
            case ( ischosen(pl_stats[vl_i].providers[vl_providerListIdx].statHandler) ){
              var integer vl_varIdx := -1;
              if(f_EPTF_str2int_HashMap_Find(pl_fsm.statisticNamesHash, 
                  pl_stats[vl_i].providers[vl_providerListIdx].statHandler,
                  vl_varIdx)){
                pl_fsm.statisticListArray[vl_scope][vl_actId].providers[vl_providerListIdx].statHandlerXref := vl_varIdx
              }else{ 
                f_EPTF_Base_assert(%definitionId&": Invalid provider "&pl_stats[vl_i].providers[vl_providerListIdx].statHandler&
                  "in declaration of statistic "&log2str(pl_stats[vl_i].name&
                    " of FSM "&pl_fsm.name),false);
              }
            }
            case else{
              f_EPTF_Base_assert(%definitionId&": Invalid provider type "&log2str(pl_stats[vl_i].providers[vl_providerListIdx])&
                "in declaration of statistic "&log2str(pl_stats[vl_i].name&
                  " of FSM "&pl_fsm.name),false);
            }
          }
          
        }
        pl_fsm.statisticCounts[vl_scope] := pl_fsm.statisticCounts[vl_scope] + 1;
      }
    }//f_EPTF_LGenBase_processStatHandlerDeclarations
    
    private function f_EPTF_LGenBase_processStatDeclarations(
      in EPTF_LGenBase_FsmStatDeclaratorList pl_stats,
      inout EPTF_LGenBase_InternalFsmTable pl_fsm)
    runs on EPTF_LGenBase_Private_CT{
      var EPTF_LGenBase_FsmStatHandlerDeclaratorList vl_decl := {}
      for ( var integer vl_i := 0; vl_i < sizeof(pl_stats) ; vl_i := vl_i+1 ){
        vl_decl[vl_i].name := pl_stats[vl_i].name
        for ( var integer vl_varList := 0; vl_varList < sizeof(pl_stats[vl_i].providersList) ; vl_varList := vl_varList+1 ){
          vl_decl[vl_i].providers[0].varList := pl_stats[vl_i].providersList[vl_varList]
          vl_decl[vl_i].statMethod := pl_stats[vl_i].statMethod
          vl_decl[vl_i].statResetValue := pl_stats[vl_i].statResetValue
          vl_decl[vl_i].scope := pl_stats[vl_i].scope
        }
      }
      f_EPTF_LGenBase_processStatHandlerDeclarations(vl_decl, pl_fsm)
    }//f_EPTF_LGenBase_processStatDeclarations
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_processStatMeasDeclarationsWithParams
    // 
    //  Purpose:
    //    Appends the list of measured statistics to the FSM 
    // 
    //  Errors & assertions:
    //    There mustn't be measured statistics with the same name
    //
    //  Detailed comments:
    //    The HashMap passed in parameter <pl_nameHashmap> must contain
    //    the names of all the previously declared FSM measured statistis of the FSM 
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_processStatMeasDeclarationsWithParams(
      in EPTF_LGenBase_FsmStatMeasWithParamsDeclaratorList pl_stats,
      inout EPTF_LGenBase_InternalFsmTable pl_fsm)
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_xRefIdx := sizeof(pl_fsm.statMeasXRefs);
      for ( var integer vl_i := 0; vl_i < sizeof(pl_stats) ; vl_i := vl_i+1 )
      {
        f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Processing measured statistic declaration: "&log2str( pl_stats[vl_i] ))
        var integer vl_scope := enum2int(pl_stats[vl_i].scope)
        var integer vl_temp;
        if(f_EPTF_str2int_HashMap_Find(pl_fsm.statMeasNamesHash, pl_stats[vl_i].name, vl_temp)){
          f_EPTF_LGenBase_loggingError(%definitionId&": The FSM measured statistic "&pl_stats[vl_i].name&" is already defined!");
        }
        if("" != pl_stats[vl_i].providerVarName and
          not f_EPTF_str2int_HashMap_Find(pl_fsm.varNamesHash, pl_stats[vl_i].providerVarName, vl_temp)){
          f_EPTF_LGenBase_loggingError(%definitionId&": The provider variable "&pl_stats[vl_i].providerVarName&" FSM measured statistic "&pl_stats[vl_i].name&" is not defined!");
        }
        var integer vl_actId := pl_fsm.statMeasCounts[vl_scope];
        pl_fsm.statMeasXRefs[vl_xRefIdx] := {vl_scope, vl_actId}
        f_EPTF_str2int_HashMap_Insert(pl_fsm.statMeasNamesHash, pl_stats[vl_i].name, vl_xRefIdx);
        pl_fsm.statMeasStatListArray[vl_scope][vl_actId] := c_EPTF_LGenBase_emptyFsmStatMeasDescriptor;
        pl_fsm.statMeasStatListArray[vl_scope][vl_actId].params := pl_stats[vl_i].statMeasParams
        pl_fsm.statMeasStatListArray[vl_scope][vl_actId].name := pl_stats[vl_i].name;
        if("" != pl_stats[vl_i].providerVarName){
          if(f_EPTF_str2int_HashMap_Find(pl_fsm.varNamesHash, 
              pl_stats[vl_i].providerVarName,
              pl_fsm.statMeasStatListArray[vl_scope][vl_actId].varXRef)){
          }else{ 
            f_EPTF_Base_assert(%definitionId&": Invalid provider "&pl_stats[vl_i].providerVarName&
              "in declaration of measured statistic "&log2str(pl_stats[vl_i].name&
                " of FSM "&pl_fsm.name),false);
          }
        }
        if("" != pl_stats[vl_i].targetVarName and omit != pl_stats[vl_i].targetVarName){
          pl_fsm.statMeasStatListArray[vl_scope][vl_actId].targetVarName := pl_stats[vl_i].targetVarName 
        }
        pl_fsm.statMeasCounts[vl_scope] := pl_fsm.statMeasCounts[vl_scope] + 1;
        vl_xRefIdx := vl_xRefIdx +1;
      }
    }
    
    private function f_EPTF_LGenBase_processStatMeasDeclarationsWithoutBoundaries(
      in EPTF_LGenBase_FsmStatMeasDeclaratorList pl_stats,
      inout EPTF_LGenBase_InternalFsmTable pl_fsm)
    runs on EPTF_LGenBase_Private_CT{
      var EPTF_LGenBase_FsmStatMeasWithParamsDeclaratorList vl_list := {}
      for ( var integer vl_i := 0; vl_i < sizeof(pl_stats) ; vl_i := vl_i+1 ){
        vl_list[vl_i] := c_EPTF_LGenBase_emptyFsmStatMeasWithParamsDeclarator
        vl_list[vl_i].name := pl_stats[vl_i].name
        vl_list[vl_i].statMeasParams.statType := pl_stats[vl_i].statType
        vl_list[vl_i].providerVarName := pl_stats[vl_i].varName
        vl_list[vl_i].scope := pl_stats[vl_i].scope
      }
      f_EPTF_LGenBase_processStatMeasDeclarationsWithParams(
        vl_list, 
        pl_fsm)
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_processVariableDeclarations
    // 
    //  Purpose:
    //    Appends the list of variables to the FSM 
    // 
    //  Errors & assertions:
    //    There mustn't be FSM variables with the same name
    //
    //  Detailed comments:
    //    The HashMap passed in parameter <pl_nameHashmap> must contain
    //    the names of all the previously declared FSM statistis of the FSM 
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_processVariableDeclarations(
      in EPTF_LGenBase_FsmVarDeclaratorList pl_vars,
      in integer pl_nameHashmap,
      inout EPTF_LGenBase_InternalFsmTable pl_fsm)
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_varXRefIdx := sizeof(pl_fsm.varXRefs);
      for ( var integer vl_i := 0; vl_i < sizeof(pl_vars) ; vl_i := vl_i+1 )
      {
        var integer vl_scope := enum2int(pl_vars[vl_i].scope)
        var integer vl_temp;
        if(f_EPTF_str2int_HashMap_Find(pl_nameHashmap, pl_vars[vl_i].name, vl_temp)){
          f_EPTF_LGenBase_loggingError(%definitionId&": The FSM variable "&pl_vars[vl_i].name&" is already defined!");
        }
        var integer vl_actId := pl_fsm.varCounts[vl_scope];
        pl_fsm.varXRefs[vl_varXRefIdx] := {vl_scope, vl_actId}
        f_EPTF_str2int_HashMap_Insert(pl_nameHashmap, pl_vars[vl_i].name, vl_varXRefIdx);
        pl_fsm.varListArray[vl_scope][vl_actId] := c_EPTF_LGenBase_emptyFsmVarDescriptor;
        pl_fsm.varListArray[vl_scope][vl_actId].name := pl_vars[vl_i].name;
        pl_fsm.varListArray[vl_scope][vl_actId].initValue := pl_vars[vl_i].initValue;
        pl_fsm.varCounts[vl_scope] := pl_fsm.varCounts[vl_scope] + 1;
        vl_varXRefIdx := vl_varXRefIdx +1;
      }
    }//f_EPTF_LGenBase_processVariableDeclarations
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_processTimerDeclarations
    // 
    //  Purpose:
    //    Appends the list of timers to the FSM 
    // 
    //  Errors & assertions:
    //    There mustn't be timers with the same name
    //
    //  Detailed comments:
    //    The HashMap passed in parameter <pl_nameHashmap> must contain
    //    the names of all the previously declared FSM statistis of the FSM 
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_processTimerDeclarations(
      in EPTF_LGenBase_FsmTimerInternalList pl_timers,
      in integer pl_nameHashmap,
      inout EPTF_LGenBase_InternalFsmTable pl_fsm)
    runs on EPTF_LGenBase_Private_CT{
      f_EPTF_LGenBase_loggingDebugConfig(%definitionId)
      //Add the new ones
      for ( var integer vl_i := 0; vl_i < sizeof(pl_timers) ; vl_i := vl_i+1 )
      {
        var integer vl_statIdx := -1;
        if(c_EPTF_Common_debugSwitch){
          f_EPTF_Base_assert(%definitionId&": The FSM timer "&pl_timers[vl_i].name&" is already defined in table "&
            pl_fsm.name&"!",
            not f_EPTF_str2int_HashMap_Find(pl_nameHashmap, pl_timers[vl_i].name, vl_statIdx));
          if(ischosen(pl_timers[vl_i].timerParams.random)){
            f_EPTF_Base_assert(%definitionId&": The minimal timeout value of FSM timer "&pl_timers[vl_i].name&
              " of table "& pl_fsm.name&
              " must be a positive value instead of "&float2str(pl_timers[vl_i].timerParams.random.timeoutMin),pl_timers[vl_i].timerParams.random.timeoutMin >= 0.0)
            f_EPTF_Base_assert(%definitionId&": The maximal timeout value of FSM timer "&pl_timers[vl_i].name&
              " of table "& pl_fsm.name&
              " must be a positive value instead of "&float2str(pl_timers[vl_i].timerParams.random.timeoutMax),pl_timers[vl_i].timerParams.random.timeoutMax >= 0.0)
            f_EPTF_Base_assert(%definitionId&": The maximal timeout value ("&
              float2str(pl_timers[vl_i].timerParams.random.timeoutMax)&") of FSM timer "&pl_timers[vl_i].name&
              " of table "& pl_fsm.name&
              " must be greater than the minimal timeout value: "&float2str(pl_timers[vl_i].timerParams.random.timeoutMin),
              pl_timers[vl_i].timerParams.random.timeoutMax >= pl_timers[vl_i].timerParams.random.timeoutMin)
          }else if (ischosen(pl_timers[vl_i].timerParams.static)){
            f_EPTF_Base_assert(%definitionId&": The timeout value of FSM timer "&pl_timers[vl_i].name&
              " of table "& pl_fsm.name&
              " must be a positive value instead of "&float2str(pl_timers[vl_i].timerParams.static.startValue), pl_timers[vl_i].timerParams.static.startValue >= 0.0)
            
          }else if (ischosen(pl_timers[vl_i].timerParams.randomGauss)){
            f_EPTF_Base_assert(%definitionId&": The mean value of FSM timer "&pl_timers[vl_i].name&
              " of table "& pl_fsm.name&
              " must be a positive value instead of "&float2str(pl_timers[vl_i].timerParams.randomGauss.mean), pl_timers[vl_i].timerParams.randomGauss.mean > 0.0)
          }else {
            f_EPTF_Base_assert(%definitionId&": Unknown FSM timer parameter type " &
              log2str(pl_timers[vl_i].timerParams), false);
          }
        }
        f_EPTF_str2int_HashMap_Insert(pl_nameHashmap, pl_timers[vl_i].name, vl_i);
        pl_fsm.timerList[vl_i] := pl_timers[vl_i];
      }
    }//f_EPTF_LGenBase_processTimerDeclarations
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_processCompactTableDeclarations
    // 
    //  Purpose:
    //    Appends the table rows to the FSM 
    // 
    //  Errors & assertions:
    //    The names of referred FSM objects must be valid.
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_processCompactTableDeclarations(
      in EPTF_LGenBase_FsmTableRowDeclaratorList pl_rows,
      inout EPTF_LGenBase_InternalFsmTable pl_fsm)
    runs on EPTF_LGenBase_Private_CT{
      f_EPTF_LGenBase_loggingDebugConfig(%definitionId)
      f_EPTF_Base_assert(%definitionId&": The FSM table is already defined!", 0 == sizeof(pl_fsm.rows));      
      
      var integer vl_rowCount := sizeof(pl_rows);
      var boolean vl_found := false;
      var integer vl_stateCount := sizeof(pl_fsm.stateList);
      
      //Initialize the column index list
      var EPTF_IntegerList vl_colIdxList := {}
      for ( var integer vl_state := 0; vl_state < sizeof(pl_fsm.stateList) ; vl_state := vl_state+1 ){
        vl_colIdxList[vl_state] := vl_state
      }
      for (var integer vl_row:=0; vl_row<vl_rowCount; vl_row:=vl_row+1){
        // Process events to listen
        var integer vl_bIdx := -1;
        var integer vl_iIdx := -1;
        pl_fsm.eventXref[vl_row] := c_EPTF_LGenBase_emptyInternalFSMEvent2RowXref;
        if ( c_EPTF_LGenBase_specialBName_timerTimeout == pl_rows[vl_row].eventToListen.bName )
        {
          vl_iIdx := f_EPTF_LGenBase_fsmTimerIdx(pl_fsm.timerList, pl_rows[vl_row].eventToListen.iName);
          f_EPTF_Base_assert(%definitionId&": The declared event is a timer timeout event, but the "&pl_rows[vl_row].eventToListen.iName&" name is not in the list of timers!",-1 != vl_iIdx);
          
          pl_fsm.eventXref[vl_row].event2Listen.bIdx := c_EPTF_LGenBase_specialBIdx_timerTimeout;
          pl_fsm.eventXref[vl_row].event2Listen.iIdx := vl_iIdx; 
          pl_fsm.eventXref[vl_row].event2Listen.eventType := pl_rows[vl_row].eventToListen.eventType;
        }
        else
        {
          vl_found := f_EPTF_str2int_HashMap_Find(v_LGenBase_fsmEventsBehaviorHashMap, pl_rows[vl_row].eventToListen.bName&tsp_LGenBase_nameSeparator&pl_rows[vl_row].eventToListen.iName, vl_bIdx)
          //TODO error instead of asserts
          f_EPTF_Base_assert(%definitionId&": The declared "&pl_rows[vl_row].eventToListen.bName&" event behavior name is not valid!",vl_found);
          vl_found := f_EPTF_str2int_HashMap_Find(v_LGenBase_fsmEventsInputHashMap, pl_rows[vl_row].eventToListen.bName&tsp_LGenBase_nameSeparator&pl_rows[vl_row].eventToListen.iName, vl_iIdx)
          f_EPTF_Base_assert(%definitionId&": The declared "&pl_rows[vl_row].eventToListen.iName&" event input name is not valid!",vl_found);
          pl_fsm.eventXref[vl_row].event2Listen.bIdx := vl_bIdx;
          pl_fsm.eventXref[vl_row].event2Listen.iIdx := vl_iIdx;
          pl_fsm.eventXref[vl_row].event2Listen.eventType := pl_rows[vl_row].eventToListen.eventType;
        }
        pl_fsm.eventXref[vl_row].rowIdx := vl_row;
        // Process cell declarations
        var integer vl_cellRowCount := sizeof(pl_rows[vl_row].cellRow);
        f_EPTF_Base_assert(%definitionId&": The count of the declared states and the states in row#"&int2str(vl_row)&" of the FSM differ! States: "&log2str( pl_fsm.stateList )&" Row: "&log2str( pl_rows[vl_row].cellRow ),
          vl_stateCount == vl_cellRowCount); 
        var EPTF_LGenBase_FsmTableCellInternal vl_cellInternal
        for (var integer vl_c:=0; vl_c<vl_cellRowCount; vl_c:=vl_c+1) {
          f_EPTF_LGenBase_classicCell2internal(pl_rows[vl_row].cellRow[vl_c], vl_cellInternal)
          f_EPTF_LGenBase_createInternalFsmCell( vl_cellInternal,
            vl_row, vl_c, pl_fsm, pl_fsm.rows[vl_row].cellList[vl_c] );
        }//columns
        pl_fsm.rows[vl_row].colIdxListByStates := vl_colIdxList
      }//rows
    }//f_EPTF_LGenBase_processTableDeclarations
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_appendEventList
    // 
    //  Purpose:
    //    Creates a list of events from an event range list 
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_appendEventList(
      in EPTF_LGenBase_EventSet pl_eventSet,
      in EPTF_LGenBase_InternalFsmTable pl_fsm,
      in integer pl_rowIdx,
      inout EPTF_LGenBase_InternalFSMEvent2RowXrefList pl_outEventList)
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_sizeIn := sizeof(pl_outEventList)
      // iterate through the setItems in eventSet
      for (var integer i:= 0; i<sizeof(pl_eventSet); i:=i+1) {
        select(true)
        {
          case( ischosen(pl_eventSet[i].singleEvent) ){
            f_EPTF_LGenBase_appendEventToList(
              f_EPTF_LGenBase_convertEvent(
                pl_eventSet[i].singleEvent.bName,
                pl_eventSet[i].singleEvent.iName,
                pl_eventSet[i].singleEvent.eventType,
                pl_fsm,
                pl_rowIdx),
              pl_rowIdx,
              vl_sizeIn,
              pl_outEventList);
          }
          case( ischosen(pl_eventSet[i].eventList) ){
            for ( var integer j := 0; j < sizeof(pl_eventSet[i].eventList.iNameList) ; j := j+1 )
            {
              f_EPTF_LGenBase_appendEventToList(
                f_EPTF_LGenBase_convertEvent(
                  pl_eventSet[i].eventList.bName,
                  pl_eventSet[i].eventList.iNameList[j],
                  pl_eventSet[i].eventList.eventType,
                  pl_fsm,
                  pl_rowIdx),
                pl_rowIdx,
                vl_sizeIn,
                pl_outEventList
              );
            }
          }
          case( ischosen(pl_eventSet[i].eventRange) ){
            // check limits of event interval
            var EPTF_LGenBase_EventDescriptor vl_low := f_EPTF_LGenBase_convertEvent(
              pl_eventSet[i].eventRange.bName,
              pl_eventSet[i].eventRange.iNameMin,
              pl_eventSet[i].eventRange.eventType, 
              pl_fsm,
              pl_rowIdx
            ); 
            var EPTF_LGenBase_EventDescriptor vl_hi := f_EPTF_LGenBase_convertEvent(
              pl_eventSet[i].eventRange.bName,
              pl_eventSet[i].eventRange.iNameMax,
              pl_eventSet[i].eventRange.eventType, 
              pl_fsm,
              pl_rowIdx
            ); 
            // check if range is valid
            if(vl_low.iIdx > vl_hi.iIdx){
              f_EPTF_LGenBase_loggingError(%definitionId&
                ": The declared event input names <" & pl_eventSet[i].eventRange.iNameMin & ", " & pl_eventSet[i].eventRange.iNameMax & "> don't specify a valid range!")
            }
            // iterate through the event range, create internal events and put them to output list
            for (var integer j:= vl_low.iIdx; j<=vl_hi.iIdx; j:=j+1) {
              f_EPTF_LGenBase_appendEventToList(
                {vl_low.bIdx, j, vl_low.eventType},
                pl_rowIdx,
                vl_sizeIn,
                pl_outEventList);
            }
          }
          case else{
            f_EPTF_Base_assert(%definitionId&": EventSet undefined type " & log2str(pl_eventSet[i]), false);
          }
        }
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_convertEvent
    // 
    //  Purpose:
    //    Converts an inpout event to internal format or asserts if the event is not declared 
    ///////////////////////////////////////////////////////////
    friend function f_EPTF_LGenBase_convertEvent(
      in charstring pl_bName,
      in charstring pl_iName,
      in EPTF_LGenBase_ReportableEventType pl_eventType,
      in EPTF_LGenBase_InternalFsmTable pl_fsm,
      in integer pl_rowIdx)
    runs on EPTF_LGenBase_Private_CT
    return EPTF_LGenBase_EventDescriptor{
      var integer vl_bIdx, vl_iIdx;
      if ( c_EPTF_LGenBase_specialBName_timerTimeout == pl_bName ) {
        vl_bIdx := c_EPTF_LGenBase_specialBIdx_timerTimeout;
        vl_iIdx := f_EPTF_LGenBase_fsmTimerIdx(pl_fsm.timerList, pl_iName);
        if (c_EPTF_Common_debugSwitch){
          f_EPTF_Base_assert(%definitionId&": The declared event is a timer timeout event, but the "&pl_iName&" name is not in the list of timers!",-1 != vl_iIdx);
        }
      }
      else {
        var boolean vl_found := f_EPTF_str2int_HashMap_Find(v_LGenBase_fsmEventsBehaviorHashMap, pl_bName&tsp_LGenBase_nameSeparator&pl_iName, vl_bIdx)
        vl_found := vl_found and f_EPTF_str2int_HashMap_Find(v_LGenBase_fsmEventsInputHashMap, pl_bName&tsp_LGenBase_nameSeparator&pl_iName, vl_iIdx)
        if (not vl_found){
          f_EPTF_LGenBase_loggingError(%definitionId&": The declared "&pl_bName&tsp_LGenBase_nameSeparator&pl_iName&
            " event name is not valid in row ("&int2str(pl_rowIdx)&") of FSM "&pl_fsm.name&"!");
        } 
      }
      //TODO use const!
      var EPTF_LGenBase_EventDescriptor vl_outEvent := {vl_bIdx, vl_iIdx, pl_eventType};
      return(vl_outEvent);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_appendEventToList
    // 
    //  Purpose:
    //    Appends a new event to an event list if the event is not yet in the list 
    ///////////////////////////////////////////////////////////
    friend function f_EPTF_LGenBase_appendEventToList(
      in EPTF_LGenBase_EventDescriptor pl_event,
      in integer pl_rowIdx,
      in integer pl_checkFrom,
      inout EPTF_LGenBase_InternalFSMEvent2RowXrefList pl_outEventList,
      in integer pl_siblingRef := -1)
    runs on EPTF_LGenBase_Private_CT{
      //TODO The event type should be checked. 
      //All the events must have the same type!!
      // if this event is not yet in the list, add it to the list
      var integer i := pl_checkFrom;
      while(i<sizeof(pl_outEventList) and pl_event != pl_outEventList[i].event2Listen) {
        i:=i+1
      }
      if (i == sizeof(pl_outEventList)) {
        pl_outEventList[i].event2Listen := pl_event;
        pl_outEventList[i].rowIdx := pl_rowIdx;
        pl_outEventList[i].siblingRef := pl_siblingRef;
      }
      else {
        f_EPTF_LGenBase_loggingWarning("The event with index: " & log2str(pl_event.iIdx) & "is already added to input event list!");
      }
    }
    
    private function f_EPTF_LGenBase_charstringInList(
      in EPTF_CharstringList pl_list,
      in charstring pl_search4)
    return integer{
      for ( var integer vl_i := 0; vl_i < sizeof(pl_list); vl_i := vl_i+1 ){
        if(pl_list[vl_i] == pl_search4){
          return vl_i
        }
      }
      return -1
    }
    
    private function f_EPTF_LGenBase_varName2IntList(
      in charstring pl_varName,
      in EPTF_LGenBase_InternalFsmTable pl_fsm,
      in integer pl_row, //debug purposes
      in integer pl_col, //debug purposes
      in integer pl_startIdx,
      inout EPTF_IntegerList pl_destArgs)
    runs on EPTF_LGenBase_Private_CT
    {
      var integer vl_idx := -1
      if(not f_EPTF_str2int_HashMap_Find(pl_fsm.varNamesHash,
          pl_varName,
          vl_idx)){
        f_EPTF_LGenBase_loggingError(%definitionId&": Invalid variable name \""&pl_varName&"\" in FSMRow#"&int2str(pl_row)&" , cellrow#"&int2str(pl_col)&
          " in FSM table "& pl_fsm.name);
      }
      pl_destArgs[pl_startIdx]   := pl_fsm.varXRefs[vl_idx].idxInScope;
      pl_destArgs[pl_startIdx+1] := pl_fsm.varXRefs[vl_idx].scope
    }
    
    private function f_EPTF_LGenBase_stepArgs2IntList(
      in EPTF_LGenBase_FsmActionArgsDeclarator pl_args,
      inout EPTF_LGenBase_InternalFsmTable pl_fsm,
      in integer pl_row, //debug purposes
      in integer pl_col, //debug purposes
      out EPTF_IntegerList pl_destArgs)
    runs on EPTF_LGenBase_Private_CT
    {
      var integer vl_iIdx := -1;
      //What kind of context arguments?
      select(true){
        case(ischosen(pl_args.timerName)){
          vl_iIdx := f_EPTF_LGenBase_fsmTimerIdx(pl_fsm.timerList, pl_args.timerName);
          if(0 > vl_iIdx){
            f_EPTF_LGenBase_loggingError(%definitionId&": The declared "&pl_args.timerName&
              " timer name in FSM table "& pl_fsm.name&
              " in FSMRow#"&int2str(pl_row)&" , cellrow#"&int2str(pl_col)&
              " is not in the list of timers");
          }
          pl_destArgs := {vl_iIdx}; 
        }
        case(ischosen(pl_args.varNames)){
          //Convert variable names to their indices
          pl_destArgs := {};
          for ( var integer vl_varI := 0; vl_varI < sizeof(pl_args.varNames) ; vl_varI := vl_varI+1 )
          {
            f_EPTF_LGenBase_varName2IntList(
              pl_args.varNames[vl_varI],
              pl_fsm, 
              pl_row, 
              pl_col, 
              vl_varI*2, 
              pl_destArgs)
          }
        }
        case(ischosen(pl_args.statMeasName)){
          //Convert measured statistic names to their indices
          var integer vl_idx := -1;
          if(not f_EPTF_str2int_HashMap_Find(pl_fsm.statMeasNamesHash,
              pl_args.statMeasName,
              vl_idx)){
            f_EPTF_LGenBase_loggingError(%definitionId&": Invalid measured statistic name "&
              pl_args.statMeasName&" in FSMRow#"&int2str(pl_row)&" , cellrow#"&int2str(pl_col)&
              " in FSM table "& pl_fsm.name);
          }
          pl_destArgs := {
            pl_fsm.statMeasXRefs[vl_idx].idxInScope,
            pl_fsm.statMeasXRefs[vl_idx].scope}
        }
        case(ischosen(pl_args.varParams)){
          pl_destArgs := {};
          f_EPTF_LGenBase_varName2IntList(
            pl_args.varParams.varName,
            pl_fsm, 
            pl_row, 
            pl_col,
            0,
            pl_destArgs 
          )
          if(ispresent(pl_args.varParams.paramValue)){
            pl_destArgs[2] := sizeof(pl_fsm.paramValues);
            pl_fsm.paramValues[pl_destArgs[2]] := pl_args.varParams.paramValue;
          }
        }
        case(ischosen(pl_args.statMeasParams)){
          var EPTF_IntegerList vl_args := {};
          var integer vl_idx := -1;
          if(not f_EPTF_str2int_HashMap_Find(pl_fsm.statMeasNamesHash,
              pl_args.statMeasParams.statMeasName,
              vl_idx)){
            f_EPTF_LGenBase_loggingError(%definitionId&": Invalid measured statistic name "&
              pl_args.statMeasParams.statMeasName&
              " in FSMRow#"&int2str(pl_row)&" , cellrow#"&int2str(pl_col)&
              " in FSM table "& pl_fsm.name);
          }
          vl_args[0] := pl_fsm.statMeasXRefs[vl_idx].idxInScope;
          vl_args[1] := pl_fsm.statMeasXRefs[vl_idx].scope
          if(ispresent(pl_args.statMeasParams.paramValue)){
            vl_args[2] := sizeof(pl_fsm.paramValues);
            pl_fsm.paramValues[vl_args[2]] := pl_args.statMeasParams.paramValue 
          }
          pl_destArgs := vl_args;
        }
        case(ischosen(pl_args.statName)){
          //Convert statistic names to their indices
          var integer vl_idx := -1;
          if(not f_EPTF_str2int_HashMap_Find(pl_fsm.statisticNamesHash,
              pl_args.statName,
              vl_idx)){
            f_EPTF_LGenBase_loggingError(%definitionId&": Invalid statistic name "&
              pl_args.statName&
              " in FSMRow#"&int2str(pl_row)&" , cellrow#"&int2str(pl_col)&
              " in FSM table "& pl_fsm.name);
          }
          pl_destArgs := {pl_fsm.statisticXRefs[vl_idx].idxInScope, pl_fsm.statisticXRefs[vl_idx].scope};
        }
        case( ischosen(pl_args.stepContextArgs) ){
          pl_destArgs := 
          pl_args.stepContextArgs;          
        }
        case( ischosen(pl_args.eventToSibling) ){
          //Add the name of the sibling to the list if it does not contain already 
          //and put its idx in the list into the args
          pl_destArgs[c_EPTF_LGenBase_stepArgsIdxEventToSiblingRefFSM] := f_EPTF_LGenBase_addSiblingRef(pl_args.eventToSibling.siblingName, pl_fsm)
          
          if(ispresent(pl_args.eventToSibling.argVarName)){ 
            f_EPTF_LGenBase_commonFunc4EventData(pl_fsm, pl_row, pl_col,
              pl_args.eventToSibling.behaviorName, c_EPTF_LGenBase_stepArgsIdxEventToSiblingBehavior,
              pl_args.eventToSibling.inputName, c_EPTF_LGenBase_stepArgsIdxEventToSiblingInput,
              pl_args.eventToSibling.argVarName, c_EPTF_LGenBase_stepArgsIdxEventToSiblingVarId0,
              pl_destArgs);
          } else {
            f_EPTF_LGenBase_commonFunc4EventData(pl_fsm, pl_row, pl_col, 
              pl_args.eventToSibling.behaviorName, c_EPTF_LGenBase_stepArgsIdxEventToSiblingBehavior,
              pl_args.eventToSibling.inputName, c_EPTF_LGenBase_stepArgsIdxEventToSiblingInput,
              omit, c_EPTF_LGenBase_stepArgsIdxEventToSiblingVarId0,
              pl_destArgs);  
          }  
        }
        case( ischosen(pl_args.replyEvent) ){
          if(ispresent(pl_args.replyEvent.argVarName)){
            f_EPTF_LGenBase_commonFunc4EventData(pl_fsm, pl_row, pl_col, 
              pl_args.replyEvent.behaviorName, c_EPTF_LGenBase_stepArgsIdxReplyEventBehavior,
              pl_args.replyEvent.inputName,c_EPTF_LGenBase_stepArgsIdxReplyEventInput,
              pl_args.replyEvent.argVarName, c_EPTF_LGenBase_stepArgsIdxReplyEventVarId0,
              pl_destArgs);
          } else {
            f_EPTF_LGenBase_commonFunc4EventData(pl_fsm, pl_row, pl_col,
              pl_args.replyEvent.behaviorName, c_EPTF_LGenBase_stepArgsIdxReplyEventBehavior,
              pl_args.replyEvent.inputName, c_EPTF_LGenBase_stepArgsIdxReplyEventInput,
              omit, c_EPTF_LGenBase_stepArgsIdxReplyEventVarId0,
              pl_destArgs);  
          }  
          
        }
        case( ischosen(pl_args.eventToTC) ){
          pl_destArgs[c_EPTF_LGenBase_stepArgsIdxEventToTCRefFSM] := f_EPTF_LGenBase_addSiblingTCRef(pl_args.eventToTC.tcName, pl_fsm);
          if(ispresent(pl_args.eventToTC.argVarName)){
            f_EPTF_LGenBase_commonFunc4EventData(pl_fsm, pl_row, pl_col,
              pl_args.eventToTC.behaviorName, c_EPTF_LGenBase_stepArgsIdxEventToTCBehavior,
              pl_args.eventToTC.inputName, c_EPTF_LGenBase_stepArgsIdxEventToTCInput,
              pl_args.eventToTC.argVarName, c_EPTF_LGenBase_stepArgsIdxEventToTCVarId0,
              pl_destArgs);
          } else {
            f_EPTF_LGenBase_commonFunc4EventData(pl_fsm, pl_row, pl_col, 
              pl_args.eventToTC.behaviorName, c_EPTF_LGenBase_stepArgsIdxEventToTCBehavior,
              pl_args.eventToTC.inputName, c_EPTF_LGenBase_stepArgsIdxEventToTCInput,
              omit, c_EPTF_LGenBase_stepArgsIdxEventToTCVarId0,
              pl_destArgs);  
          }  
          
        }
        case( ischosen(pl_args.eventOfFsmToSibling) ){
          //Add the name of the sibling to the list if it does not contain already 
          //and put its idx in the list into the args
          pl_destArgs[c_EPTF_LGenBase_stepArgsIdxEventOfFsmToSiblingRefFSM] := f_EPTF_LGenBase_addSiblingRef(pl_args.eventOfFsmToSibling.siblingName, pl_fsm)
          
          if(ispresent(pl_args.eventOfFsmToSibling.argVarName)){
            f_EPTF_LGenBase_commonFunc4EventData2(pl_fsm, pl_row, pl_col,
              pl_fsm.name,  //behavior has the same name as the fsm 
              pl_args.eventOfFsmToSibling.inputName, c_EPTF_LGenBase_stepArgsIdxEventOfFsmToSiblingInput,
              pl_args.eventOfFsmToSibling.argVarName, c_EPTF_LGenBase_stepArgsIdxEventOfFsmToSiblingVarId0,
              pl_destArgs);
          } else {
            f_EPTF_LGenBase_commonFunc4EventData2(pl_fsm, pl_row, pl_col, 
              pl_fsm.name,  //behavior has the same name as the fsm
              pl_args.eventOfFsmToSibling.inputName, c_EPTF_LGenBase_stepArgsIdxEventOfFsmToSiblingInput,
              omit, c_EPTF_LGenBase_stepArgsIdxEventOfFsmToSiblingVarId0,
              pl_destArgs);  
          }  
        }
        case( ischosen(pl_args.eventOfFsm) ){
          if(ispresent(pl_args.eventOfFsm.argVarName)){
            f_EPTF_LGenBase_commonFunc4EventData2(pl_fsm, pl_row, pl_col, 
              pl_fsm.name,  //behavior has the same name as the fsm
              pl_args.eventOfFsm.inputName,c_EPTF_LGenBase_stepArgsIdxEventOfFsmInput,
              pl_args.eventOfFsm.argVarName, c_EPTF_LGenBase_stepArgsIdxEventOfFsmVarId0,
              pl_destArgs);
          } else {
            f_EPTF_LGenBase_commonFunc4EventData2(pl_fsm, pl_row, pl_col,
              pl_fsm.name,  //behavior has the same name as the fsm
              pl_args.eventOfFsm.inputName, c_EPTF_LGenBase_stepArgsIdxEventOfFsmInput,
              omit, c_EPTF_LGenBase_stepArgsIdxEventOfFsmVarId0,
              pl_destArgs);  
          }  
          
        }
        //charstringValue
        case( ischosen(pl_args.charstringValue) ){
          pl_destArgs[0] := sizeof(pl_fsm.paramValues);
          pl_fsm.paramValues[pl_destArgs[0]] := {charstringVal := pl_args.charstringValue};
        }
        //verdict
        case( ischosen(pl_args.verdict) ){
          pl_destArgs[0] := sizeof(pl_fsm.verdictList);
          pl_fsm.verdictList[pl_destArgs[0]] := pl_args.verdict.verdict;
          if(ispresent(pl_args.verdict.reason)){
            pl_destArgs[1] := sizeof(pl_fsm.paramValues);
            pl_fsm.paramValues[pl_destArgs[1]] := {charstringVal := pl_args.verdict.reason};
          }else{
            pl_destArgs[1] := -1;
          }
        }
        case else{
          f_EPTF_LGenBase_loggingError(%definitionId&": Invalid contextArgs in row#"&int2str(pl_row)&
            " , cellrow#"&int2str(pl_col)&
            " in FSM table "& pl_fsm.name) 
        }
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_commonFunc4EventData
    // 
    //  Purpose:
    //    Converts the input values to an intlist to pass as stepArgs 
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_commonFunc4EventData(
      in EPTF_LGenBase_InternalFsmTable pl_fsm,
      in integer pl_row,
      in integer pl_col,
      in charstring pl_behaviorName,
      in integer pl_behaviorNameID,
      in charstring pl_inputName,
      in integer pl_inputNameID,
      in template charstring pl_argVarName,
      in integer pl_argVarNameID,
      inout EPTF_IntegerList pl_destArgs
    ) runs on EPTF_LGenBase_Private_CT
    {
      //The sibling idx of the referred FSM will be set in the tc database at the createTc
      pl_destArgs[pl_behaviorNameID] :=
      f_EPTF_LGenBase_behaviorTypeNameIndex(pl_behaviorName)
      if(0 >pl_destArgs[pl_behaviorNameID]){
        f_EPTF_LGenBase_loggingError(%definitionId&": Invalid behavior name \""&
          pl_behaviorName&
          "\" in row#"&int2str(pl_row)&
          " , cellrow#"&int2str(pl_col)&
          " in FSM table "& pl_fsm.name)
      }
      pl_destArgs[pl_inputNameID] :=
      f_EPTF_LGenBase_inputNameIndex(pl_behaviorName, pl_inputName)
      if(0 >pl_destArgs[pl_inputNameID]){
        f_EPTF_LGenBase_loggingError(%definitionId&": Invalid input name \""&
          pl_inputName&
          "\" in row#"&int2str(pl_row)&
          " , cellrow#"&int2str(pl_col)&
          " in FSM table "& pl_fsm.name&
          " in the behavior \""& pl_behaviorName &"\"")
      }
      if(isvalue(pl_argVarName)){
        f_EPTF_LGenBase_varName2IntList(
          valueof(pl_argVarName), 
          pl_fsm, 
          pl_row, 
          pl_col, 
          pl_argVarNameID, 
          pl_destArgs)
      }else{
        pl_destArgs[pl_argVarNameID] := -1
      }
    }
    
    
    private function f_EPTF_LGenBase_commonFunc4EventData2(
      in EPTF_LGenBase_InternalFsmTable pl_fsm,
      in integer pl_row,
      in integer pl_col,
      in charstring pl_behaviorName,
      in charstring pl_inputName,
      in integer pl_inputNameID,
      in template charstring pl_argVarName,
      in integer pl_argVarNameID,
      inout EPTF_IntegerList pl_destArgs
    ) runs on EPTF_LGenBase_Private_CT
    {
      pl_destArgs[pl_inputNameID] :=
      f_EPTF_LGenBase_inputNameIndex(pl_behaviorName, pl_inputName)
      if(0 >pl_destArgs[pl_inputNameID]){
        f_EPTF_LGenBase_loggingError(%definitionId&": Invalid input name \""&
          pl_inputName&
          "\" in row#"&int2str(pl_row)&
          " , cellrow#"&int2str(pl_col)&
          " in FSM table "& pl_fsm.name&
          " in the behavior \""& pl_behaviorName &"\"")
      }
      if(isvalue(pl_argVarName)){
        f_EPTF_LGenBase_varName2IntList(
          valueof(pl_argVarName), 
          pl_fsm, 
          pl_row, 
          pl_col, 
          pl_argVarNameID, 
          pl_destArgs)
      }else{
        pl_destArgs[pl_argVarNameID] := -1
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_createInternalFsmCell
    // 
    //  Purpose:
    //    Converts a cell daclarator to the internal structure
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_createInternalFsmCell(
      in EPTF_LGenBase_FsmTableCellInternal pl_inCell,
      in integer pl_row,
      in integer pl_col,
      inout EPTF_LGenBase_InternalFsmTable pl_fsm,
      out EPTF_LGenBase_FsmTableCell pl_outCell)
    runs on EPTF_LGenBase_Private_CT
    {
      pl_outCell := c_EPTF_LGenBase_emptyFsmTableCell;
      if(ispresent(pl_inCell.actionList)) {
        for (var integer vl_action:=0;vl_action<sizeof(pl_inCell.actionList); vl_action:=vl_action+1){
          
          var integer vl_fnIdx := f_EPTF_LGenBase_functionNameIndex(pl_inCell.actionList[vl_action].stepOrFunctionName);
          if(0 > vl_fnIdx){
            f_EPTF_LGenBase_loggingError(%definitionId&": Invalid step function: "&pl_inCell.actionList[vl_action].stepOrFunctionName&" in FSMRow#"&int2str(pl_row)&" , cellrow#"&int2str(pl_col));
          }
          if(not ischosen(v_LGenBase_functions[vl_fnIdx].testStepFunction)){
            f_EPTF_LGenBase_loggingError(%definitionId&": Invalid step function type: "&pl_inCell.actionList[vl_action].stepOrFunctionName&" in FSMRow#"&int2str(pl_row)&" , cellrow#"&int2str(pl_col));
          }
          pl_outCell.actionList[vl_action].step := v_LGenBase_functions[vl_fnIdx].testStepFunction;
          //Check context argument types
          //In case of timer steps
          select( pl_inCell.actionList[vl_action].stepOrFunctionName )
          {
            case ( c_EPTF_LGenBase_StepFunction_timerStart, c_EPTF_LGenBase_stepName_timerStart )
            {
              if(not ispresent(pl_inCell.actionList[vl_action].contextArgs)){
                f_EPTF_LGenBase_loggingError(%definitionId&": In case of timer start step the contextArgs must be present in FSMRow#"&int2str(pl_row)&" , cellrow#"&int2str(pl_col));
              }
              if(not ischosen(pl_inCell.actionList[vl_action].contextArgs.timerName)){
                f_EPTF_LGenBase_loggingError(%definitionId&": In case of timer start step the contextArgs must be a name of a timer in FSMRow#"&int2str(pl_row)&" , cellrow#"&int2str(pl_col));
              }
            }
            case (c_EPTF_LGenBase_StepFunction_timerCancel, c_EPTF_LGenBase_stepName_timerCancel)
            {
              if(not ispresent(pl_inCell.actionList[vl_action].contextArgs)){
                f_EPTF_LGenBase_loggingError(%definitionId&": In case of timer cancel step the contextArgs must be present in FSMRow#"&int2str(pl_row)&" , cellrow#"&int2str(pl_col));
              }
              if(not ischosen(pl_inCell.actionList[vl_action].contextArgs.timerName)){
                f_EPTF_LGenBase_loggingError(%definitionId&": In case of timer cancel step the contextArgs must be a name of a timer in FSMRow#"&int2str(pl_row)&" , cellrow#"&int2str(pl_col));
              }
            }
          }
          //Process context arguments
          if ( ispresent(pl_inCell.actionList[vl_action].contextArgs) ){
            f_EPTF_LGenBase_stepArgs2IntList(
              pl_inCell.actionList[vl_action].contextArgs,
              pl_fsm,
              pl_row,
              pl_col,
              pl_outCell.actionList[vl_action].stepContextArgs)
            //
          }else{
            pl_outCell.actionList[vl_action].stepContextArgs := {}; 
          }
        }//actionList
      } else {
        pl_outCell.actionList := omit;
      }
      if(ispresent(pl_inCell.nextStateCalculation)){
        var integer vl_fnIdx := f_EPTF_LGenBase_functionNameIndex(pl_inCell.nextStateCalculation.fnName);
        if(0 > vl_fnIdx){
          f_EPTF_LGenBase_loggingError(%definitionId&
            ": Invalid next state calculation function: "&
            pl_inCell.nextStateCalculation.fnName&" in FSMRow#"&int2str(pl_row)&" , cellrow#"&int2str(pl_col)&
            " of FSM table "&pl_fsm.name);
        }
        if(not ischosen(v_LGenBase_functions[vl_fnIdx].nextStateCalcFunction)){
          f_EPTF_LGenBase_loggingError(%definitionId&
            ": Invalid next state calculation function type: "&
            pl_inCell.nextStateCalculation.fnName&
            " in FSMRow#"&int2str(pl_row)&" , cellrow#"&int2str(pl_col)&
            " of FSM table "&pl_fsm.name);
        }
        pl_outCell.nextStateCalculation.fn := v_LGenBase_functions[vl_fnIdx].nextStateCalcFunction;
        f_EPTF_LGenBase_stepArgs2IntList(pl_inCell.nextStateCalculation.args, pl_fsm, pl_row, pl_col, pl_outCell.nextStateCalculation.contextArgs)
      }else{
        pl_outCell.nextStateCalculation := omit;
      }
      if(ispresent(pl_inCell.nextState)){
        var integer vl_nextState := -1;
        if(f_EPTF_str2int_HashMap_Find(pl_fsm.stateNamesHash, pl_inCell.nextState, vl_nextState)){
          pl_outCell.nextState := vl_nextState;
        }else{
          f_EPTF_LGenBase_loggingError(%definitionId&": Declared nextstate must be valid in FSMRow#"&int2str(pl_row)&" , cellrow#"&int2str(pl_col));
        }
      }else{
        pl_outCell.nextState := omit;
      }
    } //f_EPTF_LGenBase_createInternalFsmCell
    
    private function f_EPTF_LGenBase_classicCell2internal(
      in EPTF_LGenBase_FsmTableCellDeclarator pl_cellIn, 
      out EPTF_LGenBase_FsmTableCellInternal pl_cellInternal
    ){
      pl_cellInternal.actionList := pl_cellIn.actionList
      if(ispresent(pl_cellIn.nextState)){
        pl_cellInternal.nextState := pl_cellIn.nextState
      }else{
        pl_cellInternal.nextState := omit
      }
      if(ispresent(pl_cellIn.nextStateCalculation)){
        pl_cellInternal.nextStateCalculation.fnName := pl_cellIn.nextStateCalculation.fnName
        if(ispresent(pl_cellIn.nextStateCalculation.argsList)){
          pl_cellInternal.nextStateCalculation.args.stepContextArgs := pl_cellIn.nextStateCalculation.argsList
        }else{
          pl_cellInternal.nextStateCalculation.args.stepContextArgs := {}
        }
      }else{
        pl_cellInternal.nextStateCalculation := omit
      }
    }
    
    private function f_EPTF_LGenBase_extCell2internal(
      in EPTF_LGenBase_FsmTableCellWithExtNext pl_cellIn, 
      out EPTF_LGenBase_FsmTableCellInternal pl_cellInternal
    ){
      if(ispresent(pl_cellIn.actionList)){
        pl_cellInternal.actionList := pl_cellIn.actionList
      }
      pl_cellInternal.nextStateCalculation.fnName := pl_cellIn.nextStateCalculation.fnName
      pl_cellInternal.nextStateCalculation.args := pl_cellIn.nextStateCalculation.argsList
      pl_cellInternal.nextState := omit
    }
    
    private function f_EPTF_LGenBase_convertParamedFsm2Internal(
      in EPTF_LGenBase_CompactFsmTableDeclarator pl_compactTable,
      out EPTF_LGenBase_FSMInternalDeclarator pl_internal)
    {
      pl_internal.name := pl_compactTable.name
      pl_internal.fsmParams := c_EPTF_LGenBase_emptyFSMParamsInternalDeclarator
      pl_internal.fsmParams.stateList := pl_compactTable.stateList
      f_EPTF_LGenBase_appendTimerList(pl_compactTable.timerList, pl_internal.fsmParams.timerList) 
      pl_internal.table := {}
      var integer vl_event := 0
      do
      {
        pl_internal.table[vl_event].events2Listen.events[0].singleEvent := pl_compactTable.table[vl_event].eventToListen
        for ( var integer vl_state := 0; vl_state < sizeof(pl_compactTable.table[vl_event].cellRow) ; vl_state := vl_state+1 ){
          pl_internal.table[vl_event].actionList[vl_state].inState.state := pl_compactTable.stateList[vl_state]
          f_EPTF_LGenBase_classicCell2internal(pl_compactTable.table[vl_event].cellRow[vl_state],pl_internal.table[vl_event].actionList[vl_state].cell)
        }
        vl_event := vl_event + 1
      } while ( vl_event < sizeof(pl_compactTable.table) )
    }
    
    private function f_EPTF_LGenBase_appendTimerList(
      in EPTF_LGenBase_FsmLocalTimerList pl_timerListIn,
      inout EPTF_LGenBase_FsmTimerInternalList pl_timerListTo){
      var integer vl_count := sizeof(pl_timerListIn)
      if(0 < vl_count){
        var integer vl_currCount := sizeof(pl_timerListTo)
        pl_timerListTo[vl_currCount + vl_count - 1] := c_EPTF_LGenBase_emptyFSMTimerInternal
        for ( var integer vl_i := 0; vl_i < vl_count ; vl_i := vl_i+1 ){
          pl_timerListTo[vl_currCount + vl_i] := c_EPTF_LGenBase_emptyFSMTimerInternal
          pl_timerListTo[vl_currCount + vl_i].name := pl_timerListIn[vl_i].name
          pl_timerListTo[vl_currCount + vl_i].timerParams.static.startValue := pl_timerListIn[vl_i].startValue
        }
      }
    }
    
    private function f_EPTF_LGenBase_appendRandomTimerList(
      in EPTF_LGenBase_FsmRandomTimerList pl_timerListIn,
      inout EPTF_LGenBase_FsmTimerInternalList pl_timerListTo)
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_count := sizeof(pl_timerListIn)
      if(0 < vl_count){
        var integer vl_currCount := sizeof(pl_timerListTo)
        pl_timerListTo[vl_currCount + vl_count - 1] := c_EPTF_LGenBase_emptyFSMTimerInternal;  //prealloc
        for ( var integer vl_i := 0; vl_i < vl_count ; vl_i := vl_i+1 ){
          pl_timerListTo[vl_currCount + vl_i] := c_EPTF_LGenBase_emptyFSMTimerInternal;
          pl_timerListTo[vl_currCount + vl_i].name := pl_timerListIn[vl_i].name;
          pl_timerListTo[vl_currCount + vl_i].timerParams.random.timeoutMin := pl_timerListIn[vl_i].timeoutMin;
          pl_timerListTo[vl_currCount + vl_i].timerParams.random.timeoutMax := pl_timerListIn[vl_i].timeoutMax;
        }
      }
    }
    
    private function f_EPTF_LGenBase_appendParamedTimerList(
      in EPTF_LGenBase_FsmTimerList pl_timerListIn,
      inout EPTF_LGenBase_FsmTimerInternalList pl_timerListTo)
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_count := sizeof(pl_timerListIn)
      if(0 < vl_count){
        var integer vl_currCount := sizeof(pl_timerListTo)
        pl_timerListTo[vl_currCount + vl_count - 1] := c_EPTF_LGenBase_emptyFSMTimerInternal; //prealloc
        
        for ( var integer vl_i := 0; vl_i < vl_count; vl_i := vl_i + 1 ){
          pl_timerListTo[vl_currCount + vl_i] := c_EPTF_LGenBase_emptyFSMTimerInternal;
          
          pl_timerListTo[vl_currCount + vl_i].name := pl_timerListIn[vl_i].name;
          pl_timerListTo[vl_currCount + vl_i].timerParams := pl_timerListIn[vl_i].timerParams;
          
        }
      }
    }
    
    private function f_EPTF_LGenBase_declareEvents(
      in charstring pl_fsmName, 
      in EPTF_LGenBase_declareEvents pl_declareEvents)
    runs on EPTF_LGenBase_Private_CT{
      
      f_EPTF_LGenBase_declareBehaviorType(pl_fsmName, -1, null, null, null)
      
      if (pl_declareEvents.useDefaultEvents){
        for(var integer vl_i := 0; vl_i < sizeof(c_EPTF_LGenBase_DefaultFSMEvents); vl_i := vl_i + 1 ){
          f_EPTF_LGenBase_declareFsmEvent(pl_fsmName,tsp_LGenBase_FSMDefaultEvents[vl_i]);
        }
      }
      
      for(var integer vl_i := 0; vl_i < sizeof(pl_declareEvents.eventList); vl_i := vl_i + 1 ){
        f_EPTF_LGenBase_declareFsmEvent(pl_fsmName,pl_declareEvents.eventList[vl_i]);
      }
      
    }
    
    private function f_EPTF_LGenBase_convertFlexFsmDeclaration2Internal(
      in EPTF_LGenBase_FsmTableDeclarator pl_flexTable,
      out EPTF_LGenBase_FSMInternalDeclarator pl_internal)
    runs on EPTF_LGenBase_Private_CT{
      pl_internal := c_EPTF_LGenBase_emptyFSMInternalDeclarator;
      pl_internal.name := pl_flexTable.name
      pl_internal.fsmParams := c_EPTF_LGenBase_emptyFSMParamsInternalDeclarator
      //process FSM params
      for ( var integer vl_param := 0; vl_param < sizeof(pl_flexTable.fsmParams) ; vl_param := vl_param+1 ){
        select( true ){
          case ( ischosen(pl_flexTable.fsmParams[vl_param].stateList) ){
            pl_internal.fsmParams.stateList := pl_internal.fsmParams.stateList & pl_flexTable.fsmParams[vl_param].stateList
          }
          case ( ischosen(pl_flexTable.fsmParams[vl_param].timerList) ){
            f_EPTF_LGenBase_appendTimerList(pl_flexTable.fsmParams[vl_param].timerList, pl_internal.fsmParams.timerList)
          }
          case ( ischosen(pl_flexTable.fsmParams[vl_param].randomTimerList) ){
            f_EPTF_LGenBase_appendRandomTimerList(pl_flexTable.fsmParams[vl_param].randomTimerList, pl_internal.fsmParams.timerList)
          }
          case ( ischosen(pl_flexTable.fsmParams[vl_param].fsmTimerList) ){
            f_EPTF_LGenBase_appendParamedTimerList(pl_flexTable.fsmParams[vl_param].fsmTimerList, pl_internal.fsmParams.timerList)
          }
          case ( ischosen(pl_flexTable.fsmParams[vl_param].statMeasStatList) ){
            f_EPTF_LGenBase_convertStatMeasStatList2StatMeasWithParamsList(
              pl_flexTable.fsmParams[vl_param].statMeasStatList,
              pl_internal.fsmParams.statMeasWithParamsList)
          }
          case ( ischosen(pl_flexTable.fsmParams[vl_param].statMeasWithParamsList) ){
            pl_internal.fsmParams.statMeasWithParamsList := 
            pl_internal.fsmParams.statMeasWithParamsList & pl_flexTable.fsmParams[vl_param].statMeasWithParamsList
          }
          case ( ischosen(pl_flexTable.fsmParams[vl_param].statisticList) ){
            f_EPTF_LGenBase_convertStatList2StatHandlerList(
              pl_flexTable.fsmParams[vl_param].statisticList,
              pl_internal.fsmParams.statHandlerStatList) 
          }
          case ( ischosen(pl_flexTable.fsmParams[vl_param].statHandlerStatList) ){
            pl_internal.fsmParams.statHandlerStatList := 
            pl_internal.fsmParams.statHandlerStatList & pl_flexTable.fsmParams[vl_param].statHandlerStatList
          }
          case ( ischosen(pl_flexTable.fsmParams[vl_param].varList) ){
            pl_internal.fsmParams.varList := pl_internal.fsmParams.varList & pl_flexTable.fsmParams[vl_param].varList
          }
          case ( ischosen(pl_flexTable.fsmParams[vl_param].declareEvents) ){
            f_EPTF_LGenBase_declareEvents(pl_flexTable.name, pl_flexTable.fsmParams[vl_param].declareEvents);
          }
          case else{
            f_EPTF_LGenBase_loggingError(%definitionId&": Unknown FSM parameter type " &
              log2str(pl_flexTable.fsmParams[vl_param]));
          }
        }
        
      }
      //Process table
      select( true ){
        case ( ischosen(pl_flexTable.table.classicTable) ){
          for ( var integer vl_event := 0; vl_event < sizeof(pl_flexTable.table.classicTable) ; vl_event := vl_event+1 ){
            pl_internal.table[vl_event].events2Listen.events[0].singleEvent := pl_flexTable.table.classicTable[vl_event].eventToListen
            for ( var integer vl_state := 0; vl_state < sizeof(pl_internal.fsmParams.stateList) ; vl_state := vl_state+1 ){
              if(sizeof(pl_internal.fsmParams.stateList)!=sizeof(pl_flexTable.table.classicTable[vl_event].cellRow)){
                f_EPTF_LGenBase_loggingError("The size of the state list must equal with the size of list of actions in FSM table"&
                  pl_flexTable.name&" row#"&int2str(vl_event)&" reflecting to "&log2str(pl_flexTable.table.classicTable[vl_event].eventToListen))
              }
              pl_internal.table[vl_event].actionList[vl_state].inState.state := pl_internal.fsmParams.stateList[vl_state]
              f_EPTF_LGenBase_classicCell2internal(
                pl_flexTable.table.classicTable[vl_event].cellRow[vl_state],
                pl_internal.table[vl_event].actionList[vl_state].cell)
            }
          }
        }
        case ( ischosen(pl_flexTable.table.extendedTable) ){
          for ( var integer vl_event := 0; vl_event < sizeof(pl_flexTable.table.extendedTable) ; vl_event := vl_event+1 ){
            pl_internal.table[vl_event].events2Listen := pl_flexTable.table.extendedTable[vl_event].events2Listen
            select( true ){
              case ( ischosen(pl_flexTable.table.extendedTable[vl_event].cellRow.classicCellRow) ){
                if(sizeof(pl_internal.fsmParams.stateList)!=sizeof(pl_flexTable.table.extendedTable[vl_event].cellRow.classicCellRow)){
                  f_EPTF_LGenBase_loggingError("The size of the state list must equal with the size of list of actions in FSM table"&
                    pl_flexTable.name&" row#"&int2str(vl_event)&" reflecting to "&log2str(pl_flexTable.table.extendedTable[vl_event].events2Listen))
                }
                for ( var integer vl_state := 0; vl_state < sizeof(pl_internal.fsmParams.stateList) ; vl_state := vl_state+1 ){
                  pl_internal.table[vl_event].actionList[vl_state].inState.state := pl_internal.fsmParams.stateList[vl_state]
                  f_EPTF_LGenBase_classicCell2internal(
                    pl_flexTable.table.extendedTable[vl_event].cellRow.classicCellRow[vl_state],
                    pl_internal.table[vl_event].actionList[vl_state].cell)
                }
              }
              case ( ischosen(pl_flexTable.table.extendedTable[vl_event].cellRow.statedCellRow) ){
                for ( var integer vl_state := 0; vl_state < sizeof(pl_flexTable.table.extendedTable[vl_event].cellRow.statedCellRow) ; vl_state := vl_state+1 ){
                  pl_internal.table[vl_event].actionList[vl_state].inState := pl_flexTable.table.extendedTable[vl_event].cellRow.statedCellRow[vl_state].inState
                  f_EPTF_LGenBase_classicCell2internal(
                    pl_flexTable.table.extendedTable[vl_event].cellRow.statedCellRow[vl_state].cell,
                    pl_internal.table[vl_event].actionList[vl_state].cell)
                }
              }
              case ( ischosen(pl_flexTable.table.extendedTable[vl_event].cellRow.extStatedCellRow) ){
                for ( var integer vl_state := 0; vl_state < sizeof(pl_flexTable.table.extendedTable[vl_event].cellRow.extStatedCellRow) ; vl_state := vl_state+1 ){
                  pl_internal.table[vl_event].actionList[vl_state].inState := pl_flexTable.table.extendedTable[vl_event].cellRow.extStatedCellRow[vl_state].inState
                  f_EPTF_LGenBase_extCell2internal(
                    pl_flexTable.table.extendedTable[vl_event].cellRow.extStatedCellRow[vl_state].cell,
                    pl_internal.table[vl_event].actionList[vl_state].cell)
                }
              }
              case else{
                f_EPTF_LGenBase_loggingError(%definitionId&": Unknown FSM actionlist type " &
                  log2str(pl_flexTable.table.extendedTable[vl_event].cellRow));
              }
            }
          }
        }
        case else{
          f_EPTF_LGenBase_loggingError(%definitionId&": Unknown FSM table declaration: " &
            log2str(pl_flexTable.table));
        }
      }
    }
    
    private function f_EPTF_LGenBase_convertStatMeasStatList2StatMeasWithParamsList(
      in EPTF_LGenBase_FsmStatMeasDeclaratorList pl_statMeasList,
      inout EPTF_LGenBase_FsmStatMeasWithParamsDeclaratorList pl_statMeasWithParamsList)
    {
      var integer vl_count := sizeof(pl_statMeasWithParamsList)
      for ( var integer vl_stat := vl_count; vl_stat < sizeof(pl_statMeasList)+vl_count ; vl_stat := vl_stat+1 )
      {
        pl_statMeasWithParamsList[vl_stat] := c_EPTF_LGenBase_emptyFsmStatMeasWithParamsDeclarator
        pl_statMeasWithParamsList[vl_stat].name := pl_statMeasList[vl_stat].name
        pl_statMeasWithParamsList[vl_stat].statMeasParams.statType := pl_statMeasList[vl_stat].statType
        pl_statMeasWithParamsList[vl_stat].providerVarName := pl_statMeasList[vl_stat].varName
        pl_statMeasWithParamsList[vl_stat].scope := pl_statMeasList[vl_stat].scope
      }
    }
    
    private function f_EPTF_LGenBase_convertStatList2StatHandlerList(
      in EPTF_LGenBase_FsmStatDeclaratorList pl_stats,
      inout EPTF_LGenBase_FsmStatHandlerDeclaratorList pl_statHandlerList)
    {
      var integer vl_count := sizeof(pl_statHandlerList)
      for ( var integer vl_stat := vl_count; vl_stat < sizeof(pl_stats)+vl_count ; vl_stat := vl_stat+1 ){
        pl_statHandlerList[vl_stat].name := pl_stats[vl_stat].name
        for ( var integer vl_varList := 0; vl_varList < sizeof(pl_stats[vl_stat].providersList) ; vl_varList := vl_varList+1 ){
          pl_statHandlerList[vl_stat].providers[0].varList := pl_stats[vl_stat].providersList[vl_varList]
          pl_statHandlerList[vl_stat].statMethod := pl_stats[vl_stat].statMethod
          pl_statHandlerList[vl_stat].statResetValue := pl_stats[vl_stat].statResetValue
          pl_statHandlerList[vl_stat].scope := pl_stats[vl_stat].scope
        }
      }
    }
    
    
    private function f_EPTF_LGenBase_declareFSMTableFromInternal(in EPTF_LGenBase_FSMInternalDeclarator pl_fsmDecl)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      if(-1 < f_EPTF_LGenBase_fsmNameIndex(pl_fsmDecl.name)){
        f_EPTF_LGenBase_loggingError("The FSM with name "&pl_fsmDecl.name&" is already declared.")
        return -1
      }else{
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
          f_EPTF_LGenBase_loggingDebugConfig(%definitionId&": The FSM table declaration is:"&log2str(pl_fsmDecl)) 
        }
        var integer vl_newTableId := sizeof(v_LGenBase_fsmTables);
        var EPTF_LGenBase_InternalFsmTable vl_newTable := c_EPTF_LGenBase_emptyInternalFsmTable;
        vl_newTable.name := pl_fsmDecl.name;
        for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_fsmDebugLightList) and not vl_newTable.debugLight ; vl_i := vl_i+1 ){
          if(vl_newTable.name == v_LGenBase_fsmDebugLightList[vl_i]){
            vl_newTable.debugLight := true
          }
        }
        f_EPTF_LGenBase_createFSMHashMaps(pl_fsmDecl.name,vl_newTable)
        if(0 < sizeof(pl_fsmDecl.fsmParams.stateList)){
          f_EPTF_LGenBase_processStateDeclarations(pl_fsmDecl.fsmParams.stateList, vl_newTable.stateNamesHash, vl_newTable);
        }else{
          f_EPTF_LGenBase_loggingError(%definitionId&": The state list of FSM table "&
            vl_newTable.name&
            " is undefined.");
        }
        if(0 < sizeof(pl_fsmDecl.fsmParams.timerList)){
          f_EPTF_LGenBase_processTimerDeclarations(pl_fsmDecl.fsmParams.timerList, vl_newTable.timerNamesHash, vl_newTable);
        }
        if(0 < sizeof(pl_fsmDecl.fsmParams.varList)){
          f_EPTF_LGenBase_processVariableDeclarations(pl_fsmDecl.fsmParams.varList, vl_newTable.varNamesHash, vl_newTable);
        }
        if(0 < sizeof(pl_fsmDecl.fsmParams.statMeasWithParamsList)){
          f_EPTF_LGenBase_processStatMeasDeclarationsWithParams(pl_fsmDecl.fsmParams.statMeasWithParamsList, vl_newTable);
        }
        if(0 < sizeof(pl_fsmDecl.fsmParams.statHandlerStatList)){
          f_EPTF_LGenBase_processStatHandlerDeclarations(pl_fsmDecl.fsmParams.statHandlerStatList, vl_newTable);
        }
        f_EPTF_LGenBase_processInternalTable(pl_fsmDecl, vl_newTable)
        v_LGenBase_fsmTables[vl_newTableId] := vl_newTable;
        v_LGenBase_temporaryHashMaps := {}
        f_EPTF_LGenBase_fillEventsHasmaps(vl_newTableId,vl_newTable.eventXref,-1,-1);
        return vl_newTableId;
      }
    }//f_EPTF_LGenBase_declareFSMTableFromInternal
    
    private function f_EPTF_LGenBase_createStateColIdxList(
      in EPTF_LGenBase_FSMInternalDeclarator pl_fsmDecl,
      in EPTF_LGenBase_InternalFsmTable pl_newTable,
      in integer pl_row,
      out EPTF_IntegerList pl_stateColIdxList)
    runs on EPTF_LGenBase_Private_CT{
      pl_stateColIdxList[sizeof(pl_fsmDecl.fsmParams.stateList)-1] := -1 //just 4 malloc
      //Clean up index list
      for ( var integer vl_i := 0; vl_i < sizeof(pl_newTable.stateList) ; vl_i := vl_i+1 ){
        pl_stateColIdxList[vl_i] := -1
      }
      var integer vl_undefinedStateCol := -1
      for (var integer vl_col:=0; vl_col<sizeof(pl_fsmDecl.table[pl_row].actionList); vl_col:=vl_col+1) {
        if(ischosen(pl_fsmDecl.table[pl_row].actionList[vl_col].inState.anyUndefinedState)){
          if(-1 < vl_undefinedStateCol){
            f_EPTF_LGenBase_loggingError(%definitionId&": The actions to be executed in any undefined state of FSM table "&
              pl_newTable.name&
              " of row#"&int2str(pl_row)&
              " is already defined in column#"&int2str(vl_undefinedStateCol)&
              " and in column#"&int2str(vl_col)& " again.");
          }else{
            vl_undefinedStateCol := vl_col
          }
        }else{
          select( true ){
            case ( ischosen(pl_fsmDecl.table[pl_row].actionList[vl_col].inState.state) ){
              f_EPTF_LGenBase_setStateColIdx(
                pl_newTable.stateNamesHash,
                pl_fsmDecl.table[pl_row].actionList[vl_col].inState.state,
                pl_stateColIdxList, 
                pl_row, vl_col, pl_newTable.name)
            }
            case ( ischosen(pl_fsmDecl.table[pl_row].actionList[vl_col].inState.stateList) ){
              for ( var integer vl_i := 0; vl_i < sizeof(pl_fsmDecl.table[pl_row].actionList[vl_col].inState.stateList) ; vl_i := vl_i+1 ){
                f_EPTF_LGenBase_setStateColIdx(
                  pl_newTable.stateNamesHash,
                  pl_fsmDecl.table[pl_row].actionList[vl_col].inState.stateList[vl_i],
                  pl_stateColIdxList, 
                  pl_row, vl_col, pl_newTable.name)
              }
            }
            case else{
              f_EPTF_Base_assert(%definitionId&": Unknown FSM action state declaration type: " &
                log2str(pl_fsmDecl.table[pl_row].actionList[vl_col].inState),
                false);
            }
          }
        }
      }
      if(-1 < vl_undefinedStateCol){
        for ( var integer vl_state := 0; vl_state < sizeof(pl_fsmDecl.fsmParams.stateList) ; vl_state := vl_state+1 ){
          if(not isbound(pl_stateColIdxList[vl_state]) or -1 == pl_stateColIdxList[vl_state]){
            pl_stateColIdxList[vl_state] := vl_undefinedStateCol
          }
        }
      }
    }
    
    private function f_EPTF_LGenBase_setStateColIdx(
      in integer pl_stateNamesHashmap,
      in charstring pl_stateName,
      inout EPTF_IntegerList pl_stateColIdxList,
      in integer pl_row,
      in integer pl_col,
      in charstring pl_fsmName)
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_stateIdx := -1
      if(not f_EPTF_str2int_HashMap_Find(pl_stateNamesHashmap,
          pl_stateName,
          vl_stateIdx)){
        f_EPTF_LGenBase_loggingError(%definitionId&": Invalid state name "&
          pl_stateName&
          " in FSMRow#"&int2str(pl_row)&" , column#"&int2str(pl_col)&
          " in FSM table "& pl_fsmName);
      }
      if(-1 < pl_stateColIdxList[vl_stateIdx]){
        f_EPTF_LGenBase_loggingError(%definitionId&
          ": The actions in state "&
          pl_stateName&
          " in FSMRow#"&int2str(pl_row)&" , column#"&int2str(pl_col)&
          " in FSM table "& pl_fsmName&
          " is already defined in column#"&
          int2str(pl_stateColIdxList[vl_stateIdx]));
      }
      pl_stateColIdxList[vl_stateIdx] := pl_col
    }
    
    //Process table
    private function f_EPTF_LGenBase_processInternalTable(
      in EPTF_LGenBase_FSMInternalDeclarator pl_fsmDecl,
      inout EPTF_LGenBase_InternalFsmTable pl_fsm)
    runs on EPTF_LGenBase_Private_CT
    {
      for (var integer vl_row:=0; vl_row < sizeof(pl_fsmDecl.table); vl_row := vl_row+1) {
        //Build up state column index list 4 the row
        f_EPTF_LGenBase_createStateColIdxList(
          pl_fsmDecl, 
          pl_fsm,
          vl_row,
          pl_fsm.rows[vl_row].colIdxListByStates)
        //Create the cell list
        for (var integer vl_col:=0; vl_col<sizeof(pl_fsmDecl.table[vl_row].actionList); vl_col:=vl_col+1) {
          f_EPTF_LGenBase_createInternalFsmCell(
            pl_fsmDecl.table[vl_row].actionList[vl_col].cell,
            vl_row,
            vl_col,
            pl_fsm,
            pl_fsm.rows[vl_row].cellList[vl_col])
        }//columns
        
        //Set the event index list
        select(true){
          case ( ischosen(pl_fsmDecl.table[vl_row].events2Listen.events)){
            // 1. create list of events to listen
            f_EPTF_LGenBase_appendEventList(
              pl_fsmDecl.table[vl_row].events2Listen.events,
              pl_fsm,
              vl_row,
              pl_fsm.eventXref);
          }
          case ( ischosen(pl_fsmDecl.table[vl_row].events2Listen.catchAll)){
            pl_fsm.catchAllRowIdxList[sizeof(pl_fsm.catchAllRowIdxList)] := vl_row
          }
          case ( ischosen(pl_fsmDecl.table[vl_row].events2Listen.unhandled)){
            pl_fsm.unhandledEventRowIdxList[sizeof(pl_fsm.unhandledEventRowIdxList)] := vl_row
          }
          case ( ischosen(pl_fsmDecl.table[vl_row].events2Listen.siblingEvents)){
            var integer vl_size := sizeof(pl_fsm.siblingListenerRowList);
            pl_fsm.siblingListenerRowList[vl_size].row := vl_row;
            pl_fsm.siblingListenerRowList[vl_size].eventsFromSibling := pl_fsmDecl.table[vl_row].events2Listen.siblingEvents;
          }
          case else{
            f_EPTF_LGenBase_loggingError(%definitionId&
              ": Invalid Events2ListenDeclarator type: "&
              log2str( pl_fsmDecl.table[vl_row].events2Listen )&
              " in FSM "&pl_fsmDecl.name);
          }  
        }
      }//rows
    }
    
    friend function f_EPTF_LGenBase_addSiblingRef(
      in charstring pl_siblingName,
      inout EPTF_LGenBase_InternalFsmTable pl_fsm)
    runs on EPTF_LGenBase_Private_CT return integer {
      var integer vl_size := sizeof(pl_fsm.referredFsmList);
      for ( var integer i := 0; i < vl_size; i := i+1 )
      {
        if(pl_fsm.referredFsmList[i] == pl_siblingName){
          return i; // already added
        }
      }
      pl_fsm.referredFsmList[vl_size] := pl_siblingName;  // not found
      return vl_size;
      
    }
    
    private function f_EPTF_LGenBase_addSiblingTCRef(
      in charstring pl_siblingTCName,
      inout EPTF_LGenBase_InternalFsmTable pl_fsm)
    runs on EPTF_LGenBase_Private_CT return integer {
      var integer vl_size := sizeof(pl_fsm.referredTCList);
      for ( var integer i := 0; i < vl_size; i := i+1 )
      {
        if(pl_fsm.referredTCList[i] == pl_siblingTCName){
          return i; // already added
        }
      }
      pl_fsm.referredTCList[vl_size] := pl_siblingTCName;  // not found
      return vl_size;
      
    }
    
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_convertTcMgmtEntityFinishConditions2Internal
    // 
    //  Purpose:
    //    Converts the obsolete entity finish conditions to the internal structure
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_convertTcMgmtEntityFinishConditions2Internal(
      in EPTF_LGenBase_TcMgmt_EntityFinishConditions pl_conditions,
      out EPTF_LGenBase_EntityFinishConditionsInternalDeclarator pl_internal)
    runs on EPTF_Base_CT{
      pl_internal := c_EPTF_LGenBase_emptyEntityFinishConditionsInternalDeclarator
      pl_internal.nrOfExecStart := pl_conditions.nrOfExecStart
      pl_internal.nrOfFails := pl_conditions.nrOfFails
      pl_internal.nrOfSuccesses := pl_conditions.nrOfSuccesses
      if(ispresent(pl_conditions.customFinishCondition)){
        pl_internal.customFinishCondition := pl_conditions.customFinishCondition
      }    
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_convertTcMgmtGroupFinishConditions2Internal
    // 
    //  Purpose:
    //    Converts the obsolete group finish conditions to the internal structure
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_convertTcMgmtGroupFinishConditions2Internal(
      in EPTF_LGenBase_TcMgmt_GroupFinishConditions pl_conditions,
      in EPTF_LGenBase_TcMgmt_GroupActionsList pl_actions,
      out EPTF_LGenBase_TrafficStartFinishConditionsInternalDeclarator pl_decl){
      pl_decl := c_EPTF_LGenBase_emptyTrafficStartFinishConditionsInternalDeclarator;
      if(ispresent(pl_conditions.execTime)){
        pl_decl.execTime := {pl_conditions.execTime,{}}
      }
      if(ispresent(pl_conditions.nrOfExecStart)){
        pl_decl.nrOfExecStart := {pl_conditions.nrOfExecStart,{}}
      }
      if(ispresent(pl_conditions.nrOfFails)){
        pl_decl.nrOfFails := {pl_conditions.nrOfFails,{}}
      }
      if(ispresent(pl_conditions.nrOfRangeLoop)){
        pl_decl.nrOfRangeLoop := {pl_conditions.nrOfRangeLoop,{}}
      }
      if(ispresent(pl_conditions.nrOfSuccesses)){
        pl_decl.nrOfSuccesses := {pl_conditions.nrOfSuccesses,{}}
      }
      if(ispresent(pl_conditions.customFinishCondition)){
        pl_decl.customFinish := {pl_conditions.customFinishCondition,{}}
      }
      if(ispresent(pl_conditions.nrOfGrpLoop)){
        f_EPTF_Common_warning(%definitionId&" The group loop condition is not implemented.")
      }
      pl_decl.anythingFinished.actions := pl_actions;
    }
    
  } // group processR3Declarators
  
  private function f_EPTF_LGenBase_createFSMHashMaps(
    in charstring pl_name,
    inout EPTF_LGenBase_InternalFsmTable pl_fsm,
    in boolean pl_createTempList := true)
  runs on EPTF_LGenBase_Private_CT{
    var charstring vl_stateHashName := c_EPTF_LGenBase_stateNamesHashMapPrefix&pl_name;
    var charstring vl_statisticHashName := c_EPTF_LGenBase_statisticsNamesHashMapPrefix&pl_name;
    var charstring vl_statMeasHashName := c_EPTF_LGenBase_statMeasNamesHashMapPrefix&pl_name;
    var charstring vl_varHashName := c_EPTF_LGenBase_varNamesHashMapPrefix&pl_name;
    var charstring vl_timerHashName := c_EPTF_LGenBase_timerNamesHashMapPrefix&pl_name;
    pl_fsm.varNamesHash := f_EPTF_str2int_HashMap_New(vl_varHashName);
    pl_fsm.stateNamesHash := f_EPTF_str2int_HashMap_New(vl_stateHashName);
    pl_fsm.statisticNamesHash := f_EPTF_str2int_HashMap_New(vl_statisticHashName);
    pl_fsm.statMeasNamesHash := f_EPTF_str2int_HashMap_New(vl_statMeasHashName);
    pl_fsm.timerNamesHash := f_EPTF_str2int_HashMap_New(vl_timerHashName);
    if(pl_createTempList){
      v_LGenBase_temporaryHashMaps := {vl_varHashName,vl_stateHashName,vl_statisticHashName,vl_statMeasHashName,vl_timerHashName}
    }
  }
}//PrivateFunctions

///////////////////////////////////////////////////////////
// Group: obsolete
//
// Purpose:
//   Obsolete traffic case and scenario declaration functions and obsolete declartor converter functions.
//
///////////////////////////////////////////////////////////
group obsolete{
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_TcMgmt_declareScenarios
  // 
  //  Purpose:
  //    This is a TitanSim R2 scenario declaration function.
  //    Registers a list of scenarios. Calls the <f_EPTF_LGenBase_declareScenarioType2>.
  //    See also:<EPTF_LGenBase_TcMgmt_ScenarioDeclaratorList>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_TcMgmt_declareScenarios(in  EPTF_LGenBase_TcMgmt_ScenarioDeclaratorList pl_scTypeList) 
  runs on EPTF_LGenBase_Private_CT
  return EPTF_IntegerList{
    var EPTF_IntegerList vl_ret := {};
    for ( var integer vl_i := 0; vl_i < sizeof(pl_scTypeList) ; vl_i := vl_i+1 )
    {
      vl_ret[vl_i] := f_EPTF_LGenBase_declareScenarioType2(pl_scTypeList[vl_i]);
    }
    return vl_ret;
  }//f_EPTF_LGenBase_TcMgmt_declareScenarios
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_TcMgmt_declareTrafficCases
  // 
  //  Purpose:
  //    Registers a list of traffic case types. Calls the <f_EPTF_LGenBase_declareTcType2>.
  //    See also:<EPTF_LGenBase_TcMgmt_tcTypeDeclaratorList>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_TcMgmt_declareTrafficCases(in  EPTF_LGenBase_TcMgmt_tcTypeDeclaratorList pl_tcTypeList) 
  runs on EPTF_LGenBase_Private_CT
  return EPTF_IntegerList{
    var EPTF_IntegerList vl_ret := {};
    for ( var integer vl_i := 0; vl_i < sizeof(pl_tcTypeList) ; vl_i := vl_i+1 )
    {
      vl_ret[vl_i] := f_EPTF_LGenBase_declareTcType2(pl_tcTypeList[vl_i]);
    }
    return vl_ret;
  }//f_EPTF_LGenBase_TcMgmt_declareTrafficCases
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareTcType2
  // 
  //  Purpose:
  //    Declares a traffic case type. This is an obsolete R2 traffic case declaration function.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_declareTcType2(
    in EPTF_LGenBase_TcMgmt_tcTypeDeclarator2 pl_tc
  )
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var EPTF_LGenBase_TcTypeDescriptor vl_tcType;
    var EPTF_LGenBase_TrafficCaseTypeInternalDeclarator vl_internal;
    f_EPTF_LGenBase_convertTcTypeDeclarator22Internal(pl_tc, vl_internal)
    return f_EPTF_LGenBase_declareTrafficCaseTypeInternal(vl_internal)
  }//f_EPTF_LGenBase_declareTcType2
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_converttcTypeDeclarator2Internal
  // 
  //  Purpose:
  //    Processes an <EPTF_LGenBase_tcTypeDeclarator> and
  //    converts it to an internal <EPTF_LGenBase_TrafficCaseTypeInternalDeclarator>
  //   This is an obsolete R2 data structure converter function.   
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_converttcTypeDeclarator2Internal(
    in EPTF_LGenBase_tcTypeDeclarator pl_source,
    out EPTF_LGenBase_TrafficCaseTypeInternalDeclarator pl_decl)
  runs on EPTF_Base_CT{
    pl_decl := c_EPTF_LGenBase_emptyTrafficCaseTypeInternalDeclarator
    pl_decl.name := pl_source.name;
    pl_decl.fsmName := pl_source.fsmName;
    pl_decl.entityType := pl_source.entityType;
    pl_decl.params := pl_source.params;
    pl_decl.customEntitySuccPrev := pl_source.customEntitySucc
    pl_decl.entityFinishActions := pl_source.entityFinishActions
    f_EPTF_LGenBase_convertTcMgmtEntityFinishConditions2Internal(
      pl_source.entityFinishConditions,
      pl_decl.entityFinishConditions)
    f_EPTF_LGenBase_convertTcMgmtGroupFinishConditions2Internal(
      pl_source.groupFinishConditions,
      pl_source.groupFinishActions,
      pl_decl.trafficStartFinishConditionsAndFunctions)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_convertTcTypeDeclarator22Internal
  // 
  //  Purpose:
  //   Converts <EPTF_LGenBase_TcMgmt_tcTypeDeclarator2> data structure into the internal data structure.
  //   This data structure declares a traffic case type.  
  //   This is an obsolete R2 data structure converter function. 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_convertTcTypeDeclarator22Internal(
    in EPTF_LGenBase_TcMgmt_tcTypeDeclarator2 pl_tc,
    out EPTF_LGenBase_TrafficCaseTypeInternalDeclarator pl_internal){
    pl_internal := c_EPTF_LGenBase_emptyTrafficCaseTypeInternalDeclarator
    pl_internal.name := pl_tc.name
    pl_internal.fsmName := pl_tc.fsmName
    pl_internal.entityType := pl_tc.entityType
    pl_internal.customEntitySucc := pl_tc.customEntitySucc
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareScenarioType2
  // 
  //  Purpose:
  //    Creates a (non-weighted) scenario. This is an obsolete R2 scenario declaration function.
  // 
  //  Detailed Comments:
  //    This is a TitanSim R2 scenario declaration function. It registers one scenario.   
  //    A scenario is a collection of traffic cases. See <f_EPTF_LGenBase_validateScenarioType>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_declareScenarioType2(in EPTF_LGenBase_TcMgmt_ScenarioDeclarator2 pl_scenario)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var EPTF_LGenBase_ScenarioTypeInternalDeclarator vl_scTypeInternal;
    f_EPTF_LGenBase_convertTcMgmtScenarioDeclarator22Internal(pl_scenario, vl_scTypeInternal)
    return f_EPTF_LGenBase_declareScenarioTypeInternal(vl_scTypeInternal);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_convertTcMgmtScenarioDeclarator22Internal
  // 
  //  Purpose:
  //   Converts <EPTF_LGenBase_TcMgmt_ScenarioDeclarator2> scenario data structure into the internal data structure.
  //   This is an obsolete R2 data structure converter function.
  ///////////////////////////////////////////////////////////  
  public function f_EPTF_LGenBase_convertTcMgmtScenarioDeclarator22Internal(
    in EPTF_LGenBase_TcMgmt_ScenarioDeclarator2 pl_source,
    out EPTF_LGenBase_ScenarioTypeInternalDeclarator pl_scTypeInternal)
  runs on EPTF_Base_CT{
    pl_scTypeInternal:= c_EPTF_LGenBase_emptyScenarioTypeInternalDeclarator;
    pl_scTypeInternal.name := pl_source.name;
    var integer vl_tcMax := sizeof(pl_source.tcList);
    for(var integer vl_i := 0; vl_i < vl_tcMax; vl_i := vl_i + 1){
      //f_EPTF_LGenBase_loggingDebugConfig(log2str(vl_sc.tcList[vl_i]))
      //f_EPTF_LGenBase_loggingDebugConfig(log2str(pl_scenario.tcList[vl_i]))
      pl_scTypeInternal.tcList[vl_i].enable := false //Placeholder only to create the object
      f_EPTF_LGenBase_convertTcMgmtTcOfScenario22Internal(pl_source.tcList[vl_i], pl_scTypeInternal.tcList[vl_i])
    }
  }//f_EPTF_LGenBase_declareScenarioType2    
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_convertTcMgmtTcOfScenario22Internal
  // 
  //  Purpose:
  //   Converts <EPTF_LGenBase_TcMgmt_TcOfScenario2> data structure into the internal data structure.
  //   This data structure declares a traffic case of a non-weighted scenario.  
  //   This is an obsolete R2 data structure converter function. 
  ///////////////////////////////////////////////////////////  
  public function f_EPTF_LGenBase_convertTcMgmtTcOfScenario22Internal(
    in EPTF_LGenBase_TcMgmt_TcOfScenario2 pl_sourceTC,
    out EPTF_LGenBase_TcOfScenarioInternalDeclarator pl_internal)
  runs on EPTF_Base_CT{
    pl_internal := c_EPTF_LGenBase_emptyTcOfScenarioInternalDeclarator;
    pl_internal.tcPrivateName := pl_sourceTC.tcName;
    pl_internal.tcTypeName := pl_sourceTC.tcName;
    pl_internal.enableEntities := pl_sourceTC.enableEntities;
    pl_internal.enable := pl_sourceTC.enable;
    if(ispresent(pl_sourceTC.entityFinishActions)){
      pl_internal.entityFinishActions := pl_sourceTC.entityFinishActions;
    }
    if(ispresent(pl_sourceTC.ranges)){
      pl_internal.ranges := pl_sourceTC.ranges;
    }
    if(ispresent(pl_sourceTC.params)){
      pl_internal.params := pl_sourceTC.params;
    }       
    if(ispresent(pl_sourceTC.entityFinishConditions)){
      f_EPTF_LGenBase_convertTcMgmtEntityFinishConditions2Internal(
        pl_sourceTC.entityFinishConditions, 
        pl_internal.entityFinishConditions)
    }
    var EPTF_LGenBase_TcMgmt_GroupFinishConditions2 vl_gfc := c_EPTF_LGenBase_TcMgmt_emptyGroupFinishConditions2
    var EPTF_LGenBase_TcMgmt_GroupActions2List vl_ga := {};     
    if(ispresent(pl_sourceTC.groupFinishConditions)){
      vl_gfc := pl_sourceTC.groupFinishConditions
    }
    if(ispresent(pl_sourceTC.tcFinishActions)){
      vl_ga := pl_sourceTC.tcFinishActions
    }
    f_EPTF_LGenBase_convertTcMgmtGroupFinishConditions22Internal(
      vl_gfc,
      vl_ga,
      pl_internal.trafficStartFinishConditionsAndActions,
      pl_internal.trafficFinishedActions)
    
    if(ispresent(pl_sourceTC.startDelay)){
      pl_internal.startDelay := pl_sourceTC.startDelay
    }
    pl_internal.target.cpsToReach := pl_sourceTC.cpsToReach;
    /*
    //Obsolete structures 4 ExecCtrl
    if(ispresent(pl_sourceTC.groupFinishConditions)){
    pl_internal.groupFinishConditions := pl_sourceTC.groupFinishConditions
    }
    if(ispresent(pl_sourceTC.tcFinishActions)){
    pl_internal.tcFinishActions := pl_sourceTC.tcFinishActions
    }
    */
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_convertTcMgmtTcOfWeightedScenario2Internal
  // 
  //  Purpose:
  //   Converts <EPTF_LGenBase_TcMgmt_TcOfWeightedScenario> data structure into the internal data structure.
  //   This data structure declares a traffic case of a weighted scenario.  
  //   This is an obsolete R2 data structure converter function. 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_convertTcMgmtTcOfWeightedScenario2Internal(
    in EPTF_LGenBase_TcMgmt_TcOfWeightedScenario pl_sourceTC,
    out EPTF_LGenBase_TcOfScenarioInternalDeclarator pl_internal)
  runs on EPTF_Base_CT{
    pl_internal := c_EPTF_LGenBase_emptyTcOfScenarioInternalDeclarator;
    pl_internal.tcPrivateName := pl_sourceTC.tcName;
    pl_internal.tcTypeName := pl_sourceTC.tcName;
    pl_internal.enableEntities := pl_sourceTC.enableEntities;
    pl_internal.enable := pl_sourceTC.enable;
    if(ispresent(pl_sourceTC.entityFinishActions)){
      pl_internal.entityFinishActions := pl_sourceTC.entityFinishActions;
    }
    if(ispresent(pl_sourceTC.ranges)){
      pl_internal.ranges := pl_sourceTC.ranges;
    }
    if(ispresent(pl_sourceTC.params)){
      pl_internal.params := pl_sourceTC.params;
    }
    if(ispresent(pl_sourceTC.entityFinishConditions)){
      f_EPTF_LGenBase_convertTcMgmtEntityFinishConditions2Internal(
        pl_sourceTC.entityFinishConditions, 
        pl_internal.entityFinishConditions)
    }
    var EPTF_LGenBase_TcMgmt_GroupFinishConditions2 vl_gfc := c_EPTF_LGenBase_TcMgmt_emptyGroupFinishConditions2
    var EPTF_LGenBase_TcMgmt_GroupActions2List vl_ga := {};     
    if(ispresent(pl_sourceTC.groupFinishConditions)){
      vl_gfc := pl_sourceTC.groupFinishConditions
    }
    if(ispresent(pl_sourceTC.tcFinishActions)){
      vl_ga := pl_sourceTC.tcFinishActions
    }
    f_EPTF_LGenBase_convertTcMgmtGroupFinishConditions22Internal(
      vl_gfc,
      vl_ga,
      pl_internal.trafficStartFinishConditionsAndActions,
      pl_internal.trafficFinishedActions)
    pl_internal.target.trafficWeight:= pl_sourceTC.tcWeight;
    //Obsolete structures 4 ExecCtrl
    /*
    if(ispresent(pl_sourceTC.groupFinishConditions)){
    pl_internal.groupFinishConditions := pl_sourceTC.groupFinishConditions
    }
    if(ispresent(pl_sourceTC.tcFinishActions)){
    pl_internal.tcFinishActions := pl_sourceTC.tcFinishActions
    }
    */
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareWeightedScenarioType
  // 
  //  Purpose:
  //    Creates weighted scenario. This is an obsolete R2 scenario declaration function.
  // 
  //  Detailed Comments:
  //    This is a TitanSim R2 scenario declaration function. It registers a weighted scenario.     
  //    A scenario is a collection of traffic cases. See <f_EPTF_LGenBase_validateScenarioType>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_declareWeightedScenarioType(
    in EPTF_LGenBase_TcMgmt_WeightedScenarioDeclarator pl_scenario)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var EPTF_LGenBase_ScenarioTypeInternalDeclarator vl_scTypeInternal;
    f_EPTF_LGenBase_convertWeightedScenarioDeclarator2Internal(pl_scenario, vl_scTypeInternal)
    return f_EPTF_LGenBase_declareScenarioTypeInternal(vl_scTypeInternal);
  }
  
  public function f_EPTF_LGenBase_convertWeightedScenarioDeclarator2Internal(
    in EPTF_LGenBase_TcMgmt_WeightedScenarioDeclarator pl_source,
    out EPTF_LGenBase_ScenarioTypeInternalDeclarator pl_scTypeInternal)
  runs on EPTF_Base_CT{
    pl_scTypeInternal := c_EPTF_LGenBase_emptyScenarioTypeInternalDeclarator;
    pl_scTypeInternal.name := pl_source.name;
    pl_scTypeInternal.enabled := pl_source.enabled;      
    pl_scTypeInternal.weightedScData.cpsToReach := pl_source.cpsToReach;
    pl_scTypeInternal.weightedScData.lockCPS := pl_source.lockCPS;
    pl_scTypeInternal.weightedScData.deterministicMix := pl_source.weightedScData.deterministicMix;
    pl_scTypeInternal.weightedScData.scheduler.preDefinedName := cs;
    var integer vl_tcMax := sizeof(pl_source.tcList);
    for(var integer vl_i := 0; vl_i < vl_tcMax; vl_i := vl_i + 1){
      pl_scTypeInternal.tcList[vl_i].enable := false //Placeholder only to create the object
      f_EPTF_LGenBase_convertTcMgmtTcOfWeightedScenario2Internal(
        pl_source.tcList[vl_i],
        pl_scTypeInternal.tcList[vl_i])
    }
  }//f_EPTF_LGenBase_declareWeightedScenarioType
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareTcType
  // 
  //  Purpose:
  //    Declares a traffic case type. This is an obsolete R2 traffic case declaration function.
  // 
  //  Detailed Comments:
  //    
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_declareTcType(
    in EPTF_LGenBase_tcTypeDeclarator pl_tc
  )
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var EPTF_LGenBase_TrafficCaseTypeInternalDeclarator vl_declInternal;
    f_EPTF_LGenBase_converttcTypeDeclarator2Internal(pl_tc,vl_declInternal)
    return f_EPTF_LGenBase_declareTrafficCaseTypeInternal(vl_declInternal)
  }//f_EPTF_LGenBase_declareTcType
  
  public function f_EPTF_LGenBase_convertTcMgmtGroupFinishConditions22Internal(
    in EPTF_LGenBase_TcMgmt_GroupFinishConditions2 pl_conditions,
    in EPTF_LGenBase_TcMgmt_GroupActions2List pl_actions,
    out EPTF_LGenBase_TrafficStartFinishConditionsInternalDeclarator pl_internalStopConditions,
    out EPTF_LGenBase_TcMgmt_GroupActionsList pl_finishedActions)
  runs on EPTF_Base_CT{
    pl_internalStopConditions := c_EPTF_LGenBase_emptyTrafficStartFinishConditionsInternalDeclarator;
    if(ispresent(pl_conditions.execTime)){
      pl_internalStopConditions.execTime := {pl_conditions.execTime,{}}
    }
    if(ispresent(pl_conditions.nrOfExecStart)){
      pl_internalStopConditions.nrOfExecStart := {pl_conditions.nrOfExecStart,{}}
    }
    if(ispresent(pl_conditions.nrOfFails)){
      pl_internalStopConditions.nrOfFails := {pl_conditions.nrOfFails,{}}
    }
    if(ispresent(pl_conditions.nrOfRangeLoop)){
      pl_internalStopConditions.nrOfRangeLoop := {pl_conditions.nrOfRangeLoop,{}}
    }
    if(ispresent(pl_conditions.nrOfSuccesses)){
      pl_internalStopConditions.nrOfSuccesses := {pl_conditions.nrOfSuccesses,{}}
    }
    if(ispresent(pl_conditions.customFinishCondition)){
      pl_internalStopConditions.customFinish := {pl_conditions.customFinishCondition,{}}
    }
    if(ispresent(pl_conditions.nrOfGrpLoop)){
      f_EPTF_Common_warning(%definitionId&" The group loop condition is not implemented.")
    }
    if (ispresent(pl_conditions.entitiesFinished)){
      pl_internalStopConditions.entitiesFinished.actions := {}
    }
    for ( var integer vl_i := 0; vl_i < sizeof(pl_actions) ; vl_i := vl_i+1 )
    {
      select( pl_actions[vl_i].actionsType )
      {
        case ( onGroupFinishCondition ){
          if(not ispresent(pl_internalStopConditions.anythingFinished)){
            pl_internalStopConditions.anythingFinished.actions := {};
          }
          var integer vl_base := sizeof(pl_internalStopConditions.anythingFinished.actions)
          for ( var integer vl_action := 0; vl_action < sizeof(pl_actions[vl_i].actions) ; vl_action := vl_action+1 ){
            pl_internalStopConditions.anythingFinished.actions[vl_base+vl_action] := pl_actions[vl_i].actions[vl_action];
          }
        }
        case ( onLaunchFinish ){
          var integer vl_base := sizeof(pl_finishedActions)
          for ( var integer vl_action := 0; vl_action < sizeof(pl_actions[vl_i].actions) ; vl_action := vl_action+1 ){
            pl_finishedActions[vl_base+vl_action] := pl_actions[vl_i].actions[vl_action];
          }
        }
        case else
        {
          //paranoia
          f_EPTF_Base_assert(%definitionId&": Invalid action type: "&log2str(pl_actions[vl_i].actionsType),false);
        }
      }
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_declareScenarioType
  // 
  //  Purpose:
  //    Creates a non-weighted traffic case scenario. This is an obsolete R2 scenario declaration function.
  // 
  //  Detailed Comments:
  //    A scenario is a collection of traffic cases. See <f_EPTF_LGenBase_validateScenarioType>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_declareScenarioType(in EPTF_LGenBase_ScenarioDeclarator pl_scenario)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var EPTF_LGenBase_ScenarioTypeInternalDeclarator vl_scTypeInternal;
    f_EPTF_LGenBase_convertScenarioDeclarator2Internal(pl_scenario, vl_scTypeInternal)
    return f_EPTF_LGenBase_declareScenarioTypeInternal(vl_scTypeInternal);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_convertScenarioDeclarator2Internal
  // 
  //  Purpose:
  //   Converts <EPTF_LGenBase_ScenarioDeclarator> scenario data structure into the internal data structure.
  //   This is an obsolete R2 data structure
  ///////////////////////////////////////////////////////////  
  friend function f_EPTF_LGenBase_convertScenarioDeclarator2Internal(
    in EPTF_LGenBase_ScenarioDeclarator pl_source,
    out EPTF_LGenBase_ScenarioTypeInternalDeclarator pl_scTypeInternal)
  runs on EPTF_Base_CT{
    pl_scTypeInternal:= c_EPTF_LGenBase_emptyScenarioTypeInternalDeclarator;
    pl_scTypeInternal.name := pl_source.name;
    pl_scTypeInternal.conditionsFromTC := true; 
    var integer vl_tcMax := sizeof(pl_source.tcList);
    for(var integer vl_i := 0; vl_i < vl_tcMax; vl_i := vl_i + 1){
      pl_scTypeInternal.tcList[vl_i].enable := false //Placeholder only to create the object
      f_EPTF_LGenBase_convertTcOfScenario2Internal(
        pl_source.tcList[vl_i],
        pl_scTypeInternal.tcList[vl_i])
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_convertTcOfScenario2Internal
  // 
  //  Purpose:
  //   Converts <EPTF_LGenBase_TcOfScenario> data structure into the internal data structure.
  //   This data structure declares a traffic case of a non-weighted scenario.  
  //   This is an obsolete R2 data structure converter function.  
  ///////////////////////////////////////////////////////////   
  friend function f_EPTF_LGenBase_convertTcOfScenario2Internal(
    in EPTF_LGenBase_TcOfScenario pl_sourceTC,
    out EPTF_LGenBase_TcOfScenarioInternalDeclarator pl_internal)
  runs on EPTF_Base_CT{
    pl_internal := c_EPTF_LGenBase_emptyTcOfScenarioInternalDeclarator;
    pl_internal.tcPrivateName := pl_sourceTC.tcName;
    pl_internal.tcTypeName := pl_sourceTC.tcName;
    pl_internal.startDelay := pl_sourceTC.startDelay;
    pl_internal.target.cpsToReach := pl_sourceTC.cpsToReach;
    pl_internal.enableEntities := pl_sourceTC.enableEntities;
    pl_internal.enable := pl_sourceTC.enable;
    pl_internal.ranges := pl_sourceTC.ranges;
  }
  
} // group obsolete
}  // end of module
