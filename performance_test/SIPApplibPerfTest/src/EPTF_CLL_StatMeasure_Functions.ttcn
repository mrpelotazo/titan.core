/******************************************************************************
 * Copyright (c) 2000-2018 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 ******************************************************************************/
//  File:     EPTF_CLL_StatMeasure_Functions.ttcn
//  Rev:      <RnXnn>
//  Prodnr:   CNL 113 512
//  Updated:  2012-05-11
//  Contact:  http://ttcn.ericsson.se
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//  Module: EPTF_CLL_StatMeasure_Functions
// 
//  Purpose:
//    This module contains function definitions for TTCN-3 EPTF StatMeasure 
//    implementation.
// 
//  Module Parameters:
//    tsp_debug_EPTF_StatMeasure_Functions - boolean - enable/disable debugging
//
//  Module depends on:
//    <EPTF_CLL_StatMeasure_Definitions>
//    <EPTF_CLL_Variable_Definitions>
//    <EPTF_CLL_Variable_Functions>
//    <EPTF_CLL_Base_Definitions>
//    <EPTF_CLL_Base_Functions>
//    <EPTF_CLL_Common_Definitions>
//    <EPTF_CLL_Logging_Definitions>
//    <EPTF_CLL_Logging_Functions>
//
//  Public functions:
//    <f_EPTF_StatMeasure_init_CT>
//    <f_EPTF_StatMeasure_LogAll>
//    <f_EPTF_StatMeasure_LogStat>
//    <f_EPTF_StatMeasure_newStat>
//    <f_EPTF_StatMeasure_newStatWithParams>
//    <f_EPTF_StatMeasure_createAllStats>
//    <f_EPTF_StatMeasure_resetStats>
//    <f_EPTF_StatMeasure_getVarIdx>
//    <f_EPTF_StatMeasure_getCreatedVarIdx>
//    <f_EPTF_StatMeasure_isEnabled>
//    <f_EPTF_StatMeasure_isReset>
//    <f_EPTF_StatMeasure_getStatType>
//    <f_EPTF_StatMeasure_resetStat>
//    <f_EPTF_StatMeasure_initStatValue>
//    <f_EPTF_StatMeasure_enableStat>
//    <f_EPTF_StatMeasure_disableStat>
//    <f_EPTF_StatMeasure_value2str>
//    <f_EPTF_StatMeasure_createVarFromStat>
//    <f_EPTF_StatMeasure_newStat_content>
//    <f_EPTF_StatMeasure_resetStat_content>
//    <f_EPTF_StatMeasure_initStatValue_content>
//    <f_EPTF_StatMeasure_enableStat_content>
//    <f_EPTF_StatMeasure_disableStat_content>
//    <f_EPTF_StatMeasure_getStat_content>
//    <f_EPTF_StatMeasure_content2str>
//    <f_EPTF_StatMeasure_newStat_delta>
//    <f_EPTF_StatMeasure_resetStat_delta>
//    <f_EPTF_StatMeasure_initStatValue_delta>
//    <f_EPTF_StatMeasure_changeToFloat_delta>
//    <f_EPTF_StatMeasure_addData_delta>
//    <f_EPTF_StatMeasure_enableStat_delta>
//    <f_EPTF_StatMeasure_disableStat_delta>
//    <f_EPTF_StatMeasure_getStat_delta>
//    <f_EPTF_StatMeasure_delta2str>
//    <f_EPTF_StatMeasure_newStat_deltaSum>
//    <f_EPTF_StatMeasure_resetStat_deltaSum>
//    <f_EPTF_StatMeasure_initStatValue_deltaSum>
//    <f_EPTF_StatMeasure_changeToFloat_deltaSum>
//    <f_EPTF_StatMeasure_addData_deltaSum>
//    <f_EPTF_StatMeasure_enableStat_deltaSum>
//    <f_EPTF_StatMeasure_disableStat_deltaSum>
//    <f_EPTF_StatMeasure_getStat_deltaSum>
//    <f_EPTF_StatMeasure_deltaSum2str>
//    <f_EPTF_StatMeasure_newStat_min>
//    <f_EPTF_StatMeasure_resetStat_min>
//    <f_EPTF_StatMeasure_initStatValue_min>
//    <f_EPTF_StatMeasure_changeToFloat_min>
//    <f_EPTF_StatMeasure_addData_min>
//    <f_EPTF_StatMeasure_enableStat_min>
//    <f_EPTF_StatMeasure_disableStat_min>
//    <f_EPTF_StatMeasure_getStat_min>
//    <f_EPTF_StatMeasure_min2str>
//    <f_EPTF_StatMeasure_newStat_max>
//    <f_EPTF_StatMeasure_changeToFloat_max>
//    <f_EPTF_StatMeasure_resetStat_max>
//    <f_EPTF_StatMeasure_initStatValue_max>
//    <f_EPTF_StatMeasure_addData_max>
//    <f_EPTF_StatMeasure_enableStat_max>
//    <f_EPTF_StatMeasure_disableStat_max>
//    <f_EPTF_StatMeasure_getStat_max>
//    <f_EPTF_StatMeasure_max2str>
//    <f_EPTF_StatMeasure_newStat_mean>
//    <f_EPTF_StatMeasure_resetStat_mean>
//    <f_EPTF_StatMeasure_initStatValue_mean>
//    <f_EPTF_StatMeasure_addData_mean>
//    <f_EPTF_StatMeasure_enableStat_mean>
//    <f_EPTF_StatMeasure_disableStat_mean>
//    <f_EPTF_StatMeasure_getStat_mean>
//    <f_EPTF_StatMeasure_mean2str>
//    <f_EPTF_StatMeasure_createVarFromStat_N_mean>
//    <f_EPTF_StatMeasure_newStat_standardDev>
//    <f_EPTF_StatMeasure_resetStat_standardDev>
//    <f_EPTF_StatMeasure_initStatValue_standardDev>
//    <f_EPTF_StatMeasure_addData_standardDev>
//    <f_EPTF_StatMeasure_enableStat_standardDev>
//    <f_EPTF_StatMeasure_disableStat_standardDev>
//    <f_EPTF_StatMeasure_getStat_standardDev>
//    <f_EPTF_StatMeasure_getStat_standardDev_mean>
//    <f_EPTF_StatMeasure_getStatIdx_standardDev_mean>
//    <f_EPTF_StatMeasure_standardDev2str>
//    <f_EPTF_StatMeasure_standardDev_mean2str>
//    <f_EPTF_StatMeasure_createVarFromStat_Mean_standardDev>
//    <f_EPTF_StatMeasure_createVarFromStat_N_standardDev>
//    <f_EPTF_StatMeasure_createVarFromStat_S_standardDev>
//    <f_EPTF_StatMeasure_newStat_EPS>
//    <f_EPTF_StatMeasure_resetStat_EPS>
//    <f_EPTF_StatMeasure_initStatValue_EPS>
//    <f_EPTF_StatMeasure_startMeasurement_EPS>
//    <f_EPTF_StatMeasure_addData_EPS>
//    <f_EPTF_StatMeasure_enableStat_EPS>
//    <f_EPTF_StatMeasure_disableStat_EPS>
//    <f_EPTF_StatMeasure_getStat_EPS>
//    <f_EPTF_StatMeasure_EPS2str>
//    <f_EPTF_StatMeasure_getMeasurementLength_EPS>
//    <f_EPTF_StatMeasure_getTime_EPS>
//    <f_EPTF_StatMeasure_update_EPS>
//    <f_EPTF_StatMeasure_newStat_chrono>
//    <f_EPTF_StatMeasure_resetStat_chrono>
//    <f_EPTF_StatMeasure_initStatValue_chrono>
//    <f_EPTF_StatMeasure_start_chrono>
//    <f_EPTF_StatMeasure_stop_chrono>
//    <f_EPTF_StatMeasure_addData_chrono>
//    <f_EPTF_StatMeasure_enableStat_chrono>
//    <f_EPTF_StatMeasure_disableStat_chrono>
//    <f_EPTF_StatMeasure_getStat_chrono>
//    <f_EPTF_StatMeasure_chrono2str>
//    <f_EPTF_StatMeasure_getMeasurementLength_chrono>
//    <f_EPTF_StatMeasure_getTime_chrono>
//    <f_EPTF_StatMeasure_update_chrono>
//    <f_EPTF_StatMeasure_newStat_density>
//    <f_EPTF_StatMeasure_setBoundaries_density>
//    <f_EPTF_StatMeasure_getBoundaries_density>
//    <f_EPTF_StatMeasure_setScale_density>
//    <f_EPTF_StatMeasure_resetStat_density>
//    <f_EPTF_StatMeasure_initStatValue_density>
//    <f_EPTF_StatMeasure_addData_density>
//    <f_EPTF_StatMeasure_enableStat_density>
//    <f_EPTF_StatMeasure_disableStat_density>
//    <f_EPTF_StatMeasure_getStat_density>
//    <f_EPTF_StatMeasure_getStat_normalized_density>
//    <f_EPTF_StatMeasure_density2str>
//    <f_EPTF_StatMeasure_createVarFromStat_boundaries_density>
//    <f_EPTF_StatMeasure_newStat_percentileP>
//    <f_EPTF_StatMeasure_setBoundaries_percentileP>
//    <f_EPTF_StatMeasure_setScale_percentileP>
//    <f_EPTF_StatMeasure_setValueP_percentileP>
//    <f_EPTF_StatMeasure_resetStat_percentileP>
//    <f_EPTF_StatMeasure_initStatValue_percentileP>
//    <f_EPTF_StatMeasure_addData_percentileP>
//    <f_EPTF_StatMeasure_enableStat_percentileP>
//    <f_EPTF_StatMeasure_disableStat_percentileP>
//    <f_EPTF_StatMeasure_getStat_percentileP>
//    <f_EPTF_StatMeasure_getStatIdx_density_percentileP>
//    <f_EPTF_StatMeasure_getStatIdx_max_percentileP>
//    <f_EPTF_StatMeasure_percentileP2str>
//    <f_EPTF_StatMeasure_createVarFromStat_max_percentileP>
//    <f_EPTF_StatMeasure_createVarFromStat_density_percentileP>
//    <f_EPTF_StatMeasure_createVarFromStat_boundaries_density_percentileP>
//    <f_EPTF_StatMeasure_createVarFromStat_valueP_percentileP>
//    <f_EPTF_StatMeasure_newStat_percentile95>
//    <f_EPTF_StatMeasure_setBoundaries_percentile95>
//    <f_EPTF_StatMeasure_setScale_percentile95>
//    <f_EPTF_StatMeasure_resetStat_percentile95>
//    <f_EPTF_StatMeasure_initStatValue_percentile95>
//    <f_EPTF_StatMeasure_addData_percentile95>
//    <f_EPTF_StatMeasure_enableStat_percentile95>
//    <f_EPTF_StatMeasure_disableStat_percentile95>
//    <f_EPTF_StatMeasure_getStat_percentile95>
//    <f_EPTF_StatMeasure_getStatIdx_density_percentile95>
//    <f_EPTF_StatMeasure_getStatIdx_max_percentile95>
//    <f_EPTF_StatMeasure_percentile952str>
//    <f_EPTF_StatMeasure_createVarFromStat_max_percentile95>
//    <f_EPTF_StatMeasure_createVarFromStat_density_percentile95>
//    <f_EPTF_StatMeasure_createVarFromStat_boundaries_density_percentile95>
//    <f_EPTF_StatMeasure_newStat_limits>
//    <f_EPTF_StatMeasure_setLimits_limits>
//    <f_EPTF_StatMeasure_getLimits_limits>
//    <f_EPTF_StatMeasure_resetStat_limits>
//    <f_EPTF_StatMeasure_initStatValue_limits>
//    <f_EPTF_StatMeasure_addData_limits>
//    <f_EPTF_StatMeasure_enableStat_limits>
//    <f_EPTF_StatMeasure_disableStat_limits>
//    <f_EPTF_StatMeasure_getStat_limits>
//    <f_EPTF_StatMeasure_limits2str>
//    <f_EPTF_StatMeasure_newStat_custom>
//    <f_EPTF_StatMeasure_setProperties_custom>
//    <f_EPTF_StatMeasure_resetStat_custom>
//    <f_EPTF_StatMeasure_addData_custom>
//    <f_EPTF_StatMeasure_enableStat_custom>
//    <f_EPTF_StatMeasure_disableStat_custom>
//    <f_EPTF_StatMeasure_getStat_custom>
//    <f_EPTF_StatMeasure_custom2str>
//    <f_EPTF_StatMeasure_createVarFromStat_custom>
//
//    <f_EPTF_StatMeasure_bubblesort>
//    <f_EPTF_StatMeasure_getStatName>
//    <f_EPTF_StatMeasure_registerDefaultUpdate_EPS>
//    <f_EPTF_StatMeasure_stat2Var>
// 
//  Current Owner:
//    Jozsef Gyurusi (ETHJGI)
// 
//  Last Review Date:
//    2009-05-22
//
//  Detailed Comments:
//    This module contains function definitions for TTCN-3 EPTF StatMeasure 
//    implementation.
// 
///////////////////////////////////////////////////////////////////////////////

module EPTF_CLL_StatMeasure_Functions {

import from EPTF_CLL_StatMeasure_Definitions all;
import from EPTF_CLL_Variable_Definitions all;
import from EPTF_CLL_Variable_Functions all;
import from EPTF_CLL_Base_Definitions all;
import from EPTF_CLL_Base_Functions all;
import from EPTF_CLL_Common_Definitions all; // EPTF_IntegerList
import from TCCMaths_Functions all; // sqrt, etc.
import from EPTF_CLL_Logging_Definitions all;
import from EPTF_CLL_Logging_Functions all;

modulepar boolean tsp_debug_EPTF_StatMeasure_Functions := false;

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_init_CT
// 
//  Purpose:
//    Initializes the EPTF_StatMeasure_CT component
//
//  Parameters:
//    -
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    This function should be called before using the <EPTF_StatMeasure_CT>
//    component.
//
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_init_CT(
  in charstring pl_selfName) 
runs on EPTF_StatMeasure_CT 
{
  if (v_EPTF_StatMeasure_initialized) {
    return; // already initialized
  }

  f_EPTF_Logging_init_CT(pl_selfName);
  v_StatMeasure_loggingMaskId := f_EPTF_Logging_registerComponentMasks(tsp_EPTF_StatMeasure_loggingComponentMask, c_EPTF_StatMeasure_loggingEventClasses, EPTF_Logging_CLL);
  if(tsp_debug_EPTF_StatMeasure_Functions) {
    f_EPTF_Logging_enableLocalMask(v_StatMeasure_loggingMaskId, c_EPTF_StatMeasure_loggingClassIdx_Debug);
  } else {
    f_EPTF_Logging_disableLocalMask(v_StatMeasure_loggingMaskId, c_EPTF_StatMeasure_loggingClassIdx_Debug);
  }
  f_EPTF_Var_init_CT(pl_selfName);

  statList := {};
  
  v_EPTF_StatMeasure_initialized := true;

  f_EPTF_Base_registerCleanup(refers(f_EPTF_StatMeasure_cleanup_CT));

  //log("----STATMEASURE INIT DONE----");
  f_EPTF_StatMeasure_debug(
    "---- EPTF_StatMeasure INIT "&pl_selfName&" DONE ----");
}


///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_LogAll
// 
//  Purpose:
//    Log everything (important) in <EPTF_StatMeasure_CT> component
//
//  Parameters:
//    pl_msg - *in* *charstring* - message to log. It is printed before and 
//    after the component data
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_LogAll(
  in charstring pl_msg) 
runs on EPTF_StatMeasure_CT 
{
  if (pl_msg!="")  { f_EPTF_StatMeasure_debug(pl_msg); }

  f_EPTF_StatMeasure_debug(
    log2str("EPTF_StatMeasure_CT.statList: ", statList));
  
  if (pl_msg!="") {f_EPTF_StatMeasure_debug(pl_msg);}
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_LogAll
// 
//  Purpose:
//    Log everything about the given stat
//
//  Parameters:
//    pl_msg - *in* *charstring* - message to log. It is printed before and 
//    after the component data
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_LogStat(
  in charstring pl_msg,
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_debug(
    log2str(pl_msg&": EPTF_StatMeasure_CT.statList[",pl_statIdx,"]: ", statList[pl_statIdx]));
}

///////////////////////////////////////////////////////////////////////////////
// Group: General
//
// Purpose:
//   General functions for all statistics
//
// Elements:
///////////////////////////////////////////////////////////////////////////////
group General {

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStat
// 
//  Purpose:
//    Creates a new statistics for the EPTF Variable and returns its idx.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var (-1 for standalone)
//    pl_statType - *in* <EPTF_StatMeasure_statType> - type of stat   
//
//  Return Value:
//    *integer* - index of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If the pl_varIdx is set to -1 then a standalone statistics will be 
//    created. It is not allowed to create standalone content type statistics.
//    The created statistics is enabled and created with default settings.
//    Note, that the type of the stats 'delta', 'deltaSum', 'min' and 'max' is
//    set to integer by default. It should be modified if needed before creating
//    variable from the stat!
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStat(
  in integer pl_varIdx, 
  in EPTF_StatMeasure_statType pl_statType) 
runs on EPTF_StatMeasure_CT return integer 
{
  if (pl_statType == content) {
    return f_EPTF_StatMeasure_newStat_content(pl_varIdx);
  }
  if (pl_statType == delta) {
    return f_EPTF_StatMeasure_newStat_delta(pl_varIdx);
  }
  if (pl_statType == deltaSum) {
    return f_EPTF_StatMeasure_newStat_deltaSum(pl_varIdx);
  }
  if (pl_statType == min) {
    return f_EPTF_StatMeasure_newStat_min(pl_varIdx);
  }
  if (pl_statType == max) {
    return f_EPTF_StatMeasure_newStat_max(pl_varIdx);
  }
  if (pl_statType == mean) {
    return f_EPTF_StatMeasure_newStat_mean(pl_varIdx);
  }
  if (pl_statType == standardDev) {
    return f_EPTF_StatMeasure_newStat_standardDev(pl_varIdx);
  }
  if (pl_statType == EPS) {
    return f_EPTF_StatMeasure_newStat_EPS(pl_varIdx);
  }
  if (pl_statType == chrono) {
    return f_EPTF_StatMeasure_newStat_chrono(pl_varIdx);
  }
  if (pl_statType == density) {
    return f_EPTF_StatMeasure_newStat_density({},pl_varIdx);
  }
  if (pl_statType == percentileP) {
    return f_EPTF_StatMeasure_newStat_percentileP({}, 0.5, pl_varIdx);
  }  
  if (pl_statType == percentile95) {
    return f_EPTF_StatMeasure_newStat_percentile95({}, pl_varIdx);
  }
  if (pl_statType == limits) {
    return f_EPTF_StatMeasure_newStat_limits(pl_varIdx);
  }
  if (pl_statType == custom) {
    return f_EPTF_StatMeasure_newStat_custom(pl_varIdx);
  }
  //...
  return -1; // never reached
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStatWithParams
// 
//  Purpose:
//    Creates a new statistics for the EPTF Variable and returns its idx.
//    Additional parameters can be specified
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var (-1 for standalone)
//    pl_statParams - *in* <EPTF_StatMeasure_StatParams> - type and parameter of the stat
//
//  Return Value:
//    *integer* - index of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If the pl_varIdx is set to -1 then a standalone statistics will be 
//    created. It is not allowed to create standalone content type statistics.
//    The created statistics is enabled and created with default settings.
//    Note, that the type of the stats 'delta', 'deltaSum', 'min' and 'max' is
//    set to integer by default. It should be modified if needed before creating
//    variable from the stat!
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStatWithParams(
  in integer pl_varIdx, 
  in EPTF_StatMeasure_StatParams pl_statParams) 
runs on EPTF_StatMeasure_CT return integer 
{
  if (ischosen(pl_statParams.content)) {
    return f_EPTF_StatMeasure_newStat_content(pl_varIdx);
  }
  if (ischosen(pl_statParams.delta)) {
    return f_EPTF_StatMeasure_newStat_delta(pl_varIdx);
  }
  if (ischosen(pl_statParams.deltaSum)) {
    return f_EPTF_StatMeasure_newStat_deltaSum(pl_varIdx);
  }
  if (ischosen(pl_statParams.min)) {
    return f_EPTF_StatMeasure_newStat_min(pl_varIdx);
  }
  if (ischosen(pl_statParams.max)) {
    return f_EPTF_StatMeasure_newStat_max(pl_varIdx);
  }
  if (ischosen(pl_statParams.mean)) {
    return f_EPTF_StatMeasure_newStat_mean(pl_varIdx);
  }
  if (ischosen(pl_statParams.standardDev)) {
    return f_EPTF_StatMeasure_newStat_standardDev(pl_varIdx);
  }
  if (ischosen(pl_statParams.EPS)) {
    var integer vl_statId := f_EPTF_StatMeasure_newStat_EPS(pl_varIdx);
    if(lengthof(pl_statParams.EPS) != 0) {
      if(lengthof(pl_statParams.EPS) > 1) {
        f_EPTF_StatMeasure_warning(%definitionId&": more than one parameter "&
          "not currently supported for EPS statistics. The first parameter will be used.");
      }
      if (ischosen(pl_statParams.EPS[0].registerDefaultUpdate) and
        pl_statParams.EPS[0].registerDefaultUpdate) {
        f_EPTF_StatMeasure_registerDefaultUpdate_EPS(vl_statId);
      }
    }
    return vl_statId;
  }
  if (ischosen(pl_statParams.chrono)) {
    return f_EPTF_StatMeasure_newStat_chrono(pl_varIdx);
  }
  if (ischosen(pl_statParams.density)) {
    var integer vl_statId := f_EPTF_StatMeasure_newStat_density({},pl_varIdx);
    if (ischosen(pl_statParams.density.boundaries)) {
      f_EPTF_StatMeasure_setBoundaries_density(vl_statId,pl_statParams.density.boundaries);
    }
    if (ischosen(pl_statParams.density.scale)) {
      f_EPTF_StatMeasure_setScale_density(vl_statId,
        pl_statParams.density.scale.min,
        pl_statParams.density.scale.max,
        pl_statParams.density.scale.n,
        pl_statParams.density.scale.scale
      );
    }
    return vl_statId;
  }
  if (ischosen(pl_statParams.percentileP)) {
    var integer vl_statId :=  f_EPTF_StatMeasure_newStat_percentileP({}, 0.5, pl_varIdx);
    f_EPTF_StatMeasure_setValueP_percentileP(vl_statId,pl_statParams.percentileP.valueP);
    if (ischosen(pl_statParams.percentileP.density.boundaries)) {
      f_EPTF_StatMeasure_setBoundaries_percentileP(vl_statId,pl_statParams.percentileP.density.boundaries);
    }
    if (ischosen(pl_statParams.percentileP.density.scale)) {
      f_EPTF_StatMeasure_setScale_percentileP(vl_statId,
        pl_statParams.percentileP.density.scale.min,
        pl_statParams.percentileP.density.scale.max,
        pl_statParams.percentileP.density.scale.n,
        pl_statParams.percentileP.density.scale.scale
      );
    }
    return vl_statId;
  }    
  if (ischosen(pl_statParams.percentile95)) {
    var integer vl_statId :=  f_EPTF_StatMeasure_newStat_percentile95({}, pl_varIdx);
    if (ischosen(pl_statParams.percentile95.boundaries)) {
      f_EPTF_StatMeasure_setBoundaries_percentile95(vl_statId,pl_statParams.percentile95.boundaries);
    }
    if (ischosen(pl_statParams.percentile95.scale)) {
      f_EPTF_StatMeasure_setScale_percentile95(vl_statId,
        pl_statParams.percentile95.scale.min,
        pl_statParams.percentile95.scale.max,
        pl_statParams.percentile95.scale.n,
        pl_statParams.percentile95.scale.scale
      );
    }
    return vl_statId;
  }
  if (ischosen(pl_statParams.limits)) {
    return f_EPTF_StatMeasure_newStat_limits(
      pl_varIdx,
      pl_statParams.limits.limits,
      pl_statParams.limits.referenceVarId,
      pl_statParams.limits.defaultColor,
      pl_statParams.limits.enableValueInLEDText
    );
  }
  if (ischosen(pl_statParams.custom)) {
    return f_EPTF_StatMeasure_newStat_custom(pl_varIdx);
  }
  //...
  return -1; // never reached
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_createAllStats
// 
//  Purpose:
//    Creates all available statistics for the EPTF Variable and returns 
//    their indexes.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var (-1 for standalone stat)
//
//  Return Value:
//    *EPTF_IntegerList* - list of the indexes of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    The created statistics are enabled and created with default settings.
//    Note, that the type of the stats 'delta', 'deltaSum', 'min' and 'max' is
//    set to integer by default. It should be modified if needed before creating
//    variable from the stat!
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_createAllStats(
  in integer pl_varIdx) 
runs on EPTF_StatMeasure_CT return EPTF_IntegerList 
{
  var EPTF_IntegerList vl_idxList := {};

  vl_idxList[sizeof(vl_idxList)] := f_EPTF_StatMeasure_newStat_content(pl_varIdx);
  vl_idxList[sizeof(vl_idxList)] := f_EPTF_StatMeasure_newStat_delta(pl_varIdx);
  vl_idxList[sizeof(vl_idxList)] := f_EPTF_StatMeasure_newStat_deltaSum(pl_varIdx);
  vl_idxList[sizeof(vl_idxList)] := f_EPTF_StatMeasure_newStat_min(pl_varIdx);
  vl_idxList[sizeof(vl_idxList)] := f_EPTF_StatMeasure_newStat_max(pl_varIdx);
  vl_idxList[sizeof(vl_idxList)] := f_EPTF_StatMeasure_newStat_mean(pl_varIdx);
  vl_idxList[sizeof(vl_idxList)] := f_EPTF_StatMeasure_newStat_standardDev(pl_varIdx);
  vl_idxList[sizeof(vl_idxList)] := f_EPTF_StatMeasure_newStat_EPS(pl_varIdx);
  vl_idxList[sizeof(vl_idxList)] := f_EPTF_StatMeasure_newStat_chrono(pl_varIdx);
  vl_idxList[sizeof(vl_idxList)] := f_EPTF_StatMeasure_newStat_density({},pl_varIdx);
  vl_idxList[sizeof(vl_idxList)] := f_EPTF_StatMeasure_newStat_percentile95({}, pl_varIdx);  
  vl_idxList[sizeof(vl_idxList)] := f_EPTF_StatMeasure_newStat_percentileP({}, 0.5, pl_varIdx);
  vl_idxList[sizeof(vl_idxList)] := f_EPTF_StatMeasure_newStat_limits(pl_varIdx);
  vl_idxList[sizeof(vl_idxList)] := f_EPTF_StatMeasure_newStat_custom(pl_varIdx);
  /*
  for (var integer i := 0; i < sizeof(customStatFNs); i := i + 1) 
  {
    vl_idxList[sizeof(vl_idxList)] := f_EPTF_StatMeasure_newStat_custom(pl_varIdx, i);
  }
  */
  //...
  return vl_idxList;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStats
// 
//  Purpose:
//    Resets the given statistics list
//
//  Parameters:
//    pl_idx - *in* <EPTF_IntegerList> - list of the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStats(
  in EPTF_IntegerList pl_statIdxList) 
runs on EPTF_StatMeasure_CT 
{
  for(var integer i:=0; i<sizeof(pl_statIdxList); i:=i+1) {
    f_EPTF_StatMeasure_resetStat(pl_statIdxList[i]);
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getVarIdx
// 
//  Purpose:
//    Returns the idx of the EPTF Variable the given statistics calculated
//    from.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getVarIdx(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return integer 
{
  return statList[pl_statIdx].varIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getCreatedVarIdx
// 
//  Purpose:
//    Returns the idx of the EPTF Variable created from the given statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getCreatedVarIdx(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return integer 
{
  return statList[pl_statIdx].createdVarIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_isEnabled
// 
//  Purpose:
//    Returns true if the stat is enabled.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    *boolean* - enabled state (true: enabled / false: disabled)
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_isEnabled(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return boolean 
{
  return statList[pl_statIdx].enabled;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_isReset
// 
//  Purpose:
//    Returns true if the stat was reset.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    *boolean* - reset state (true: need reset / false: don!t need reset)
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_isReset(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return boolean 
{
  return statList[pl_statIdx].reset;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStatType
// 
//  Purpose:
//    Returns the type of the statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    EPTF_StatMeasure_statType - type of the statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStatType(
  in integer pl_statIdx
) runs on EPTF_StatMeasure_CT return EPTF_StatMeasure_statType 
{
  if (ischosen(statList[pl_statIdx].statData.content)) {
    return content;
  }
  if (ischosen(statList[pl_statIdx].statData.delta)) {
    return delta;
  }
  if (ischosen(statList[pl_statIdx].statData.deltaSum)) {
    return deltaSum;
  }
  if (ischosen(statList[pl_statIdx].statData.min)) {
    return min;
  }
  if (ischosen(statList[pl_statIdx].statData.max)) {
    return max;
  }
  if (ischosen(statList[pl_statIdx].statData.mean)) {
    return mean;
  }
  if (ischosen(statList[pl_statIdx].statData.standardDev)) {
    return standardDev;
  }
  if (ischosen(statList[pl_statIdx].statData.EPS)) {
    return EPS;
  }
  if (ischosen(statList[pl_statIdx].statData.chrono)) {
    return chrono;
  }
  if (ischosen(statList[pl_statIdx].statData.density)) {
    return density;
  }
  if (ischosen(statList[pl_statIdx].statData.percentileP)) {
    return percentileP;
  }  
  if (ischosen(statList[pl_statIdx].statData.percentile95)) {
    return percentile95;
  }
  if (ischosen(statList[pl_statIdx].statData.limits)) {
    return limits;
  }
  if (ischosen(statList[pl_statIdx].statData.custom)) {
    return custom;
  }
  
 //...
  return content; // just to remove the warning, never executed
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStat
// 
//  Purpose:
//    Reset a given statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStat(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (ischosen(statList[pl_statIdx].statData.content)) {
    f_EPTF_StatMeasure_resetStat_content(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.delta)) {
    f_EPTF_StatMeasure_resetStat_delta(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.deltaSum)) {
    f_EPTF_StatMeasure_resetStat_deltaSum(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.min)) {
    f_EPTF_StatMeasure_resetStat_min(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.max)) {
    f_EPTF_StatMeasure_resetStat_max(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.mean)) {
    f_EPTF_StatMeasure_resetStat_mean(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.standardDev)) {
    f_EPTF_StatMeasure_resetStat_standardDev(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.EPS)) {
    f_EPTF_StatMeasure_resetStat_EPS(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.chrono)) {
    f_EPTF_StatMeasure_resetStat_chrono(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.density)) {
    f_EPTF_StatMeasure_resetStat_density(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.percentileP)) {
    f_EPTF_StatMeasure_resetStat_percentileP(pl_statIdx);
    return;
  }  
  if (ischosen(statList[pl_statIdx].statData.percentile95)) {
    f_EPTF_StatMeasure_resetStat_percentile95(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.limits)) {
    f_EPTF_StatMeasure_resetStat_limits(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.custom)) {
    f_EPTF_StatMeasure_resetStat_custom(pl_statIdx);
    return;
  }
  //...
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initStatValue
// 
//  Purpose:
//    Initializes the value of a given statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Stat is initialized with zero.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_initStatValue(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (ischosen(statList[pl_statIdx].statData.content)) {
    f_EPTF_StatMeasure_initStatValue_content(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.delta)) {
    f_EPTF_StatMeasure_initStatValue_delta(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.deltaSum)) {
    f_EPTF_StatMeasure_initStatValue_deltaSum(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.min)) {
    f_EPTF_StatMeasure_initStatValue_min(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.max)) {
    f_EPTF_StatMeasure_initStatValue_max(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.mean)) {
    f_EPTF_StatMeasure_initStatValue_mean(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.standardDev)) {
    f_EPTF_StatMeasure_initStatValue_standardDev(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.EPS)) {
    f_EPTF_StatMeasure_initStatValue_EPS(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.chrono)) {
    f_EPTF_StatMeasure_initStatValue_chrono(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.density)) {
    f_EPTF_StatMeasure_initStatValue_density(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.percentileP)) {
    f_EPTF_StatMeasure_initStatValue_percentileP(pl_statIdx);
    return;
  }  
  if (ischosen(statList[pl_statIdx].statData.percentile95)) {
    f_EPTF_StatMeasure_initStatValue_percentile95(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.limits)) {
    f_EPTF_StatMeasure_initStatValue_limits(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.custom)) {
    //f_EPTF_StatMeasure_initStatValue_custom(pl_statIdx);
    return;
  }
  //...
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_enableStat
// 
//  Purpose:
//    Enable a given statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    The statistics will be updated only after enabled.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_enableStat(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (ischosen(statList[pl_statIdx].statData.content)) {
    f_EPTF_StatMeasure_enableStat_content(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.delta)) {
    f_EPTF_StatMeasure_enableStat_delta(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.deltaSum)) {
    f_EPTF_StatMeasure_enableStat_deltaSum(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.min)) {
    f_EPTF_StatMeasure_enableStat_min(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.max)) {
    f_EPTF_StatMeasure_enableStat_max(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.mean)) {
    f_EPTF_StatMeasure_enableStat_mean(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.standardDev)) {
    f_EPTF_StatMeasure_enableStat_standardDev(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.EPS)) {
    f_EPTF_StatMeasure_enableStat_EPS(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.chrono)) {
    f_EPTF_StatMeasure_enableStat_chrono(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.density)) {
    f_EPTF_StatMeasure_enableStat_density(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.percentileP)) {
    f_EPTF_StatMeasure_enableStat_percentileP(pl_statIdx);
    return;
  }  
  if (ischosen(statList[pl_statIdx].statData.percentile95)) {
    f_EPTF_StatMeasure_enableStat_percentile95(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.limits)) {
    f_EPTF_StatMeasure_enableStat_limits(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.custom)) {
    f_EPTF_StatMeasure_enableStat_custom(pl_statIdx);
    return;
  }
  //...
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_disableStat
// 
//  Purpose:
//    Disable a given statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    The statistics will not be updated only after disabled.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_disableStat(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (ischosen(statList[pl_statIdx].statData.content)) {
    f_EPTF_StatMeasure_disableStat_content(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.delta)) {
    f_EPTF_StatMeasure_disableStat_delta(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.deltaSum)) {
    f_EPTF_StatMeasure_disableStat_deltaSum(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.min)) {
    f_EPTF_StatMeasure_disableStat_min(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.max)) {
    f_EPTF_StatMeasure_disableStat_max(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.mean)) {
    f_EPTF_StatMeasure_disableStat_mean(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.standardDev)) {
    f_EPTF_StatMeasure_disableStat_standardDev(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.EPS)) {
    f_EPTF_StatMeasure_disableStat_EPS(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.chrono)) {
    f_EPTF_StatMeasure_disableStat_chrono(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.density)) {
    f_EPTF_StatMeasure_disableStat_density(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.percentileP)) {
    f_EPTF_StatMeasure_disableStat_percentileP(pl_statIdx);
    return;
  }  
  if (ischosen(statList[pl_statIdx].statData.percentile95)) {
    f_EPTF_StatMeasure_disableStat_percentile95(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.limits)) {
    f_EPTF_StatMeasure_disableStat_limits(pl_statIdx);
    return;
  }
  if (ischosen(statList[pl_statIdx].statData.custom)) {
    f_EPTF_StatMeasure_disableStat_custom(pl_statIdx);
    return;
  }
  //...
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_value2str
// 
//  Purpose:
//    Converts the value of the statistics to charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    *charstring* - the value of the statistics as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    The statistics will not be updated only after disabled.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_value2str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  if (ischosen(statList[pl_statIdx].statData.content)) {
    var charstring vl_stringvalue := f_EPTF_StatMeasure_content2str(pl_statIdx);
    var EPTF_Var_DirectContent vl_content;
    f_EPTF_StatMeasure_getStat_content(pl_statIdx, vl_content);
    if (ischosen(vl_content.charstringVal)){
       vl_stringvalue := "\"" & vl_stringvalue & "\"";
    }
    return vl_stringvalue;
  }
  if (ischosen(statList[pl_statIdx].statData.delta)) {
    return f_EPTF_StatMeasure_delta2str(pl_statIdx);
  }
  if (ischosen(statList[pl_statIdx].statData.deltaSum)) {
    return f_EPTF_StatMeasure_deltaSum2str(pl_statIdx);
  }
  if (ischosen(statList[pl_statIdx].statData.min)) {
    return f_EPTF_StatMeasure_min2str(pl_statIdx);
  }
  if (ischosen(statList[pl_statIdx].statData.max)) {
    return f_EPTF_StatMeasure_max2str(pl_statIdx);
  }
  if (ischosen(statList[pl_statIdx].statData.mean)) {
    return f_EPTF_StatMeasure_mean2str(pl_statIdx);
  }
  if (ischosen(statList[pl_statIdx].statData.standardDev)) {
    return f_EPTF_StatMeasure_standardDev2str(pl_statIdx);
  }
  if (ischosen(statList[pl_statIdx].statData.EPS)) {
    return f_EPTF_StatMeasure_EPS2str(pl_statIdx);
  }
  if (ischosen(statList[pl_statIdx].statData.chrono)) {
    return f_EPTF_StatMeasure_chrono2str(pl_statIdx);
  }
  if (ischosen(statList[pl_statIdx].statData.density)) {
    return f_EPTF_StatMeasure_density2str(pl_statIdx);
  }
  if (ischosen(statList[pl_statIdx].statData.percentileP)) {
    return f_EPTF_StatMeasure_percentileP2str(pl_statIdx);
  }  
  if (ischosen(statList[pl_statIdx].statData.percentile95)) {
    return f_EPTF_StatMeasure_percentile952str(pl_statIdx);
  }
  if (ischosen(statList[pl_statIdx].statData.limits)) {
    return f_EPTF_StatMeasure_limits2str(pl_statIdx);
  }
  if (ischosen(statList[pl_statIdx].statData.custom)) {
    return f_EPTF_StatMeasure_custom2str(pl_statIdx);
  }
  //...
  return "N/A"
}


///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_createVarFromStat
// 
//  Purpose:
//    Creates an EPTF Variable from the given statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_varName - *in* *charstring* - the name of the created variable 
//   (if empty: name is auto-generated). Default: empty
//
//  Return Value:
//    *integer* - idx of the new variable
//
//  Errors:
//    -
//
//  Detailed Comments:
//    The type of the variable is auto-generated according to the type of 
//    the statistics.
//    For auto-generated names the name will be the name generated for 
//    the statistics by the function <f_EPTF_StatMeasure_getStatName>.
//
//    HK52719:
//    If the variable already exits, the variable is reused to store the value of the statistics.
//    The type of the variable should correspond to the type of the statistics in this case!
//    It is not checked in this function.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_createVarFromStat(
  in integer pl_statIdx, 
  in charstring pl_varName := "") 
runs on EPTF_StatMeasure_CT return integer 
{
  if (statList[pl_statIdx].createdVarIdx != -1) 
  {
    f_EPTF_StatMeasure_warning(
      log2str("Variable for the value of stat ", pl_statIdx, " (",
        statList[pl_statIdx],") already exists: ", 
        f_EPTF_Var_getName(statList[pl_statIdx].createdVarIdx)));
    return statList[pl_statIdx].createdVarIdx; // var already created
  }

  var EPTF_StatMeasure_statType vl_statType := 
    f_EPTF_StatMeasure_getStatType(pl_statIdx);
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  var integer vl_newVarIdx;
  if (vl_statType == content) {
    return vl_varIdx;
  }
  
  // assign auto-name:
  var charstring vl_statName := pl_varName;
  if (vl_statName == "") {
    vl_statName := f_EPTF_StatMeasure_getStatName(pl_statIdx);
  }

  vl_varIdx := f_EPTF_Var_getId(vl_statName);
  if (vl_varIdx!=-1) {
    f_EPTF_StatMeasure_debug(%definitionId&": Variable to create already exist: "&vl_statName&". Reused for storing the value of the stat (HK52719).");
    f_EPTF_StatMeasure_registerCreatedVar(pl_statIdx,vl_varIdx);
    // disable adjust of created variables (calcFn is null: prostProc will 
    // do the update, stat will notify the variable):
    f_EPTF_Var_unsubscribe(vl_varIdx);
    f_EPTF_Var_subscribeLocal(vl_varIdx, {calcFn := { null, {}, {} }});
    return vl_varIdx;
  }

  //log("vl_statName: ",vl_statName);
  f_EPTF_StatMeasure_debug("vl_statName: "&vl_statName);
  if (vl_statType == delta) {
    if (ischosen(statList[pl_statIdx].statData.delta.statValue.intVal)){
      f_EPTF_Var_newInt(vl_statName, 
        statList[pl_statIdx].statData.delta.statValue.intVal,vl_newVarIdx);
    } else {
      f_EPTF_Var_newFloat(vl_statName, 
        statList[pl_statIdx].statData.delta.statValue.floatVal,vl_newVarIdx);
    }
  } else if (vl_statType == deltaSum) {
    if (ischosen(statList[pl_statIdx].statData.deltaSum.statValue.intVal)){
      f_EPTF_Var_newInt(vl_statName, 
        statList[pl_statIdx].statData.deltaSum.statValue.intVal,vl_newVarIdx);
    } else {
      f_EPTF_Var_newFloat(vl_statName, 
        statList[pl_statIdx].statData.deltaSum.statValue.floatVal,vl_newVarIdx);
    }
  } else if (vl_statType == min) {
    if (ischosen(statList[pl_statIdx].statData.min.statValue.intVal)){
      f_EPTF_Var_newInt(vl_statName, 
        statList[pl_statIdx].statData.min.statValue.intVal,vl_newVarIdx);
    } else {
      f_EPTF_Var_newFloat(vl_statName, 
        statList[pl_statIdx].statData.min.statValue.floatVal,vl_newVarIdx);
    }
  } else if (vl_statType == max) {
    if (ischosen(statList[pl_statIdx].statData.max.statValue.intVal)){
      f_EPTF_Var_newInt(vl_statName, 
        statList[pl_statIdx].statData.max.statValue.intVal,vl_newVarIdx);
    } else {
      f_EPTF_Var_newFloat(vl_statName, 
        statList[pl_statIdx].statData.max.statValue.floatVal,vl_newVarIdx);
    }
  } else if (vl_statType == mean) {
    f_EPTF_Var_newFloat(vl_statName, 
      statList[pl_statIdx].statData.mean.statValue,vl_newVarIdx);
  } else if (vl_statType == standardDev) {
    f_EPTF_Var_newFloat(vl_statName, 
      statList[pl_statIdx].statData.standardDev.statValue,vl_newVarIdx);
  } else if (vl_statType == EPS) {
    f_EPTF_Var_newFloat(vl_statName, 
      statList[pl_statIdx].statData.EPS.statValue,vl_newVarIdx);
  } else if (vl_statType == chrono) {
    f_EPTF_Var_newFloat(vl_statName, 
      statList[pl_statIdx].statData.chrono.statValue,vl_newVarIdx);
  } else if (vl_statType == density) {
    f_EPTF_Var_newIntegerlist(vl_statName, 
      statList[pl_statIdx].statData.density.statValue,vl_newVarIdx);
  } else if (vl_statType == percentileP) {
    f_EPTF_Var_newFloat(vl_statName, 
      statList[pl_statIdx].statData.percentileP.statValue,vl_newVarIdx);
  } else if (vl_statType == percentile95) {
    f_EPTF_Var_newFloat(vl_statName, 
      statList[ statList[pl_statIdx].statData.percentile95.percentilePIdx ].statData.percentileP.statValue,vl_newVarIdx);
  } else if (vl_statType == limits) {
    f_EPTF_Var_newStatusLED(vl_statName, 
      statList[pl_statIdx].statData.limits.statValue,vl_newVarIdx);
  } else if (vl_statType == custom) {
    vl_newVarIdx := 
      f_EPTF_StatMeasure_createVarFromStat_custom(
        pl_statIdx, vl_statName);
  }
  //...

  // create notification:
  f_EPTF_StatMeasure_registerCreatedVar(pl_statIdx,vl_newVarIdx);
  // disable adjust of created variables (calcFn is null: prostProc will 
  // do the update, stat will notify the variable):
  if (vl_newVarIdx!=-1) {
    f_EPTF_Var_subscribeLocal(vl_newVarIdx, {calcFn := { null, {}, {} }});
  }
  
  return vl_newVarIdx;
}

} // group General

///////////////////////////////////////////////////////////////////////////////
// Group: contentStat
//
// Purpose:
//   Functions for the content stat
//
// Description:
//   The aim of this statistics is to interpret an EPTF_Var as a statistics
///////////////////////////////////////////////////////////////////////////////
group contentStat {


///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStat_content
// 
//  Purpose:
//    Creates a new 'content' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_varIdx - *in* *integer* - the idx of the EPTF variable (-1 is not allowed)
//
//  Return Value:
//    *integer* - the idx of the new statistics (-1 if statistics cannot be created)
//
//  Errors:
//    -
//
//  Detailed Comments:
//    A standalone content statistics cannot be created!
//    This function can be called for any type of var
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStat_content(
  in integer pl_varIdx) 
runs on EPTF_StatMeasure_CT return integer 
{
  if (pl_varIdx==-1) 
  {
    f_EPTF_StatMeasure_warning(
      "It is not allowed to create standalone content statistics!");
    return -1;
  }
  
  var integer vl_newStatIdx := sizeof(statList);
  statList[vl_newStatIdx] := { pl_varIdx, -1, {content := {}}, true, true }; // always enabled
  return vl_newStatIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStat_content
// 
//  Purpose:
//    Reset 'content' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    This function can be called for any type of stats
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStat_content(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  // nothing to do (cannot reset)
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initStatValue_content
// 
//  Purpose:
//    Initializes the value of 'content' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//   This function can be called for any type of stats
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_initStatValue_content(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  // nothing to do (cannot init)
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_enableStat_content
// 
//  Purpose:
//    Enable 'content' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    This function can be called for any type of stats
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_enableStat_content(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  // nothing to do: stat is always enabled
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_disableStat_content
// 
//  Purpose:
//    Disable 'content' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    This function can be called for any type of stats
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_disableStat_content(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  // nothing to do: cannot disable stat
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_content
// 
//  Purpose:
//    Returns the value of the 'content' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_statValue - *out* <EPTF_Var_DirectContent> - the value of the stat
//
//  Return Value:
//    *boolean* - true if stat is available, false if no
//
//  Errors:
//    -
//
//  Detailed Comments:
//    This function can be called for any type of stats
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_content(
  in integer pl_statIdx, 
  out EPTF_Var_DirectContent pl_statValue) 
runs on EPTF_StatMeasure_CT 
{
  //f_EPTF_Base_assert(ischosen(statList[pl_statIdx].statData.content));
  f_EPTF_Var_getContent(f_EPTF_StatMeasure_getVarIdx(pl_statIdx),pl_statValue);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_content2str
// 
//  Purpose:
//    Returns the value of the 'content' statistics as a charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *charstring* - the value of the statistics as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    This function can be called for any type of stats
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_content2str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  return f_EPTF_Var_content2str(f_EPTF_StatMeasure_getVarIdx(pl_statIdx));
}

} // group contentStat

///////////////////////////////////////////////////////////////////////////////
// Group: deltaStat
//
// Purpose:
//   Functions for the delta stat
//
// Description:
//   The aim of this statistics is to measure the difference between two
//   subsequent data values
///////////////////////////////////////////////////////////////////////////////
group deltaStat {


///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStat_delta
// 
//  Purpose:
//    Creates a new 'delta' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_varIdx - *in* *integer* - the idx of the EPTF variable (its type should be integer or float)
//          (-1 to create stat without a variable). Default: -1
//
//  Return Value:
//    *integer* - the idx of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    The type of the statistics is set to integer by default!
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStat_delta(
  in integer pl_varIdx := -1) 
runs on EPTF_StatMeasure_CT return integer 
{
  var integer vl_newStatIdx := sizeof(statList);
  statList[vl_newStatIdx] := { 
    pl_varIdx, -1, {delta := { {intVal := 0}, {intVal := 0}}}, false, true 
  };
  
  // change content to float if source variable is float
  if (pl_varIdx!=-1) {
    var EPTF_Var_DirectContent vl_contentNew;
    f_EPTF_Var_getContent(pl_varIdx,vl_contentNew);
    if (ischosen(vl_contentNew.floatVal)) {
      statList[vl_newStatIdx].statData.delta := { {floatVal := 0.0}, {floatVal := 0.0} };
    }
  }
  
  f_EPTF_StatMeasure_resetStat_delta(vl_newStatIdx);
  // enable the stat:
  f_EPTF_StatMeasure_enableStat_delta(vl_newStatIdx);
  return vl_newStatIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStat_delta
// 
//  Purpose:
//    Reset 'delta' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStat_delta(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  statList[pl_statIdx].reset := true;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initStatValue_delta
// 
//  Purpose:
//    Initializes the value of 'delta' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Stat is initialized with zero.
//    The created variable is also updated. 
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_initStatValue_delta(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_resetStat_delta(pl_statIdx)
  
  if (ischosen(statList[pl_statIdx].statData.delta.statValue.intVal)) {
    statList[pl_statIdx].statData.delta := { {intVal := 0}, {intVal := 0} };
  }
  else if (ischosen(statList[pl_statIdx].statData.delta.statValue.floatVal)) {
    statList[pl_statIdx].statData.delta := { {floatVal := 0.0}, {floatVal := 0.0} };
  }
  
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_changeToFloat_delta
// 
//  Purpose:
//    Changes the type of a new 'delta' statistics to float.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//
//  Errors:
//    If addData was already called, this function stops with an error.
//
//  Detailed Comments:
//    The type of a statistics created form a variable (i.e. not standalone)
//    cannot be changed.
//    This function should be called right after the statistics was created,
//    if the type of the statistics should be float. Note, that the type is
//    changed to float automatically if needed when the first data is added.
//    However, if a variable should be created from the statistics, but no
//    data was added, this function has to be called!
//    After a variable was created form the statistics, or a statistics was
//    created from a variable (i.e. not standalone), this function cannot
//    be called!
//    This function can be called only after the statistics was reset.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_changeToFloat_delta(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if(f_EPTF_StatMeasure_getVarIdx(pl_statIdx) != -1) {
    f_EPTF_StatMeasure_error(log2str("Cannot change the type to float of the stat ", pl_statIdx,
      ": The statistics is not a standalone stat"));
    f_EPTF_Base_stop();
  }
  if(f_EPTF_StatMeasure_getCreatedVarIdx(pl_statIdx) != -1) {
    f_EPTF_StatMeasure_error(log2str("Cannot change the type to float of the stat ", pl_statIdx,
      ": A variable was created from the statistics"));
    f_EPTF_Base_stop();
  }
  if (not statList[pl_statIdx].reset) {
    f_EPTF_StatMeasure_error(log2str("Cannot change the type to float of the stat ", pl_statIdx,
      ": The statistics was not reset"));
    f_EPTF_Base_stop();
  }
  statList[pl_statIdx].statData.delta := { {floatVal := 0.0}, {floatVal := 0.0} };
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_addData_delta
// 
//  Purpose:
//    Add new data for the 'delta' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was given when the statistics was created, 
//    this function can be used to add new data.
//    If the statistics was created for an existing EPTF Variable data will be
//    automatically added when the value of the variable is refreshed. But 
//    this function can be used to add additional data also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_addData_delta(
  in integer pl_statIdx, 
  in EPTF_Var_DirectContent pl_newData) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.delta));

  if (statList[pl_statIdx].reset) {
    statList[pl_statIdx].reset := false;
    // first value:
    if (ischosen(pl_newData.intVal)) {
      statList[pl_statIdx].statData.delta := {pl_newData, {intVal := 0}};
    } else if (ischosen(pl_newData.floatVal)) {
      statList[pl_statIdx].statData.delta := {pl_newData, {floatVal := 0.0}};
    }
    statList[pl_statIdx].statData.delta.prevContent := pl_newData;
    f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
    return;
  }

  if (ischosen(statList[pl_statIdx].statData.delta.statValue.intVal)) 
  {
    statList[pl_statIdx].statData.delta.statValue.intVal := 
      pl_newData.intVal - statList[pl_statIdx].statData.delta.prevContent.intVal;
  } else if (ischosen(statList[pl_statIdx].statData.delta.statValue.floatVal)) 
  {
    statList[pl_statIdx].statData.delta.statValue.floatVal := 
      pl_newData.floatVal - statList[pl_statIdx].statData.delta.prevContent.floatVal;
  }
  
  statList[pl_statIdx].statData.delta.prevContent := pl_newData;
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_enableStat_delta
// 
//  Purpose:
//    Enable 'delta' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_enableStat_delta(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := true;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.delta));

  f_EPTF_Var_addPostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_delta_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_disableStat_delta
// 
//  Purpose:
//    Disable 'delta' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_disableStat_delta(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }

  statList[pl_statIdx].enabled := false;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Var_removePostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_delta_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_delta
// 
//  Purpose:
//    Returns the value of the 'delta' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_statValue - *out* <EPTF_Var_DirectContent> - the value of the stat
//
//  Return Value:
//    *boolean* - true if stat is available, false if no
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_delta(
  in integer pl_statIdx, 
  out EPTF_Var_DirectContent pl_statValue) 
runs on EPTF_StatMeasure_CT return boolean 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.delta));
  
  pl_statValue := statList[pl_statIdx].statData.delta.statValue;
  return f_EPTF_StatMeasure_valueIsAvailable(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_delta2str
// 
//  Purpose:
//    Returns the value of the 'delta' statistics as a charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *charstring* - the value of the statistics as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_delta2str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  var EPTF_Var_DirectContent vl_currentContent;
  if (f_EPTF_StatMeasure_getStat_delta(pl_statIdx, vl_currentContent)) {
    return f_EPTF_Var_directContent2str(vl_currentContent);
  } else {
    return "N/A";
  }
}

} // group deltaStat

///////////////////////////////////////////////////////////////////////////////
// Group: deltaSumStat
//
// Purpose:
//   Functions for the deltaSum stat
//
// Description:
//   The aim of this statistics is to measure the difference between the initial
//   and the current data values
///////////////////////////////////////////////////////////////////////////////
group deltaSumStat {


///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStat_deltaSum
// 
//  Purpose:
//    Creates a new 'deltaSum' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_varIdx - *in* *integer* - the idx of the EPTF variable (its type should be integer or float) 
//     (-1 to create stat without a variable). Default: -1
//
//  Return Value:
//    *integer* - the idx of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    The type of the statistics is set to integer by default!
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStat_deltaSum(
  in integer pl_varIdx := -1) 
runs on EPTF_StatMeasure_CT return integer 
{
  var integer vl_newStatIdx := sizeof(statList);
  statList[vl_newStatIdx] := { pl_varIdx, -1, 
    {deltaSum := { {intVal := 0}, {intVal := 0}}}, false, true };

  // change content to float if source variable is float
  if (pl_varIdx!=-1) {
    var EPTF_Var_DirectContent vl_contentNew;
    f_EPTF_Var_getContent(pl_varIdx,vl_contentNew);
    if (ischosen(vl_contentNew.floatVal)) {
      statList[vl_newStatIdx].statData.deltaSum := { {floatVal := 0.0}, {floatVal := 0.0} };
    }
  }
  
  f_EPTF_StatMeasure_resetStat_deltaSum(vl_newStatIdx);
  // enable the stat:
  f_EPTF_StatMeasure_enableStat_deltaSum(vl_newStatIdx);
  
  return vl_newStatIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStat_deltaSum
// 
//  Purpose:
//    Reset 'deltaSum' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStat_deltaSum(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  statList[pl_statIdx].reset := true;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initStatValue_deltaSum
// 
//  Purpose:
//    Initializes the value of 'deltaSum' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Stat is initialized with zero.
//    The created variable is also updated. 
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_initStatValue_deltaSum(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_resetStat_deltaSum(pl_statIdx);

  if (ischosen(statList[pl_statIdx].statData.deltaSum.statValue.intVal)) {
    statList[pl_statIdx].statData.deltaSum := { {intVal := 0}, {intVal := 0} };
  }
  else if (ischosen(statList[pl_statIdx].statData.deltaSum.statValue.floatVal)) {
    statList[pl_statIdx].statData.deltaSum := { {floatVal := 0.0}, {floatVal := 0.0} };
  }
  
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_changeToFloat_deltaSum
// 
//  Purpose:
//    Changes the type of a new 'deltaSum' statistics to float.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//
//  Errors:
//    If addData was already called, this function stops with an error.
//
//  Detailed Comments:
//    The type of a statistics created form a variable (i.e. not standalone)
//    cannot be changed.
//    This function should be called right after the statistics was created,
//    if the type of the statistics should be float. Note, that the type is
//    changed to float automatically if needed when the first data is added.
//    However, if a variable should be created from the statistics, but no
//    data was added, this function has to be called!
//    After a variable was created form the statistics, or a statistics was
//    created from a variable (i.e. not standalone), this function cannot
//    be called!
//    This function can be called only after the statistics was reset.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_changeToFloat_deltaSum(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if(f_EPTF_StatMeasure_getVarIdx(pl_statIdx) != -1) {
    f_EPTF_StatMeasure_error(log2str("Cannot change the type to float of the stat ", pl_statIdx,
      ": The statistics is not a standalone stat"));
    f_EPTF_Base_stop();
  }
  if(f_EPTF_StatMeasure_getCreatedVarIdx(pl_statIdx) != -1) {
    f_EPTF_StatMeasure_error(log2str("Cannot change the type to float of the stat ", pl_statIdx,
      ": A variable was created from the statistics"));
    f_EPTF_Base_stop();
  }
  if (not statList[pl_statIdx].reset) {
    f_EPTF_StatMeasure_error(log2str("Cannot change the type to float of the stat ", pl_statIdx,
      ": The statistics was not reset"));
    f_EPTF_Base_stop();
  }
  statList[pl_statIdx].statData.deltaSum := { {floatVal := 0.0}, {floatVal := 0.0} };
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_addData_deltaSum
// 
//  Purpose:
//    Add new data for the 'deltaSum' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was given when the statistics was created, this function 
//    can be used to add new data.
//    If the statistics was created for an existing EPTF Variable data will be
//    automatically added when the value of the variable is refreshed. 
//    But this function can be used to add additional data also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_addData_deltaSum(
  in integer pl_statIdx, 
  in EPTF_Var_DirectContent pl_newData) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }

  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.deltaSum));

  if (statList[pl_statIdx].reset) {
    statList[pl_statIdx].reset:=false;
    // first value:
    if (ischosen(pl_newData.intVal)) {
      statList[pl_statIdx].statData.deltaSum := {pl_newData, {intVal := 0}};
    } else if (ischosen(pl_newData.floatVal)) {
      statList[pl_statIdx].statData.deltaSum := {pl_newData, {floatVal := 0.0}};
    }
    statList[pl_statIdx].statData.deltaSum.iniContent := pl_newData;
    f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
    return;
  }

  if (ischosen(statList[pl_statIdx].statData.deltaSum.statValue.intVal)) 
  {
    statList[pl_statIdx].statData.deltaSum.statValue.intVal := 
      pl_newData.intVal - statList[pl_statIdx].statData.deltaSum.iniContent.intVal;
  } else if (ischosen(statList[pl_statIdx].statData.deltaSum.statValue.floatVal)) 
  {
    statList[pl_statIdx].statData.deltaSum.statValue.floatVal := 
      pl_newData.floatVal - statList[pl_statIdx].statData.deltaSum.iniContent.floatVal;
  }
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_enableStat_deltaSum
// 
//  Purpose:
//    Enable 'deltaSum' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_enableStat_deltaSum(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := true;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.deltaSum));

  f_EPTF_Var_addPostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_deltaSum_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_disableStat_deltaSum
// 
//  Purpose:
//    Disable 'deltaSum' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_disableStat_deltaSum(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := false;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Var_removePostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_deltaSum_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_deltaSum
// 
//  Purpose:
//    Returns the value of the 'deltaSum' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_statValue - *out* <EPTF_Var_DirectContent> - the value of the stat
//
//  Return Value:
//    *boolean* - true if stat is available, false if no
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_deltaSum(
  in integer pl_statIdx, 
  out EPTF_Var_DirectContent pl_statValue) 
runs on EPTF_StatMeasure_CT return boolean 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.deltaSum));
  
  pl_statValue := statList[pl_statIdx].statData.deltaSum.statValue;
  return f_EPTF_StatMeasure_valueIsAvailable(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_deltaSum2str
// 
//  Purpose:
//    Returns the value of the 'deltasum' statistics as a charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *charstring* - the value of the statistics as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_deltaSum2str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  var EPTF_Var_DirectContent vl_currentContent;
  if (f_EPTF_StatMeasure_getStat_deltaSum(pl_statIdx, vl_currentContent)) {
    return f_EPTF_Var_directContent2str(vl_currentContent);
  } else {
    return "N/A";
  }
}

} // group deltaSumStat

///////////////////////////////////////////////////////////////////////////////
// Group: minStat
//
// Purpose:
//   Functions for the min stat
//
// Description:
//   The aim of this statistics is to measure the minimum of the data values
///////////////////////////////////////////////////////////////////////////////
group minStat {


///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStat_min
// 
//  Purpose:
//    Creates a new 'min' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_varIdx - *in* *integer* - the idx of the EPTF variable (its type should be integer or float)
//          (-1 to create stat without a variable). Default: -1
//
//  Return Value:
//    *integer* - the idx of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    The type of the statistics is set to integer by default!
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStat_min(
  in integer pl_varIdx := -1) 
runs on EPTF_StatMeasure_CT return integer 
{
  var integer vl_newStatIdx := sizeof(statList);
  statList[vl_newStatIdx] := { pl_varIdx, -1, 
    {min := { {intVal := 0}}}, false, true };
    
  // change content to float if source variable is float
  if (pl_varIdx!=-1) {
    var EPTF_Var_DirectContent vl_contentNew;
    f_EPTF_Var_getContent(pl_varIdx,vl_contentNew);
    if (ischosen(vl_contentNew.floatVal)) {
      statList[vl_newStatIdx].statData.min := {{floatVal := 0.0}};
    }
  }
  
  f_EPTF_StatMeasure_resetStat_min(vl_newStatIdx);
  // enable the stat:
  f_EPTF_StatMeasure_enableStat_min(vl_newStatIdx);
  return vl_newStatIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStat_min
// 
//  Purpose:
//    Reset 'min' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStat_min(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  statList[pl_statIdx].reset := true;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initStatValue_min
// 
//  Purpose:
//    Initializes the value of 'min' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Stat is initialized with zero.
//    The created variable is also updated. 
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_initStatValue_min(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_resetStat_min(pl_statIdx);

  if (ischosen(statList[pl_statIdx].statData.min.statValue.intVal)) {
    statList[pl_statIdx].statData.min := { { intVal := 0 } };
  }
  else if (ischosen(statList[pl_statIdx].statData.min.statValue.floatVal)) {
    statList[pl_statIdx].statData.min :=  { { floatVal := 0.0 } };
  }
  
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_changeToFloat_min
// 
//  Purpose:
//    Changes the type of a new 'min' statistics to float.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//
//  Errors:
//    If addData was already called, this function stops with an error.
//
//  Detailed Comments:
//    The type of a statistics created form a variable (i.e. not standalone)
//    cannot be changed.
//    This function should be called right after the statistics was created,
//    if the type of the statistics should be float. Note, that the type is
//    changed to float automatically if needed when the first data is added.
//    However, if a variable should be created from the statistics, but no
//    data was added, this function has to be called!
//    After a variable was created form the statistics, or a statistics was
//    created from a variable (i.e. not standalone), this function cannot
//    be called!
//    This function can be called only after the statistics was reset.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_changeToFloat_min(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if(f_EPTF_StatMeasure_getVarIdx(pl_statIdx) != -1) {
    f_EPTF_StatMeasure_error(log2str("Cannot change the type to float of the stat ", pl_statIdx,
      ": The statistics is not a standalone stat"));
    f_EPTF_Base_stop();
  }
  if(f_EPTF_StatMeasure_getCreatedVarIdx(pl_statIdx) != -1) {
    f_EPTF_StatMeasure_error(log2str("Cannot change the type to float of the stat ", pl_statIdx,
      ": A variable was created from the statistics"));
    f_EPTF_Base_stop();
  }
  if (not statList[pl_statIdx].reset) {
    f_EPTF_StatMeasure_error(log2str("Cannot change the type to float of the stat ", pl_statIdx,
      ": The statistics was not reset"));
    f_EPTF_Base_stop();
  }
  statList[pl_statIdx].statData.min := {{floatVal := 0.0}};
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_addData_min
// 
//  Purpose:
//    Add new data for the 'min' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was given when the statistics was created, 
//    this function can be used to add new data.
//    If the statistics was created for an existing EPTF Variable data will be
//    automatically added when the value of the variable is refreshed. 
//    But this function can be used to add additional data also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_addData_min(
  in integer pl_statIdx, 
  in EPTF_Var_DirectContent pl_newData) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.min));
  
  if (statList[pl_statIdx].reset) {
    statList[pl_statIdx].reset := false;
    statList[pl_statIdx].statData.min := {pl_newData};
    f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
    return;
  }

  if (ischosen(statList[pl_statIdx].statData.min.statValue.intVal)) {
    if (pl_newData.intVal<statList[pl_statIdx].statData.min.statValue.intVal) {
      statList[pl_statIdx].statData.min.statValue.intVal := pl_newData.intVal;
    }
  } else if (ischosen(statList[pl_statIdx].statData.min.statValue.floatVal)) {
    if (pl_newData.floatVal<statList[pl_statIdx].statData.min.statValue.floatVal) {
      statList[pl_statIdx].statData.min.statValue.floatVal := pl_newData.floatVal;
    }
  }
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_enableStat_min
// 
//  Purpose:
//    Enable 'min' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_enableStat_min(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := true;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.min));

  f_EPTF_Var_addPostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_min_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_disableStat_min
// 
//  Purpose:
//    Disable 'min' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_disableStat_min(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := false;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Var_removePostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_min_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_min
// 
//  Purpose:
//    Returns the value of the 'min' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_statValue - *out* <EPTF_Var_DirectContent> - the value of the stat
//
//  Return Value:
//    *boolean* - true if stat is available, false if no
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_min(
  in integer pl_statIdx, 
  out EPTF_Var_DirectContent pl_statValue) 
runs on EPTF_StatMeasure_CT return boolean 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.min));
  
  pl_statValue := statList[pl_statIdx].statData.min.statValue;
  return f_EPTF_StatMeasure_valueIsAvailable(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_min2str
// 
//  Purpose:
//    Returns the value of the 'min' statistics as a charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *charstring* - the value of the statistics as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_min2str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  var EPTF_Var_DirectContent vl_currentContent;
  if (f_EPTF_StatMeasure_getStat_min(pl_statIdx, vl_currentContent)) {
    return f_EPTF_Var_directContent2str(vl_currentContent);
  } else {
    return "N/A";
  }
}

} // group minStat

///////////////////////////////////////////////////////////////////////////////
// Group: maxStat
//
// Purpose:
//   Functions for the max stat
//
// Description:
//   The aim of this statistics is to measure the maximum of the data values
///////////////////////////////////////////////////////////////////////////////
group maxStat {


///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStat_max
// 
//  Purpose:
//    Creates a new 'max' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_varIdx - *in* *integer* - the idx of the EPTF variable (its type should be integer or float)
//          (-1 to create stat without a variable). Default: -1
//
//  Return Value:
//    *integer* - the idx of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    The type of the statistics is set to integer by default!
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStat_max(
  in integer pl_varIdx := -1) 
runs on EPTF_StatMeasure_CT return integer 
{
  var integer vl_newStatIdx := sizeof(statList);
  statList[vl_newStatIdx] := 
  { pl_varIdx, -1, {max := { {intVal := 0}}}, false, true };

  // change content to float if source variable is float
  if (pl_varIdx!=-1) {
    var EPTF_Var_DirectContent vl_contentNew;
    f_EPTF_Var_getContent(pl_varIdx,vl_contentNew);
    if (ischosen(vl_contentNew.floatVal)) {
      statList[vl_newStatIdx].statData.max := {{floatVal := 0.0}};
    }
  }
  
  f_EPTF_StatMeasure_resetStat_max(vl_newStatIdx);
  // enable the stat:
  f_EPTF_StatMeasure_enableStat_max(vl_newStatIdx);
  
  return vl_newStatIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_changeToFloat_max
// 
//  Purpose:
//    Changes the type of a new 'max' statistics to float.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//
//  Errors:
//    If addData was already called, this function stops with an error.
//
//  Detailed Comments:
//    The type of a statistics created form a variable (i.e. not standalone)
//    cannot be changed.
//    This function should be called right after the statistics was created,
//    if the type of the statistics should be float. Note, that the type is
//    changed to float automatically if needed when the first data is added.
//    However, if a variable should be created from the statistics, but no
//    data was added, this function has to be called!
//    After a variable was created form the statistics, or a statistics was
//    created from a variable (i.e. not standalone), this function cannot
//    be called!
//    This function can be called only after the statistics was reset.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_changeToFloat_max(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if(f_EPTF_StatMeasure_getVarIdx(pl_statIdx) != -1) {
    f_EPTF_StatMeasure_error(log2str("Cannot change the type to float of the stat ", pl_statIdx,
      ": The statistics is not a standalone stat"));
    f_EPTF_Base_stop();
  }
  if(f_EPTF_StatMeasure_getCreatedVarIdx(pl_statIdx) != -1) {
    f_EPTF_StatMeasure_error(log2str("Cannot change the type to float of the stat ", pl_statIdx,
      ": A variable was created from the statistics"));
    f_EPTF_Base_stop();
  }
  if (not statList[pl_statIdx].reset) {
    f_EPTF_StatMeasure_error(log2str("Cannot change the type to float of the stat ", pl_statIdx,
      ": The statistics was not reset"));
    f_EPTF_Base_stop();
  }
  statList[pl_statIdx].statData.max := {{floatVal := 0.0}};
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStat_max
// 
//  Purpose:
//    Reset 'max' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStat_max(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  statList[pl_statIdx].reset := true;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initStatValue_max
// 
//  Purpose:
//    Initializes the value of 'max' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Stat is initialized with zero.
//    The created variable is also updated. 
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_initStatValue_max(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_resetStat_max(pl_statIdx);

  if (ischosen(statList[pl_statIdx].statData.max.statValue.intVal)) {
    statList[pl_statIdx].statData.max := { {intVal := 0} };
  }
  else if (ischosen(statList[pl_statIdx].statData.max.statValue.floatVal)) {
    statList[pl_statIdx].statData.max := { {floatVal := 0.0} };
  }
  
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_addData_max
// 
//  Purpose:
//    Add new data for the 'max' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was given when the statistics was created, 
//    this function can be used to add new data.
//    If the statistics was created for an existing EPTF Variable data will be
//    automatically added when the value of the variable is refreshed. 
//    But this function can be used to add additional data also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_addData_max(
  in integer pl_statIdx, 
  in EPTF_Var_DirectContent pl_newData) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.max));
  
  if (statList[pl_statIdx].reset) {
    statList[pl_statIdx].reset:=false;
    statList[pl_statIdx].statData.max := {pl_newData};
    f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
    return;
  }

  if (ischosen(statList[pl_statIdx].statData.max.statValue.intVal)) {
    if (pl_newData.intVal>statList[pl_statIdx].statData.max.statValue.intVal) {
      statList[pl_statIdx].statData.max.statValue.intVal := pl_newData.intVal;
    }
  } else if (ischosen(statList[pl_statIdx].statData.max.statValue.floatVal)) {
    if (pl_newData.floatVal>statList[pl_statIdx].statData.max.statValue.floatVal) {
      statList[pl_statIdx].statData.max.statValue.floatVal := pl_newData.floatVal;
    }
  }
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_enableStat_max
// 
//  Purpose:
//    Enable 'max' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_enableStat_max(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := true;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.max));

  f_EPTF_Var_addPostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_max_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_disableStat_max
// 
//  Purpose:
//    Disable 'max' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_disableStat_max(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := false;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Var_removePostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_max_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_max
// 
//  Purpose:
//    Returns the value of the 'max' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_statValue - *out* <EPTF_Var_DirectContent> - the value of the stat
//
//  Return Value:
//    *boolean* - true if stat is available, false if no
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_max(
  in integer pl_statIdx, 
  out EPTF_Var_DirectContent pl_statValue) 
runs on EPTF_StatMeasure_CT return boolean 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.max));
  
  pl_statValue := statList[pl_statIdx].statData.max.statValue;
  return f_EPTF_StatMeasure_valueIsAvailable(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_max2str
// 
//  Purpose:
//    Returns the value of the 'max' statistics as a charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *charstring* - the value of the statistics as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_max2str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  var EPTF_Var_DirectContent vl_currentContent;
  if (f_EPTF_StatMeasure_getStat_max(pl_statIdx, vl_currentContent)) {
    return f_EPTF_Var_directContent2str(vl_currentContent);
  } else {
    return "N/A";
  }
}

} // group maxStat

///////////////////////////////////////////////////////////////////////////////
// Group: meanStat
//
// Purpose:
//   Functions for the mean stat
//
// Description:
//   The aim of this statistics is to measure the mean of the data values
///////////////////////////////////////////////////////////////////////////////
group meanStat {


///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStat_mean
// 
//  Purpose:
//    Creates a new 'mean' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_varIdx - *in* *integer* - the idx of the EPTF variable (its type should be integer or float)
//          (-1 to create stat without a variable). Default: -1
//
//  Return Value:
//    *integer* - the idx of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStat_mean(
  in integer pl_varIdx := -1) 
runs on EPTF_StatMeasure_CT return integer 
{
  var integer vl_newStatIdx := sizeof(statList);
  statList[vl_newStatIdx] := { pl_varIdx, -1, 
    {mean := { 0, 0.0, 0.0, 0.0 }}, false, true };
  
  f_EPTF_StatMeasure_resetStat_mean(vl_newStatIdx);
  // enable the stat:
  f_EPTF_StatMeasure_enableStat_mean(vl_newStatIdx);
  return vl_newStatIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStat_mean
// 
//  Purpose:
//    Reset 'mean' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStat_mean(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  statList[pl_statIdx].reset := true;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initStatValue_mean
// 
//  Purpose:
//    Initializes the value of 'mean' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Stat is initialized with zero.
//    The created variable is also updated. 
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_initStatValue_mean(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_resetStat_mean(pl_statIdx);

  statList[pl_statIdx].statData.mean := { 0, 0.0, 0.0, 0.0 };
  
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_addData_mean
// 
//  Purpose:
//    Add new data for the 'mean' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was given when the statistics was created, 
//    this function can be used to add new data.
//    If the statistics was created for an existing EPTF Variable data will be
//    automatically added when the value of the variable is refreshed.
//     But this function can be used to add additional data also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_addData_mean(
  in integer pl_statIdx, 
  in float pl_newData) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.mean));

  if (statList[pl_statIdx].reset) {
    statList[pl_statIdx].reset := false;
    statList[pl_statIdx].statData.mean := {0, 0.0, 0.0, 0.0};
    f_EPTF_StatMeasure_addData_mean(pl_statIdx,pl_newData);
    return;
  }

  var float x, delta;
  x := pl_newData;
  delta := x - statList[pl_statIdx].statData.mean.statValue;
  statList[pl_statIdx].statData.mean.x := x;
  statList[pl_statIdx].statData.mean.delta := delta;
  statList[pl_statIdx].statData.mean.n := statList[pl_statIdx].statData.mean.n + 1;
  statList[pl_statIdx].statData.mean.statValue := 
    statList[pl_statIdx].statData.mean.statValue + 
    delta/int2float(statList[pl_statIdx].statData.mean.n);
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_enableStat_mean
// 
//  Purpose:
//    Enable 'mean' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_enableStat_mean(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := true;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.mean));

  f_EPTF_Var_addPostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_mean_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_disableStat_mean
// 
//  Purpose:
//    Disable 'mean' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_disableStat_mean(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := false;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Var_removePostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_mean_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_mean
// 
//  Purpose:
//    Returns the value of the 'mean' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_statValue - *out* <EPTF_Var_DirectContent> - the value of the stat
//
//  Return Value:
//    *boolean* - true if stat is available, false if no
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_mean(
  in integer pl_statIdx, 
  out float pl_statValue) 
runs on EPTF_StatMeasure_CT return boolean 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.mean));
  
  pl_statValue := statList[pl_statIdx].statData.mean.statValue;
  return f_EPTF_StatMeasure_valueIsAvailable(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_mean2str
// 
//  Purpose:
//    Returns the value of the 'mean' statistics as a charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *charstring* - the value of the statistics as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_mean2str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  var float vl_currentContent;
  if (f_EPTF_StatMeasure_getStat_mean(pl_statIdx, vl_currentContent)) {
    return float2str(vl_currentContent);
  } else {
    return "N/A";
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_createVarFromStat_N_mean
// 
//  Purpose:
//    Creates EPTF variable from auxuliary data N (i.e. the number of data samples) of the 'mean' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the mean stat
//    pl_varName - *in* *charstring* - the name of the created variable 
//                   (if empty: name is auto-generated). Default: empty
//
//  Return Value:
//    *integer* - the idx of the EPTF Variable that contains the number of data samples
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was created from the statistics, it creates that variable also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_createVarFromStat_N_mean(
  in integer pl_statIdx,
  in charstring pl_varName := ""
) runs on EPTF_StatMeasure_CT return integer
{
  // check type of stat:
  f_EPTF_Base_assert(%definitionId&": Invalid stat type: mean expected",
    ischosen(statList[pl_statIdx].statData.mean));
  
  var integer vl_nDataVarIdx;
  var integer vl_statVarIdx := f_EPTF_StatMeasure_getCreatedVarIdx(pl_statIdx);
  if (vl_statVarIdx==-1) {
    f_EPTF_StatMeasure_warning(%definitionId&": No variable was created from the mean stat. Creating var automatically");
    vl_statVarIdx := f_EPTF_StatMeasure_createVarFromStat(pl_statIdx);
  }

  // creating aux variable:
  var charstring vl_statName := f_EPTF_StatMeasure_getStatName(pl_statIdx);
  var charstring vl_varName := pl_varName;
  if (vl_varName=="") {
    vl_varName := "StatAux.n."&vl_statName;
  }

  vl_nDataVarIdx := f_EPTF_Var_getId(vl_varName);
  if (vl_nDataVarIdx!=-1) {
    return vl_nDataVarIdx; // var already created
  }

  f_EPTF_Var_newInt(vl_varName,0, vl_nDataVarIdx); // aux var for N
  
  // add calcFn to calculate its value:
  f_EPTF_Var_subscribeLocal(
    vl_nDataVarIdx,
    {
      calcFn := {
        funcRef := refers(f_EPTF_StatMeasure_getN_MeanStat_CalcFn),
        argList := {vl_statVarIdx}, // the varible created from the mean stat
        nonVarArgList := {pl_statIdx} // index of the mean statistics
      }
    }
  );
  return vl_nDataVarIdx;
  //f_EPTF_Var_newFloat("StatAux.sum."&vl_statName,0.0,pl_sumDataVarIdx); // aux var for sum
  //f_EPTF_Var_subscribeLocal(
  //  pl_sumDataVarIdx,
  //  {
  //    calcFn := {
  //      funcRef := refers(f_EPTF_StatMeasure_getSum_MeanStat_CalcFn),
  //      argList := {vl_statVarIdx}, // the varible created from the mean stat
  //      nonVarArgList := {pl_statIdx} // index of the mean statistics
  //    }
  //  }
  //);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getN_MeanStat_CalcFn
// 
//  Purpose:
//    calcFn that calculates the number of Data for mean stat
//
//  Parameters:
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    mean stat Id : pl_nonVarArgList[0]
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_getN_MeanStat_CalcFn(
  in integer pl_idx,
  in EPTF_IntegerList pl_argList,
  in EPTF_IntegerList pl_nonVarArgList,
  inout EPTF_Var_DirectContent pl_retVal
) runs on EPTF_StatMeasure_CT {
  var integer vl_statId := pl_nonVarArgList[0];
  pl_retVal := { intVal := statList[vl_statId].statData.mean.n };
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getSum_MeanStat_CalcFn
// 
//  Purpose:
//    calcFn that calculates the sum of Data for mean stat
//
//  Parameters:
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    mean stat Id : pl_nonVarArgList[0]
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_getSum_MeanStat_CalcFn(
  in integer pl_idx,
  in EPTF_IntegerList pl_argList,
  in EPTF_IntegerList pl_nonVarArgList,
  inout EPTF_Var_DirectContent pl_retVal
) runs on EPTF_StatMeasure_CT {
  var integer vl_statId := pl_nonVarArgList[0];
  pl_retVal := { floatVal := int2float(statList[vl_statId].statData.mean.n) * statList[vl_statId].statData.mean.statValue};
}


} // group meanStat

///////////////////////////////////////////////////////////////////////////////
// Group: standardDevStat
//
// Purpose:
//   Functions for the standardDev stat
//
// Description:
//   The aim of this statistics is to measure the standard deviation of the data values
///////////////////////////////////////////////////////////////////////////////
group standardDevStat {


///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStat_standardDev
// 
//  Purpose:
//    Creates a new 'standardDev' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_varIdx - *in* *integer* - the idx of the EPTF variable 
//          (-1 to create stat without a variable). Default: -1
//
//  Return Value:
//    *integer* - the idx of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Creates a mean stat also. It can be accessed by 
//      <f_EPTF_StatMeasure_getStat_standardDev_mean>.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStat_standardDev(
  in integer pl_varIdx := -1) 
runs on EPTF_StatMeasure_CT return integer 
{
  // create the mean stat also for standardDev:
  var integer vl_meanIdx := f_EPTF_StatMeasure_newStat_mean(pl_varIdx);
  f_EPTF_StatMeasure_disableStat_mean(vl_meanIdx); // disable mean: the standardDev's updateFunction will update it

  var integer vl_newStatIdx := sizeof(statList);

  statList[vl_newStatIdx] := { pl_varIdx, -1, 
    {standardDev := { vl_meanIdx, 0.0, 0.0 }}, false, true };
  
  f_EPTF_StatMeasure_resetStat_standardDev(vl_newStatIdx);
  // enable the stat:
  f_EPTF_StatMeasure_enableStat_standardDev(vl_newStatIdx);
  return vl_newStatIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStat_standardDev
// 
//  Purpose:
//    Reset 'standardDev' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStat_standardDev(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  statList[pl_statIdx].reset := true;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initStatValue_standardDev
// 
//  Purpose:
//    Initializes the value of 'standardDev' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Stat is initialized with zero.
//    The created variable is also updated. 
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_initStatValue_standardDev(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_resetStat_standardDev(pl_statIdx);

  var integer vl_meanIdx := statList[pl_statIdx].statData.standardDev.meanIdx;
  statList[pl_statIdx].statData.standardDev := { vl_meanIdx, 0.0, 0.0 };
  
  f_EPTF_StatMeasure_initStatValue(vl_meanIdx);
  
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_addData_standardDev
// 
//  Purpose:
//    Add new data for the 'standardDev' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was given when the statistics was created, this 
//    function can be used to add new data.
//    If the statistics was created for an existing EPTF Variable data will be
//    automatically added when the value of the variable is refreshed. 
//    But this function can be used to add additional data also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_addData_standardDev(
  in integer pl_statIdx, 
  in float pl_newData) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.standardDev));

  if (statList[pl_statIdx].reset) {
    statList[pl_statIdx].reset := false;
    var integer vl_meanIdx := statList[pl_statIdx].statData.standardDev.meanIdx;
    f_EPTF_StatMeasure_resetStat_mean(vl_meanIdx); // reset mean also

    statList[vl_meanIdx].statData.mean := {0, 0.0, 0.0, 0.0};
    statList[pl_statIdx].statData.standardDev := {vl_meanIdx, 0.0, 0.0};
    f_EPTF_StatMeasure_addData_standardDev(pl_statIdx,pl_newData);
    return;
  }
  var integer pl_statMeanIdx := 
    statList[pl_statIdx].statData.standardDev.meanIdx;

  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statMeanIdx].statData.mean));


  // pl_idx is the same as:
  //var integer pl_idx := statList[pl_statIdx].varIdx;

  // update the mean:
  statList[pl_statMeanIdx].enabled := true;
  f_EPTF_StatMeasure_addData_mean(pl_statMeanIdx,pl_newData);
  statList[pl_statMeanIdx].enabled := false;

  var float x, delta;
  x := statList[pl_statMeanIdx].statData.mean.x;
  delta := statList[pl_statMeanIdx].statData.mean.delta;

  statList[pl_statIdx].statData.standardDev.S := 
    statList[pl_statIdx].statData.standardDev.S + delta * (x-statList[pl_statMeanIdx].statData.mean.statValue);
  statList[pl_statIdx].statData.standardDev.statValue := 
    /*sqrt*/(statList[pl_statIdx].statData.standardDev.S/int2float(statList[pl_statMeanIdx].statData.mean.n));
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_enableStat_standardDev
// 
//  Purpose:
//    Enable 'standardDev' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_enableStat_standardDev(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := true;
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.standardDev));

  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Var_addPostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_standardDev_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_disableStat_standardDev
// 
//  Purpose:
//    Disable 'standardDev' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_disableStat_standardDev(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := false;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Var_removePostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_standardDev_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_standardDev
// 
//  Purpose:
//    Returns the value of the 'standardDev' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_statValue - *out* <EPTF_Var_DirectContent> - the value of the stat
//
//  Return Value:
//    *boolean* - true if stat is available, false if no
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_standardDev(
  in integer pl_statIdx, 
  out float pl_statValue) 
runs on EPTF_StatMeasure_CT return boolean 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.standardDev));

  pl_statValue := statList[pl_statIdx].statData.standardDev.statValue;
  return f_EPTF_StatMeasure_valueIsAvailable(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_standardDev_mean
// 
//  Purpose:
//    Returns the value of the 'mean' statistics belonging to the given 
//   'standardDev' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the 'standardDev' statistics
//    pl_statValue - *out* <EPTF_Var_DirectContent> - the value of the stat 'mean'
//
//  Return Value:
//    *boolean* - true if stat is available, false if no
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_standardDev_mean(
  in integer pl_statIdx, 
  out float pl_statValue) 
runs on EPTF_StatMeasure_CT return boolean 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.standardDev));

  var integer vl_meanIdx := statList[pl_statIdx].statData.standardDev.meanIdx;
  return f_EPTF_StatMeasure_getStat_mean(vl_meanIdx,pl_statValue);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStatIdx_standardDev_mean
// 
//  Purpose:
//    Returns the idx of the 'mean' statistics belonging to the given 
//   'standardDev' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the 'standardDev' statistics
//
//  Return Value:
//    *integer* - the idx of the 'mean' statistics belonging to the given 
//                'standardDev' statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Do not reset or disable this statistics!
//    This index is provided only to get the value as a charstring of 
//    the mean statistics created automatically for standardDev. Use the 
//    function <f_EPTF_StatMeasure_getStat_standardDev_mean> the get the value
//    of the mean statistics belonging to the given standardDev statistics, 
//    and use float2str to convert it to charstring.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStatIdx_standardDev_mean(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return integer 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.standardDev));
  
  return statList[pl_statIdx].statData.standardDev.meanIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_standardDev2str
// 
//  Purpose:
//    Returns the value of the 'standardDev' statistics as a charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *charstring* - the value of the statistics as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_standardDev2str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  var float vl_currentContent;
  if (f_EPTF_StatMeasure_getStat_standardDev(pl_statIdx, vl_currentContent)) {
    return float2str(vl_currentContent);
  } else {
    return "N/A";
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_standardDev_mean2str
// 
//  Purpose:
//    Returns the value of the 'mean' statistics belonging to the given 
//                             'standardDev' statistics as a charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat 'standardDev'
//
//  Return Value:
//    *charstring* - the value of the statistics 'mean' as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_standardDev_mean2str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  f_EPTF_Base_assert("Invalid stat type.",ischosen(statList[pl_statIdx].statData.standardDev));
  var float vl_currentContent;
  var integer vl_meanIdx := statList[pl_statIdx].statData.standardDev.meanIdx;
  if (f_EPTF_StatMeasure_getStat_mean(vl_meanIdx, vl_currentContent)) {
    return float2str(vl_currentContent);
  } else {
    return "N/A";
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_createVarFromStat_Mean_standardDev
// 
//  Purpose:
//    Creates EPTF variable from the mean value (i.e. the mean statistics of the data samples) of the 'standardDev' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the mean stat
//    pl_varName - *in* *charstring* - the name of the created variable 
//                   (if empty: name is auto-generated). Default: empty
//
//  Return Value:
//    *integer* - the idx of the EPTF Variable that contains the mean value
//
//  Errors:
//    -
//
//  Detailed Comments:
//    -
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_createVarFromStat_Mean_standardDev(
  in integer pl_statIdx,
  in charstring pl_varName := ""
) runs on EPTF_StatMeasure_CT return integer
{
  // check type of stat:
  f_EPTF_Base_assert(%definitionId&": Invalid stat type: standardDev expected",
    ischosen(statList[pl_statIdx].statData.standardDev));
  
  var integer vl_meanStatIdx := statList[pl_statIdx].statData.standardDev.meanIdx;
  return f_EPTF_StatMeasure_createVarFromStat(vl_meanStatIdx, pl_varName);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_createVarFromStat_N_standardDev
// 
//  Purpose:
//    Creates EPTF variable from auxuliary data N (i.e. the number of data samples) of the 'standardDev' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the mean stat
//    pl_varName - *in* *charstring* - the name of the created variable 
//                   (if empty: name is auto-generated). Default: empty
//
//  Return Value:
//    *integer* - the idx of the EPTF Variable that contains the number of data samples
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no mean variable was created from the statistics, it creates that variable also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_createVarFromStat_N_standardDev(
  in integer pl_statIdx,
  in charstring pl_varName := ""
) runs on EPTF_StatMeasure_CT return integer
{
  // check type of stat:
  f_EPTF_Base_assert(%definitionId&": Invalid stat type: standardDev expected",
    ischosen(statList[pl_statIdx].statData.standardDev));
  
  var integer vl_meanStatIdx := statList[pl_statIdx].statData.standardDev.meanIdx;
  return f_EPTF_StatMeasure_createVarFromStat_N_mean(vl_meanStatIdx, pl_varName);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_createVarFromStat_S_standardDev
// 
//  Purpose:
//    Creates EPTF variable from auxuliary data S (i.e. the sum of deviation squares, see Alg III.) of the 'standardDev' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the mean stat
//    pl_varName - *in* *charstring* - the name of the created variable 
//                   (if empty: name is auto-generated). Default: empty
//
//  Return Value:
//    *integer* - the idx of the EPTF Variable that contains the sum of data samples
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was created from the statistics, it creates that variable also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_createVarFromStat_S_standardDev(
  in integer pl_statIdx,
  in charstring pl_varName := ""
) runs on EPTF_StatMeasure_CT return integer
{
  // check type of stat:
  f_EPTF_Base_assert(%definitionId&": Invalid stat type: standardDev expected",
    ischosen(statList[pl_statIdx].statData.standardDev));
  
  var integer vl_nDataVarIdx;
  var integer vl_statVarIdx := f_EPTF_StatMeasure_getCreatedVarIdx(pl_statIdx);
  if (vl_statVarIdx==-1) {
    f_EPTF_StatMeasure_warning(%definitionId&": No variable was created from the standardDev stat. Creating var automatically");
    vl_statVarIdx := f_EPTF_StatMeasure_createVarFromStat(pl_statIdx);
  }

  // creating aux variable:
  var charstring vl_statName := f_EPTF_StatMeasure_getStatName(pl_statIdx);
  var charstring vl_varName := pl_varName;
  if (vl_varName=="") {
    vl_varName := "StatAux.n."&vl_statName;
  }

  vl_nDataVarIdx := f_EPTF_Var_getId(vl_varName);
  if (vl_nDataVarIdx!=-1) {
    return vl_nDataVarIdx; // var already created
  }

  f_EPTF_Var_newFloat(vl_varName,0.0, vl_nDataVarIdx); // aux var for S
  
  // add calcFn to calculate its value:
  f_EPTF_Var_subscribeLocal(
    vl_nDataVarIdx,
    {
      calcFn := {
        funcRef := refers(f_EPTF_StatMeasure_getS_StandardDevStat_CalcFn),
        argList := {vl_statVarIdx}, // the varible created from the mean stat
        nonVarArgList := {pl_statIdx} // index of the mean statistics
      }
    }
  );
  return vl_nDataVarIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getS_StandardDevStat_CalcFn
// 
//  Purpose:
//    calcFn that calculates the number of Data for standardDev stat
//
//  Parameters:
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    mean stat Id : pl_nonVarArgList[0]
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_getS_StandardDevStat_CalcFn(
  in integer pl_idx,
  in EPTF_IntegerList pl_argList,
  in EPTF_IntegerList pl_nonVarArgList,
  inout EPTF_Var_DirectContent pl_retVal
) runs on EPTF_StatMeasure_CT {
  var integer vl_statId := pl_nonVarArgList[0];
  pl_retVal := { floatVal := statList[vl_statId].statData.standardDev.S };
}

} // group standardDevStat

///////////////////////////////////////////////////////////////////////////////
// Group: EPSStat
//
// Purpose:
//   Functions for the EPS stat
//
// Description:
//   The aim of this statistics is to measure the event per seconds rate.
//   The number of events can be set by the <f_EPTF_StatMeasure_addData_EPS>.
//   Every refresh event of the variable the stat was created from defines one event.
///////////////////////////////////////////////////////////////////////////////
group EPSStat {


///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStat_EPS
// 
//  Purpose:
//    Creates a new 'EPS' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_varIdx - *in* *integer* - the idx of the EPTF variable 
//         (-1 to create stat without a variable). Default: -1
//
//  Return Value:
//    *integer* - the idx of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    This function can be called for any type of vars
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStat_EPS(
  in integer pl_varIdx := -1) 
runs on EPTF_StatMeasure_CT return integer 
{
  f_EPTF_StatMeasure_debug(%definitionId&"()");
  var integer vl_newStatIdx := sizeof(statList);
  statList[vl_newStatIdx] := 
  { pl_varIdx, -1, {EPS := { 0, 0.0, 0.0, 0.0 }}, false, true };

  f_EPTF_StatMeasure_resetStat_EPS(vl_newStatIdx);
  // enable the stat:
  f_EPTF_StatMeasure_enableStat_EPS(vl_newStatIdx);
  
  return vl_newStatIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStat_EPS
// 
//  Purpose:
//    Reset 'EPS' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStat_EPS(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  statList[pl_statIdx].reset := true;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initStatValue_EPS
// 
//  Purpose:
//    Initializes the value of 'EPS' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Stat is initialized with zero.
//    The created variable is also updated. 
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_initStatValue_EPS(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_resetStat_EPS(pl_statIdx);

  statList[pl_statIdx].statData.EPS := { 0, 0.0, 0.0, 0.0 };
  
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_startMeasurement_EPS
// 
//  Purpose:
//    Start the measurement for the 'EPS' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was given when the statistics was created, 
//    this function can be used to add new data.
//    If the statistics was created for an existing EPTF Variable data will be
//    automatically added when the value of the variable is refreshed. 
//    But this function can be used to add additional data also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_startMeasurement_EPS(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT {
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.EPS));
  
  if(statList[pl_statIdx].reset) {
    statList[pl_statIdx].reset:=false;
    statList[pl_statIdx].statData.EPS.n := 0;
    // preserve its previous value after reset.
    // call to f_EPTF_StatMeasure_update_EPS is needed to change the statValue 
    //statList[pl_statIdx].statData.EPS.statValue := 0.0;
    statList[pl_statIdx].statData.EPS.startTime := f_EPTF_Base_getRelTimeInSecs();
    statList[pl_statIdx].statData.EPS.measurementLength := 0.0;
    return;
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_addData_EPS
// 
//  Purpose:
//    Add new data for the 'EPS' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_nofEvents - *in* *integer* - number of events (default: 1)
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was given when the statistics was created, this function 
//    can be used to add new data.
//    If the statistics was created for an existing EPTF Variable data will be
//    automatically added when the value of the variable is refreshed. 
//    But this function can be used to add additional data also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_addData_EPS(
  in integer pl_statIdx,
  in integer pl_nofEvents := 1) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.EPS));

  if(statList[pl_statIdx].reset) {
    f_EPTF_StatMeasure_startMeasurement_EPS(pl_statIdx);
  }
  statList[pl_statIdx].statData.EPS.n := statList[pl_statIdx].statData.EPS.n + pl_nofEvents;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_enableStat_EPS
// 
//  Purpose:
//    Enable 'EPS' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Need to call this function if the EPS statistics was 
//    created for an existing variable
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_enableStat_EPS(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := true;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.EPS));

  f_EPTF_Var_addPostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_addData_EPS_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_disableStat_EPS
// 
//  Purpose:
//    Disable 'EPS' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Need to call this function if the EPS statistics was enabled by 
//    <f_EPTF_StatMeasure_enableStat_EPS>
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_disableStat_EPS(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := false;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Var_removePostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_addData_EPS_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_EPS
// 
//  Purpose:
//    Returns the value of the 'EPS' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_statValue - *out* <EPTF_Var_DirectContent> - the value of the stat
//
//  Return Value:
//    *boolean* - true if stat is available, false if no
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_EPS(
  in integer pl_statIdx, 
  out float pl_statValue) 
runs on EPTF_StatMeasure_CT return boolean 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.EPS));
  
  pl_statValue := statList[pl_statIdx].statData.EPS.statValue;
  return f_EPTF_StatMeasure_valueIsAvailable(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_EPS2str
// 
//  Purpose:
//    Returns the value of the 'EPS' statistics as a charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *charstring* - the value of the statistics as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_EPS2str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  var float vl_currentContent;
  if (f_EPTF_StatMeasure_getStat_EPS(pl_statIdx, vl_currentContent)) {
    return float2str(vl_currentContent);
  } else {
    return "N/A";
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getMeasurementLength_EPS
// 
//  Purpose:
//    Returns the length of measurement in seconds for the 'EPS' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *float* - the time of the measurement in seconds
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Note, that if the <f_EPTF_StatMeasure_update_EPS> was not called, 0.0 sec 
//    is returned for the the measurement time.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getMeasurementLength_EPS(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return float 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.EPS));

  return statList[pl_statIdx].statData.EPS.measurementLength;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getTime_EPS
// 
//  Purpose:
//    Returns the time in seconds for the 'EPS' statistics since 
//    the measurement was started
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *float* - the time of the measurement in seconds
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getTime_EPS(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return float 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.EPS));

  return f_EPTF_Base_getRelTimeInSecs() - statList[pl_statIdx].statData.EPS.startTime;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_update_EPS
// 
//  Purpose:
//    This function should be called in an event handler function for a 
//    scheduled event to calculate the EPS statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - index of the statistics to update
//    pl_period - *in* *float* - period of measurement, if -1.0 is specified 
//                               the time is automatically measured
//    pl_enableRefresh - *in* *boolean* - if false: only the content of the 
//                           created Variables will be updated, the refresh 
//                           mechanism is not initiated for them. Default: true
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_update_EPS(
  in integer pl_statIdx, 
  in float pl_period := -1.0, 
  in boolean pl_enableRefresh := true) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.EPS));

  var float vl_period := pl_period;
  if (pl_period==-1.0) {
    vl_period := 
      f_EPTF_Base_getRelTimeInSecs() - statList[pl_statIdx].statData.EPS.startTime;
  }
  statList[pl_statIdx].statData.EPS.measurementLength := vl_period;

  // pl_idx is the same as:
  //var integer pl_idx := statList[pl_statIdx].varIdx;

  if (vl_period==0.0) {
     statList[pl_statIdx].statData.EPS.statValue := 0.0;
  } else {
    statList[pl_statIdx].statData.EPS.statValue := 
      int2float(statList[pl_statIdx].statData.EPS.n)/vl_period;
  }
// do not reset automatically: the user will do it if (s)he likes
//  statList[pl_statIdx].statData.EPS.n := 0; // reset the counter
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx,pl_enableRefresh);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_registerDefaultUpdate_EPS
// 
//  Purpose:
//    This function should be called if user wants EPS statistics to be updated automatically
//
//  Parameters:
//    pl_statIdx - *in* *integer* - index of the statistics to update
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_registerDefaultUpdate_EPS(in integer pl_statIdx)
runs on EPTF_StatMeasure_CT
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.EPS));

  f_EPTF_Var_addSyncCallBackFn(
    refers(f_EPTF_StatMeasure_defaultUpdate_EPS),
    {pl_statIdx});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_defaultUpdate_EPS
// 
//  Purpose:
//    This function can be called in an event handler function for a
//    scheduled event to calculate the EPS statistics with 
//    incoming parameters stored in an <EPTF_IntegerList> format.
//
//  Parameters:
//    pl_argList - *in* <EPTF_IntegerList> - pl_argList[0] is the index of the statistics to update
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_defaultUpdate_EPS(in EPTF_IntegerList pl_argList)
runs on EPTF_StatMeasure_CT
{
  if(lengthof(pl_argList) < 1) {
    f_EPTF_StatMeasure_warning(%definitionId&": The index of the statistics is not set");
    return;
  }
  f_EPTF_StatMeasure_update_EPS(pl_argList[0]);
}

} // group EPSStat

///////////////////////////////////////////////////////////////////////////////
// Group: chronoStat
//
// Purpose:
//   Functions for the chrono stat
//
// Description:
//   The aim of this statistics is to measure the elapsed time in seconds.
///////////////////////////////////////////////////////////////////////////////
group chronoStat {


///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStat_chrono
// 
//  Purpose:
//    Creates a new 'chrono' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_varIdx - *in* *integer* - the idx of the EPTF variable 
//    (-1 to create stat without a variable). Default: -1
//
//  Return Value:
//    *integer* - the idx of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    This function can be called for any type of vars
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStat_chrono(
  in integer pl_varIdx := -1) 
runs on EPTF_StatMeasure_CT return integer 
{
  var integer vl_newStatIdx := sizeof(statList);
  statList[vl_newStatIdx] := 
  { pl_varIdx, -1, {chrono := { 0.0, 0.0, -1.0 }}, false, true };

  f_EPTF_StatMeasure_resetStat_chrono(vl_newStatIdx);
  // enable the stat:
  f_EPTF_StatMeasure_enableStat_chrono(vl_newStatIdx);
  
  return vl_newStatIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStat_chrono
// 
//  Purpose:
//    Reset 'chrono' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStat_chrono(
  in integer pl_statIdx) runs on EPTF_StatMeasure_CT 
{
  statList[pl_statIdx].reset := true;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initStatValue_chrono
// 
//  Purpose:
//    Initializes the value of 'chrono' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Stat is initialized with zero.
//    The created variable is also updated. 
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_initStatValue_chrono(
  in integer pl_statIdx) runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_resetStat_chrono(pl_statIdx);

  statList[pl_statIdx].statData.chrono := { 0.0, 0.0, -1.0 };
  
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_start_chrono
// 
//  Purpose:
//    Starts the chronometer for the 'chrono' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_start_chrono(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.chrono));

  if(statList[pl_statIdx].reset) {
    statList[pl_statIdx].reset:=false;
    statList[pl_statIdx].statData.chrono.statValue := 0.0;
    statList[pl_statIdx].statData.chrono.startTime := 
      f_EPTF_Base_getRelTimeInSecs();
    statList[pl_statIdx].statData.chrono.stopTime := -1.0;
    return;
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_stop_chrono
// 
//  Purpose:
//    Stops the chronometer for the 'chrono' statistics and updates it value.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_stop_chrono(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.chrono));

  if(statList[pl_statIdx].reset) {
    statList[pl_statIdx].reset:=false;
    statList[pl_statIdx].statData.chrono.statValue := 0.0;
    statList[pl_statIdx].statData.chrono.startTime := 0.0;
    statList[pl_statIdx].statData.chrono.stopTime := 0.0;
    f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
    return;
  }
  if (statList[pl_statIdx].statData.chrono.stopTime!=-1.0) {
    return;// already stopped
  }
  f_EPTF_StatMeasure_addData_chrono(pl_statIdx);
  statList[pl_statIdx].statData.chrono.stopTime := 
    statList[pl_statIdx].statData.chrono.statValue+statList[pl_statIdx].statData.chrono.startTime;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_addData_chrono
// 
//  Purpose:
//    Add new data for the 'chrono' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was given when the statistics was created, this 
//    function can be used to add new data.
//    If the statistics was created for an existing EPTF Variable data will be
//    automatically added when the value of the variable is refreshed. 
//    But this function can be used to add additional data also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_addData_chrono(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.chrono));

  if(statList[pl_statIdx].reset) {
    f_EPTF_StatMeasure_start_chrono(pl_statIdx);
  } else {
    f_EPTF_StatMeasure_update_chrono(pl_statIdx);
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_enableStat_chrono
// 
//  Purpose:
//    Enable 'chrono' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Need to call this function if the chrono statistics was created 
//    for an existing variable
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_enableStat_chrono(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := true;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.chrono));

  f_EPTF_Var_addPostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_addData_chrono_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_disableStat_chrono
// 
//  Purpose:
//    Disable 'chrono' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Need to call this function if the chrono statistics was enabled by 
//    <f_EPTF_StatMeasure_enableStat_chrono>
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_disableStat_chrono(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := false;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Var_removePostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_addData_chrono_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_chrono
// 
//  Purpose:
//    Returns the value of the 'chrono' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_statValue - *out* <EPTF_Var_DirectContent> - the value of the stat
//
//  Return Value:
//    *boolean* - true if stat is available, false if no
//
//  Errors:
//    -
//
//  Detailed Comments:
//    The value is the time elapsed since start in seconds
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_chrono(
  in integer pl_statIdx, 
  out float pl_statValue) 
runs on EPTF_StatMeasure_CT return boolean 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.chrono));
  
  pl_statValue := statList[pl_statIdx].statData.chrono.statValue;
  return f_EPTF_StatMeasure_valueIsAvailable(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_chrono2str
// 
//  Purpose:
//    Returns the value of the 'chrono' statistics as a charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *charstring* - the value of the statistics as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_chrono2str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  var float vl_currentContent;
  if (f_EPTF_StatMeasure_getStat_chrono(pl_statIdx, vl_currentContent)) {
    return float2str(vl_currentContent);
  } else {
    return "N/A";
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getMeasurementLength_chrono
// 
//  Purpose:
//    Returns the length of measurement in seconds for the 'chrono' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *float* - the time of the measurement in seconds
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Note, that if the <f_EPTF_StatMeasure_update_chrono> was not called, 
//    0.0 sec is returned for the the measurement time.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getMeasurementLength_chrono(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return float 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.chrono));

  return statList[pl_statIdx].statData.chrono.statValue;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getTime_chrono
// 
//  Purpose:
//    Returns the time in seconds for the 'chrono' statistics since 
//    the measurement was started
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *float* - the time of the measurement in seconds
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getTime_chrono(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return float 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.chrono));

  if (statList[pl_statIdx].statData.chrono.stopTime!=-1.0) {
    return statList[pl_statIdx].statData.chrono.stopTime - statList[pl_statIdx].statData.chrono.startTime;
  }
  
  return f_EPTF_Base_getRelTimeInSecs() - statList[pl_statIdx].statData.chrono.startTime;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_update_chrono
// 
//  Purpose:
//    This function should be called in an event handler function 
//    for a scheduled event to calculate the chrono statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - index of the statistics to update
//    pl_enableRefresh - *in* *boolean* - if false: only the content of the
//                         created Variables will be updated, no refresh is 
//                         initiated for the variables. Default: true
//
//  Detailed Comments:
//    Updates the value of the stat to the time elapsed since start.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_update_chrono(
  in integer pl_statIdx, 
  in boolean pl_enableRefresh := true) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.chrono));

  if (statList[pl_statIdx].statData.chrono.stopTime!=-1.0) {
    return; // chrono is stopped
  }
  
  statList[pl_statIdx].statData.chrono.statValue := 
    f_EPTF_Base_getRelTimeInSecs() - statList[pl_statIdx].statData.chrono.startTime;
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx,pl_enableRefresh);
}

private function f_EPTF_StatMeasure_defaultUpdate_chrono(in EPTF_IntegerList pl_argList)
runs on EPTF_StatMeasure_CT
{
  f_EPTF_StatMeasure_update_chrono(pl_argList[0]);
}

} // group chronoStat

///////////////////////////////////////////////////////////////////////////////
// Group: densityStat
//
// Purpose:
//   Functions for the density stat
//
// Description:
//   The aim of this statistics is to measure the density function of the data values.
//   Custom boundaries can be defined. The number of elements falling between these
//   boundary values are measured, together with the number of elements below the lowest-,
//   and above the highest boundary values. The normalized values give the density function.
//   If the boundaries are changed during data collection, the statistics is reset.
//   The sum of the normalized density values from the lowest boundary to a certain boundary
//   gives the probability of the data being smaller than that boundary value:
//   P(x<boundary[b]) = sum { (i:=0...b) Density[i] }
///////////////////////////////////////////////////////////////////////////////
group densityStat {


///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStat_density
// 
//  Purpose:
//    Creates a new 'density' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_boundaries - *in* <EPTF_FloatList> - the list of boundaries
//    pl_varIdx - *in* *integer* - the idx of the EPTF variable (its type should be integer or float)
//           (-1 to create stat without a variable). Default: -1
//
//  Return Value:
//    *integer* - the idx of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStat_density(
  in EPTF_FloatList pl_boundaries, 
  in integer pl_varIdx := -1) 
runs on EPTF_StatMeasure_CT return integer 
{
  var integer vl_newStatIdx := sizeof(statList);

  // sort the boundary values:
  f_EPTF_StatMeasure_bubblesort(pl_boundaries);

  statList[vl_newStatIdx] := 
  { pl_varIdx, -1, {density := { pl_boundaries, {}, -1 }}, false, true };
  
  // initialize the value:
  f_EPTF_StatMeasure_initValue_density(vl_newStatIdx);

  f_EPTF_StatMeasure_resetStat_density(vl_newStatIdx);
  // enable the stat:
  f_EPTF_StatMeasure_enableStat_density(vl_newStatIdx);

  return vl_newStatIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_setBoundaries_density
// 
//  Purpose:
//    Sets new boundaries for the density statistics. Also resets the stat.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_boundaries - *in* <EPTF_FloatList> - the list of boundaries
//    pl_enableUpdate - *in boolean* - if false the EPTF Variable created for 
//                        the boundaries will not be refreshed. Default: true
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_setBoundaries_density(
  in integer pl_statIdx, 
  in EPTF_FloatList pl_boundaries, 
  in boolean pl_enableUpdate := true) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.density));

  // sort the boundary values:
  f_EPTF_StatMeasure_bubblesort(pl_boundaries);

  if (statList[pl_statIdx].statData.density.boundaries==pl_boundaries) {
    return; // same boundary was set => nothing to do (e.g. sampledAtSync subscription)
  }
  
  statList[pl_statIdx].statData.density.boundaries := pl_boundaries;
  f_EPTF_StatMeasure_resetStat_density(pl_statIdx);

  // initialize the value:
  f_EPTF_StatMeasure_initValue_density(pl_statIdx);
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx,pl_enableUpdate);

  f_EPTF_StatMeasure_updateCreatedVarForBoundaries_density(
    pl_statIdx,pl_enableUpdate);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getBoundaries_density
// 
//  Purpose:
//    Returns the boundaries for the density statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    <EPTF_FloatList> - the list of boundaries
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getBoundaries_density(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return EPTF_FloatList
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.density));
  return statList[pl_statIdx].statData.density.boundaries;
}
///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initValue_density
// 
//  Purpose:
//    Initializes the value for the density statistics based on the boundary value.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_initValue_density(
  in integer pl_statIdx
) runs on EPTF_StatMeasure_CT {
  // initialize the value:
  statList[pl_statIdx].statData.density.statValue := {};
  for(var integer i:=0; i<sizeof(statList[pl_statIdx].statData.density.boundaries)+1; i:=i+1) {
    statList[pl_statIdx].statData.density.statValue[i] := 0;
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_setScale_density
// 
//  Purpose:
//    Sets boundaries automatically between min and max on linear/logarithmic 
//    scale for the density statistics. Also resets the stat.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_min - *in* *float* - the lowest boundary
//    pl_max - *in* *float* - the highest boundary
//    pl_n - *in* *integer* - the number of elements in the boundary list
//                            (should be 1 or more)
//    pl_scale - *in* <EPTF_StatMeasure_density_scale> - the scale to be used 
//                                      between min and max (default: linear)
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_setScale_density(
  in integer pl_statIdx, 
  in float pl_min, 
  in float pl_max, 
  in integer pl_n, 
  in EPTF_StatMeasure_density_scale pl_scale := linear) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.density));

  statList[pl_statIdx].statData.density.boundaries := {};
  if (pl_n==1) {
    statList[pl_statIdx].statData.density.boundaries[0] := pl_min;
    f_EPTF_StatMeasure_resetStat_density(pl_statIdx);
    f_EPTF_StatMeasure_updateCreatedVarForBoundaries_density(pl_statIdx);
    f_EPTF_StatMeasure_initValue_density(pl_statIdx);
    f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
    return;
  }

  for (var integer i:=0; i<pl_n; i:=i+1) 
  {
    if (pl_scale == linear) 
    {
      statList[pl_statIdx].statData.density.boundaries[i] := 
      pl_min + int2float(i)/int2float(pl_n-1)*(pl_max-pl_min);
    } else if (pl_scale == logarithmic) 
    {
      if (pl_max<=0.0 or pl_min<= 0.0) 
      {        
        f_EPTF_StatMeasure_error(log2str(
            "Invlid scale boundaries specified for logarithmic scale: min: ",
            pl_min,", max: ",pl_max));
        f_EPTF_Base_stop();
      }
      statList[pl_statIdx].statData.density.boundaries[i] := 
        f_exp( f_log(pl_min) + 
          int2float(i)/int2float(pl_n-1)*(f_log(pl_max)-f_log(pl_min)) );
    }
  }
  
  f_EPTF_StatMeasure_resetStat_density(pl_statIdx);
  f_EPTF_StatMeasure_updateCreatedVarForBoundaries_density(pl_statIdx);
  f_EPTF_StatMeasure_initValue_density(pl_statIdx);
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStat_density
// 
//  Purpose:
//    Reset 'density' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStat_density(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  statList[pl_statIdx].reset := true;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initStatValue_density
// 
//  Purpose:
//    Initializes the value of 'density' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Stat is initialized with zero.
//    The created variable is also updated. 
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_initStatValue_density(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_resetStat_density(pl_statIdx);

  f_EPTF_StatMeasure_initValue_density(pl_statIdx);
  
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_addData_density
// 
//  Purpose:
//    Add new data for the 'density' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was given when the statistics was created, this function 
//    can be used to add new data.
//    If the statistics was created for an existing EPTF Variable data will be
//    automatically added when the value of the variable is refreshed. 
//    But this function can be used to add additional data also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_addData_density(
  in integer pl_statIdx, 
  in float pl_newData) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.density));

  if (statList[pl_statIdx].reset) {
    statList[pl_statIdx].reset := false;
    f_EPTF_StatMeasure_initValue_density(pl_statIdx);
    //return;
  }
  var integer vl_nofBoundaries := sizeof(statList[pl_statIdx].statData.density.boundaries);

  for(var integer i:=0; i<vl_nofBoundaries; i:=i+1) 
  {
    if (pl_newData<statList[pl_statIdx].statData.density.boundaries[i]) {
      statList[pl_statIdx].statData.density.statValue[i] := 
        statList[pl_statIdx].statData.density.statValue[i] + 1;
      i:=vl_nofBoundaries; // end for cycle
    }
  }

  if (vl_nofBoundaries > 0
    and pl_newData>=statList[pl_statIdx].statData.density.boundaries[vl_nofBoundaries-1]) {
    statList[pl_statIdx].statData.density.statValue[vl_nofBoundaries] := 
      statList[pl_statIdx].statData.density.statValue[vl_nofBoundaries] + 1;
  }
  if (vl_nofBoundaries == 0) {
    statList[pl_statIdx].statData.density.statValue[vl_nofBoundaries] := 
      statList[pl_statIdx].statData.density.statValue[vl_nofBoundaries] + 1;
  }
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_enableStat_density
// 
//  Purpose:
//    Enable 'density' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_enableStat_density(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := true;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.density));

  f_EPTF_Var_addPostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_density_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_disableStat_density
// 
//  Purpose:
//    Disable 'density' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_disableStat_density(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := false;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Var_removePostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_density_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_density
// 
//  Purpose:
//    Returns the value of the 'density' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_statValue - *out* <EPTF_IntegerList> - the value of the stat
//
//  Return Value:
//    *boolean* - true if stat is available, false if no
//
//  Errors:
//    -
//
//  Detailed Comments:
//    It returns the counter values for each coloumn.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_density(
  in integer pl_statIdx, 
  out EPTF_IntegerList pl_statValue) 
runs on EPTF_StatMeasure_CT return boolean 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.density));

  pl_statValue := statList[pl_statIdx].statData.density.statValue;
  return f_EPTF_StatMeasure_valueIsAvailable(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_normalized_density
// 
//  Purpose:
//    Returns the normalized value of the 'density' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_statValue - *out* <EPTF_FloatList> - the value of the stat
//
//  Return Value:
//    *boolean* - true if stat is available, false if no
//
//  Errors:
//    -
//
//  Detailed Comments:
//    The coloumns are normalized by the sum of all coloumns, i.e. the 
//    sum of all elements in the returned list is 1.0.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_normalized_density(
  in integer pl_statIdx, 
  out EPTF_FloatList pl_statValue) 
runs on EPTF_StatMeasure_CT return boolean 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.density));

  var integer vl_sum := 0;
  for(var integer i:=0; i<sizeof(statList[pl_statIdx].statData.density.statValue); i:=i+1) 
  {
    vl_sum := vl_sum + statList[pl_statIdx].statData.density.statValue[i];
  }
  pl_statValue := {};
  for(var integer i:=0; i<sizeof(statList[pl_statIdx].statData.density.statValue); i:=i+1) 
  {
    if (vl_sum==0) {
      pl_statValue[i] := 0.0;
    } else {
      pl_statValue[i] := 
        int2float(statList[pl_statIdx].statData.density.statValue[i])/int2float(vl_sum);
    }
  }
  return f_EPTF_StatMeasure_valueIsAvailable(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_density2str
// 
//  Purpose:
//    Returns the value of the 'density' statistics as a charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *charstring* - the value of the statistics as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_density2str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  var EPTF_IntegerList vl_currentValue;
  if (f_EPTF_StatMeasure_getStat_density(pl_statIdx, vl_currentValue)) {
    return f_EPTF_StatMeasure_integerList2str(vl_currentValue);
  } else {
    return "N/A";
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_createVarFromStat_boundaries_density
// 
//  Purpose:
//    Creates an EPTF Variable from the boundaries of the density statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_varName - *in* *charstring* - the name of the created variable 
//                   (if empty: name is auto-generated). Default: empty
//
//  Return Value:
//    *integer* - idx of the new variable
//
//  Errors:
//    -
//
//  Detailed Comments:
//    The type of the variable is floatlist.
//    For auto-generated names the name will be the name generated for 
//    the statistics by the function <f_EPTF_StatMeasure_getStatName> & 
//    ".boundaries".
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_createVarFromStat_boundaries_density(
  in integer pl_statIdx, 
  in charstring pl_varName := "") 
runs on EPTF_StatMeasure_CT return integer 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.density));

  // return the already created var index if it exists:
  if (statList[pl_statIdx].statData.density.createdBoundaryVarIdx != -1) 
  {
    f_EPTF_StatMeasure_warning(log2str("Variable for the boundaries of stat ", 
        pl_statIdx, " (",statList[pl_statIdx],") already exists: ", 
        f_EPTF_Var_getName(statList[pl_statIdx].statData.density.createdBoundaryVarIdx)));
    return statList[pl_statIdx].statData.density.createdBoundaryVarIdx;
  }

  var integer vl_newVarIdx;

  // assign auto-name:
  var charstring vl_statName := pl_varName;
  if (vl_statName == "") {
    vl_statName := f_EPTF_StatMeasure_getStatName(pl_statIdx) & ".boundaries";
  }

  //log("vl_statName: ",vl_statName);
  f_EPTF_StatMeasure_debug("vl_statName: "&vl_statName);

  vl_newVarIdx := f_EPTF_Var_getId(vl_statName);
  if (vl_newVarIdx!=-1) {
    return vl_newVarIdx; // var already created
  }

  f_EPTF_Var_newFloatlist(vl_statName, 
    statList[pl_statIdx].statData.density.boundaries,vl_newVarIdx);

  // store the var index,
  // register postProc to update the boundaries
  // (adjust is allowed for this variable: postProc updates the boundaries):
  f_EPTF_StatMeasure_registerCreatedVarForBoundaries_density(
    pl_statIdx,vl_newVarIdx);

  return vl_newVarIdx;
}

} // group densityStat

///////////////////////////////////////////////////////////////////////////////
// Group: percentilePStat
//
// Purpose:
//   Functions for the percentileP stat
//
// Description:
//   The aim of this statistics is to measure the Pth percentile of the data values.
//   The value of the statistics is the boundary value below which the P% of the data values falls.
//   Special case of this statistic can be 95th percentile, 50th percentile(median) statistic.
///////////////////////////////////////////////////////////////////////////////
group percentilePStat {

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStat_percentileP
// 
//  Purpose:
//    Creates a new 'percentileP' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_boundaries - *in* <EPTF_FloatList> - the list of boundaries
//    pl_valueP - *in* <float> - the Pth percentile eg: 50th, 95th
//    pl_varIdx - *in* *integer* - the idx of the EPTF variable 
//          (-1 to create stat without a variable). Default: -1
//
//  Return Value:
//    *integer* - the idx of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    The P value can be between 0.0 and 1.0. For example the value 0.25 means 25th percentile.
//    Default P value is 0.5, which is the 50th percentile and the median value.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStat_percentileP(
  in EPTF_FloatList pl_boundaries,
  in float pl_valueP := 0.5,
  in integer pl_varIdx := -1) 
runs on EPTF_StatMeasure_CT return integer 
{
  if (pl_valueP<0.0 or pl_valueP> 1.0) 
  {        
    f_EPTF_StatMeasure_error(log2str(
        "Invalid percentileP value. Must be between 0.0 - 1.0 . The value is: ", pl_valueP));
    f_EPTF_Base_stop();
  }

  // create the mean stat also for standardDev:
  var integer vl_densityIdx := 
    f_EPTF_StatMeasure_newStat_density(pl_boundaries, pl_varIdx);

  var integer vl_maxIdx := 
    f_EPTF_StatMeasure_newStat_max(pl_varIdx);

  f_EPTF_StatMeasure_disableStat_density(vl_densityIdx); // disable density: the percentileP's updateFunction will update it
  f_EPTF_StatMeasure_disableStat_max(vl_maxIdx); // disable max: the percentileP's updateFunction will update it

  var integer vl_newStatIdx := sizeof(statList);

  statList[vl_newStatIdx] := { pl_varIdx, -1, 
    { percentileP := { vl_densityIdx, vl_maxIdx, 0.0, 0, 0, 0, -1.0, pl_valueP, -1 }}, false, true };

  f_EPTF_StatMeasure_resetStat_percentileP(vl_newStatIdx);
  // enable the stat:
  f_EPTF_StatMeasure_enableStat_percentileP(vl_newStatIdx);

  return vl_newStatIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_setBoundaries_percentileP
// 
//  Purpose:
//    Sets new boundaries for the percentileP type statistics. Also resets the stat.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_boundaries - *in* <EPTF_FloatList> - the list of boundaries
//    pl_enableUpdate - *in boolean* - if false the EPTF Variable created for 
//                        the boundaries will not be refreshed. Default: true
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_setBoundaries_percentileP(
  in integer pl_statIdx, 
  in EPTF_FloatList pl_boundaries, 
  in boolean pl_enableUpdate := true) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentileP));

  var integer vl_densityIdx := 
    statList[pl_statIdx].statData.percentileP.densityIdx;

  var integer vl_maxIdx := 
    statList[pl_statIdx].statData.percentileP.maxIdx;

  f_EPTF_StatMeasure_setBoundaries_density(
    vl_densityIdx, pl_boundaries, pl_enableUpdate);

  f_EPTF_StatMeasure_resetStat_max(vl_maxIdx);
  f_EPTF_StatMeasure_resetStat_percentileP(pl_statIdx);

  f_EPTF_StatMeasure_debug( "Density statistics for percentileP (" & 
    int2str(pl_statIdx) & "): " & log2str(statList[vl_densityIdx]) &
    " / " & log2str(statList[vl_maxIdx]));
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_setScale_percentileP
// 
//  Purpose:
//    Sets boundaries automatically between min and max on linear/logarithmic 
//    scale for the 'percentileP' type statistics. Also resets the stat.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_min - *in* *float* - the lowest boundary
//    pl_max - *in* *float* - the highest boundary
//    pl_n - *in* *integer* - the number of elements in the boudary list
//                            (should be 1 or more)
//    pl_scale - *in* <EPTF_StatMeasure_density_scale> - the scale to be used 
//                                      between min and max (default: linear)
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_setScale_percentileP(
  in integer pl_statIdx, 
  in float pl_min, 
  in float pl_max, 
  in integer pl_n, 
  in EPTF_StatMeasure_density_scale pl_scale := linear) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentileP));

  var integer vl_densityIdx := 
    statList[pl_statIdx].statData.percentileP.densityIdx;  

  var integer vl_maxIdx := 
    statList[pl_statIdx].statData.percentileP.maxIdx;  

  f_EPTF_StatMeasure_setScale_density(vl_densityIdx,
    pl_min, pl_max, pl_n, pl_scale);

  f_EPTF_StatMeasure_resetStat_max(vl_maxIdx);
  f_EPTF_StatMeasure_resetStat_percentileP(pl_statIdx);

  f_EPTF_StatMeasure_debug( "Density statistics for percentileP (" & 
    int2str(pl_statIdx) & "): " & log2str(statList[vl_densityIdx]) &
    " / " & log2str(statList[vl_maxIdx]));
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_setValueP_percentileP
// 
//  Purpose:
//    Sets P value for the 'percentileP' type statistics. Also resets the stat.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_valueP - *in* *float* - P value to be updated
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    The P value can be between 0.0 and 1.0. For example the value 0.25 means 25th percentile.
//    Default P value is 0.5, which is the 50th percentile and the median value.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_setValueP_percentileP(
  in integer pl_statIdx,
  in float pl_valueP) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentileP));

  if (pl_valueP<0.0 or pl_valueP> 1.0) 
  {        
    f_EPTF_StatMeasure_error(log2str(
        "Invalid P value. Must be between 0.0 - 1.0 . The value is: ", pl_valueP));
    f_EPTF_Base_stop();
  }

  statList[pl_statIdx].statData.percentileP.valueP := pl_valueP;

  f_EPTF_StatMeasure_resetStat_percentileP(pl_statIdx);

  f_EPTF_StatMeasure_debug( "P value for percentileP (" & 
    int2str(pl_statIdx) & "): " & log2str(statList[pl_statIdx].statData.percentileP.valueP));
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStat_percentileP
// 
//  Purpose:
//    Reset 'percentileP' type statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    -
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStat_percentileP(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  statList[pl_statIdx].reset := true;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initStatValue_percentileP
// 
//  Purpose:
//    Initializes the value of 'percentileP' type statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Stat is initialized with zero.
//    The created variable is also updated. 
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_initStatValue_percentileP(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_resetStat_percentileP(pl_statIdx);

  var integer vl_densityIdx := statList[pl_statIdx].statData.percentileP.densityIdx;
  var integer vl_maxIdx := statList[pl_statIdx].statData.percentileP.maxIdx;
  var integer vl_createdValuePVarIdx := statList[pl_statIdx].statData.percentileP.createdValuePVarIdx;
  var float vl_valueP := statList[pl_statIdx].statData.percentileP.valueP;
  statList[pl_statIdx].statData.percentileP := { vl_densityIdx, vl_maxIdx, 0.0, 0, 0, 0, -1.0, vl_valueP, vl_createdValuePVarIdx };
  
  f_EPTF_StatMeasure_initStatValue(vl_densityIdx);
  f_EPTF_StatMeasure_initStatValue(vl_maxIdx);

  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_addData_percentileP
// 
//  Purpose:
//    Add new data for the 'percentileP' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was given when the statistics was created, 
//    this function can be used to add new data.
//    If the statistics was created for an existing EPTF Variable data will be
//    automatically added when the value of the variable is refreshed. But 
//    this function can be used to add additional data also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_addData_percentileP(
  in integer pl_statIdx, 
  in float pl_newData) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }

  f_EPTF_StatMeasure_debug( "AddData: PercentileP: (" & 
    int2str(pl_statIdx) & ")");

  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentileP));

  var integer vl_densityIdx := 
    statList[pl_statIdx].statData.percentileP.densityIdx;

  var integer vl_maxIdx := 
    statList[pl_statIdx].statData.percentileP.maxIdx;

  var float vl_valueP := 
    statList[pl_statIdx].statData.percentileP.valueP;

  // RESET
  if (statList[pl_statIdx].reset) 
  {
    f_EPTF_StatMeasure_debug( "Reset");
    f_EPTF_StatMeasure_debug( "New value: " & float2str(pl_newData));
    f_EPTF_StatMeasure_debug( "Init percentileP: " & 
      log2str(statList[pl_statIdx].statData.percentileP));
    f_EPTF_StatMeasure_debug( "Init density: " & 
      log2str(statList[vl_densityIdx].statData.density));
    f_EPTF_StatMeasure_debug( "Init max: " & 
      log2str(statList[vl_maxIdx].statData.max));

    statList[pl_statIdx].reset := false;

    f_EPTF_StatMeasure_resetStat_max(vl_maxIdx); // reset max also
    f_EPTF_StatMeasure_resetStat_density(vl_densityIdx); // reset density also

    statList[pl_statIdx].statData.percentileP := 
      { vl_densityIdx, vl_maxIdx, 0.0, 0, 0, 0, -1.0, vl_valueP, -1 };
    f_EPTF_StatMeasure_addData_percentileP(pl_statIdx, pl_newData);
    return;
  }  

  f_EPTF_StatMeasure_debug( "AddData");
  f_EPTF_StatMeasure_debug( "New value: " & float2str(pl_newData));
  f_EPTF_StatMeasure_debug( "Current percentileP: " & 
    log2str(statList[pl_statIdx].statData.percentileP));
  f_EPTF_StatMeasure_debug( "Current density: " & 
    log2str(statList[vl_densityIdx].statData.density));
  f_EPTF_StatMeasure_debug( "Current max: " & 
      log2str(statList[vl_maxIdx].statData.max));

  // ADD DATA
  // update density:
  statList[vl_densityIdx].enabled := true;
  f_EPTF_StatMeasure_addData_density(vl_densityIdx, pl_newData);
  statList[vl_densityIdx].enabled := false;

  // update max
  statList[vl_maxIdx].enabled := true;
  f_EPTF_StatMeasure_addData_max(vl_maxIdx, { floatVal := pl_newData });
  statList[vl_maxIdx].enabled := false;

  f_EPTF_StatMeasure_debug( "Updated density: " &
    log2str(statList[vl_densityIdx].statData.density));

  f_EPTF_StatMeasure_debug( "Updated max: " &
    log2str(statList[vl_maxIdx].statData.max));

  // if no boundaries, stat value is the highest element
  if (sizeof(statList[vl_densityIdx].statData.density.boundaries) == 0) { 
    var EPTF_Var_DirectContent vl_dc;
    if (not f_EPTF_StatMeasure_getStat_max(vl_maxIdx, vl_dc)) {/*always available*/};

    statList[pl_statIdx].statData.percentileP.statValue := vl_dc.floatVal; // must be float

    return;
  }

  // gather values
  var integer vl_bidx, vl_lo, vl_cur, vl_hi, vl_lim, vl_intpos;
  var float vl_pos;  

  vl_pos := statList[pl_statIdx].statData.percentileP.pos;      // float position of P% percent element

  vl_bidx := statList[pl_statIdx].statData.percentileP.curBIdx; // index of current boundary selected as stat value
  vl_lo   := statList[pl_statIdx].statData.percentileP.lower;   // sum of elements below actual P% interval
  vl_cur  := statList[pl_statIdx].statData.percentileP.current; // sum of elements in actual P% interval

  vl_lim := sizeof(statList[vl_densityIdx].statData.density.statValue);   // number of intervals (containing <, ..., > intervals)

  vl_pos := vl_pos + vl_valueP * 0.999999999999999; // incrementally calculate P% element,  .999999999999999 is used to avoid numerical errors
  // eg: 95% -> 0.949999999999999
  f_EPTF_StatMeasure_debug( "Before update: vl_lo: " & 
    int2str(vl_lo) & " vl_cur: " & int2str(vl_cur));

  // update incrementally necessary auxilary data (categorization is similar to density: [ low limit, high limit )
  if (vl_bidx > 0 and pl_newData < statList[vl_densityIdx].statData.density.boundaries[vl_bidx-1]) 
  { 
    vl_lo := vl_lo + 1; 
  }
  else if (vl_bidx == vl_lim -1 or (vl_bidx < vl_lim - 1 and pl_newData < statList[vl_densityIdx].statData.density.boundaries[vl_bidx])) 
  { 
    vl_cur := vl_cur + 1;     
  }

  vl_hi := vl_lo + vl_cur;

  f_EPTF_StatMeasure_debug( "After update: vl_lo: " & 
    int2str(vl_lo) & " vl_cur: " & int2str(vl_cur));

  // P% element -> task: localize the interval containing this element and provide its higher limit  
  vl_intpos := f_ceil(vl_pos);

  f_EPTF_StatMeasure_debug( "Integer position (vl_inpost): " &
    int2str(vl_intpos));

  // CASE 1  
  // element is in a range lower then the current one: search left
  if (vl_intpos <= vl_lo) // possible only if we are not in the lowest range (x < boundaries[0])
  {    
    f_EPTF_Base_assert("Invalid boundary index (LO).", vl_bidx > 0);

    f_EPTF_StatMeasure_debug( "Left search"); 

    var boolean vl_notfound := true;

    vl_bidx := vl_bidx - 1; // vl_lo is 0 for the lowest range, if vl_intpos < vl_lo is true, we can go left
    while (vl_bidx >= 0 and vl_notfound)
    {
      vl_lo := vl_lo - statList[vl_densityIdx].statData.density.statValue[vl_bidx];          
      if (vl_intpos > vl_lo) { vl_notfound := false; }
      else { vl_bidx := vl_bidx - 1; }
    }

    if (vl_notfound == false) {
      vl_cur := statList[vl_densityIdx].statData.density.statValue[vl_bidx];
    }

    f_EPTF_StatMeasure_debug( "Final boundary index (vl_bidx): " & 
      int2str(vl_bidx));

    statList[pl_statIdx].statData.percentileP.statValue := 
      statList[vl_densityIdx].statData.density.boundaries[vl_bidx];
    //statList[pl_statIdx].statData.percentileP.pos := vl_pos;
    statList[pl_statIdx].statData.percentileP.curBIdx := vl_bidx;
    statList[pl_statIdx].statData.percentileP.lower   := vl_lo;
    statList[pl_statIdx].statData.percentileP.current := vl_cur;

    f_EPTF_StatMeasure_debug( "vl_lo + vl_cur: " & int2str(vl_lo + vl_cur));
  }
  else

  // CASE 2
  if (vl_intpos <= vl_hi)
  {    
    if (vl_bidx < vl_lim - 1) { // we are not in the highest interval
      statList[pl_statIdx].statData.percentileP.statValue := 
        statList[vl_densityIdx].statData.density.boundaries[vl_bidx];
    }
    else { // in the highest interval, stat value is the highest element
      var EPTF_Var_DirectContent vl_dc;
      if (not f_EPTF_StatMeasure_getStat_max(vl_maxIdx, vl_dc)) {/*always available*/};
      
      statList[pl_statIdx].statData.percentileP.statValue := vl_dc.floatVal; // must be float
    }
  }
  else

  // CASE 3
  // element is in a range higher then the current one: search right
  if (vl_intpos > vl_hi) 
  {    
    f_EPTF_Base_assert("Invalid boundary index (CUR).", vl_bidx < vl_lim);

    f_EPTF_StatMeasure_debug( "Right search");

    // if we are in the highest interval (above something), stat value is the highest element
    if (vl_bidx == vl_lim - 1) 
    {
      var EPTF_Var_DirectContent vl_dc;
      if (not f_EPTF_StatMeasure_getStat_max(vl_maxIdx, vl_dc)) {/*always available*/};
      
      statList[pl_statIdx].statData.percentileP.statValue := vl_dc.floatVal; // must be float
        
    }
    // otherwise search right to found the P% interval
    else
    {
      var boolean vl_notfound := true;
        

      f_EPTF_StatMeasure_debug( "Density size: " & int2str(vl_lim));

      vl_bidx := vl_bidx + 1;

      while (vl_bidx < vl_lim - 1 and vl_notfound)
      {                             
        vl_hi := vl_hi + statList[vl_densityIdx].statData.density.statValue[vl_bidx];

        f_EPTF_StatMeasure_debug( "While indices: bidx: " &
          int2str(vl_bidx) & " vl_hi: " & int2str(vl_hi));          

        if (vl_intpos <= vl_hi) { 
          vl_notfound := false; 
        } else { 
          vl_bidx := vl_bidx + 1; 
        }          
      }

      if (vl_notfound == false) { // found not in the last range          
        statList[pl_statIdx].statData.percentileP.statValue := 
          statList[vl_densityIdx].statData.density.boundaries[vl_bidx];                      

        vl_cur := statList[vl_densityIdx].statData.density.statValue[vl_bidx];
        vl_lo  := vl_hi - vl_cur;
      } 
      else { // found in the last range (above some value)          
        statList[pl_statIdx].statData.percentileP.statValue := -1.0;

        vl_bidx := vl_lim - 1;
        vl_cur := statList[vl_densityIdx].statData.density.statValue[vl_bidx];
          //vl_lo  := vl_tmp - vl_cur; // no change
      }

      f_EPTF_StatMeasure_debug( "Final bidx: " & int2str(vl_bidx));                          
    }      
  }        

  statList[pl_statIdx].statData.percentileP.pos     := vl_pos; // position value is always updated
  statList[pl_statIdx].statData.percentileP.curBIdx := vl_bidx;
  statList[pl_statIdx].statData.percentileP.lower   := vl_lo;
  statList[pl_statIdx].statData.percentileP.current := vl_cur;

  f_EPTF_StatMeasure_debug( "PercentileP (" & int2str(pl_statIdx) & ") results");
  f_EPTF_StatMeasure_debug( "Statistics: " & log2str(statList[pl_statIdx]));
  f_EPTF_StatMeasure_debug( "Density: " & log2str(statList[vl_densityIdx].statData.density));
  f_EPTF_StatMeasure_debug( "Detailed data: boundary index: " & int2str(vl_bidx) &
    " pos: " & float2str(vl_pos) & " lo: " & int2str(vl_lo) & " cur: " & int2str(vl_cur));
  f_EPTF_StatMeasure_debug( "Stat value: " & float2str(
      statList[pl_statIdx].statData.percentileP.statValue));

  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_enableStat_percentileP
// 
//  Purpose:
//    Enable 'percentileP' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_enableStat_percentileP(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := true;
  
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentileP));

  f_EPTF_Var_addPostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_percentileP_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_disableStat_percentileP
// 
//  Purpose:
//    Disable 'percentileP' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_disableStat_percentileP(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }

  statList[pl_statIdx].enabled := false;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  
  f_EPTF_Var_removePostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_percentileP_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_percentileP
// 
//  Purpose:
//    Returns the value of the 'percentileP' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_statValue - *out* <EPTF_Var_DirectContent> - the value of the stat
//
//  Return Value:
//    *boolean* - true if stat is available, false if no
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_percentileP(
  in integer pl_statIdx, 
  out float pl_statValue) 
runs on EPTF_StatMeasure_CT return boolean 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentileP));

  pl_statValue := statList[pl_statIdx].statData.percentileP.statValue;
    
  return f_EPTF_StatMeasure_valueIsAvailable(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStatIdx_density_percentileP
// 
//  Purpose:
//    Returns the idx of the 'density' statistics belonging to the given 
//   'percentileP' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the 'percentileP' statistics
//
//  Return Value:
//    *integer* - the idx of the 'density' statistics belonging to the given 
//                'percentileP' statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Do not reset or disable this statistics!
//    This index is provided only to get the value as a charstring of 
//    the mean statistics created automatically for percentileP.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStatIdx_density_percentileP(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return integer 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentileP));
  
  return statList[pl_statIdx].statData.percentileP.densityIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStatIdx_max_percentileP
// 
//  Purpose:
//    Returns the idx of the 'max' statistics belonging to the given 
//   'percentileP' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the 'percentileP' statistics
//
//  Return Value:
//    *integer* - the idx of the 'max' statistics belonging to the given 
//                'percentileP' statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Do not reset or disable this statistics!
//    This index is provided only to get the value as a charstring of 
//    the mean statistics created automatically for percentileP.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStatIdx_max_percentileP(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return integer 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentileP));
  
  return statList[pl_statIdx].statData.percentileP.maxIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_percentileP2str
// 
//  Purpose:
//    Returns the value of the 'percentileP' statistics as a charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *charstring* - the value of the statistics as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_percentileP2str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  var float vl_floatValue;
  if (f_EPTF_StatMeasure_getStat_percentileP(pl_statIdx, vl_floatValue)) {
    return f_EPTF_Var_directContent2str({ floatVal := vl_floatValue });
  } else {
    return "N/A";
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_createVarFromStat_max_percentileP
// 
//  Purpose:
//    Creates EPTF variable from the 'max' statistics of the 'percentileP' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the percentileP stat
//    pl_varName - *in* *charstring* - the name of the created variable 
//                   (if empty: name is auto-generated). Default: empty
//
//  Return Value:
//    *integer* - the idx of the EPTF Variable that contains the max value
//
//  Errors:
//    -
//
//  Detailed Comments:
//    -
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_createVarFromStat_max_percentileP(
  in integer pl_statIdx,
  in charstring pl_varName := ""
) runs on EPTF_StatMeasure_CT return integer
{
  // check type of stat:
  f_EPTF_Base_assert(%definitionId&": Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentileP));
  
  var integer vl_statIdx := statList[pl_statIdx].statData.percentileP.maxIdx;
  return f_EPTF_StatMeasure_createVarFromStat(vl_statIdx, pl_varName);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_createVarFromStat_density_percentileP
// 
//  Purpose:
//    Creates EPTF variable from the 'density' statistics contained by the 'percentileP' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the percentileP stat
//    pl_varName - *in* *charstring* - the name of the created variable 
//                   (if empty: name is auto-generated). Default: empty
//
//  Return Value:
//    *integer* - the idx of the EPTF Variable that contains the density value
//
//  Errors:
//    -
//
//  Detailed Comments:
//    -
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_createVarFromStat_density_percentileP(
  in integer pl_statIdx,
  in charstring pl_varName := ""
) runs on EPTF_StatMeasure_CT return integer
{
  // check type of stat:
  f_EPTF_Base_assert(%definitionId&": Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentileP));
  
  var integer vl_statIdx := statList[pl_statIdx].statData.percentileP.densityIdx;
  return f_EPTF_StatMeasure_createVarFromStat(vl_statIdx, pl_varName);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_createVarFromStat_boundaries_density_percentileP
// 
//  Purpose:
//    Creates EPTF variable from the boundaries of the 'density' statistics inside the 'percentileP' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the percentileP stat
//    pl_varName - *in* *charstring* - the name of the created variable 
//                   (if empty: name is auto-generated). Default: empty
//
//  Return Value:
//    *integer* - the idx of the EPTF Variable that contains the boundaries of the density stat
//
//  Errors:
//    -
//
//  Detailed Comments:
//    -
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_createVarFromStat_boundaries_density_percentileP(
  in integer pl_statIdx,
  in charstring pl_varName := ""
) runs on EPTF_StatMeasure_CT return integer
{
  // check type of stat:
  f_EPTF_Base_assert(%definitionId&": Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentileP));
  
  var integer vl_statIdx := statList[pl_statIdx].statData.percentileP.densityIdx;
  return f_EPTF_StatMeasure_createVarFromStat_boundaries_density(vl_statIdx, pl_varName);
}


///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_createVarFromStat_valueP_percentileP
// 
//  Purpose:
//    Creates EPTF variable from the stored percentileP value inside the 'percentileP' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the percentileP stat
//    pl_varName - *in* *charstring* - the name of the created variable 
//                   (if empty: name is auto-generated). Default: empty
//
//  Return Value:
//    *integer* - the idx of the EPTF Variable that contains the boundaries of the density stat
//
//  Errors:
//    -
//
//  Detailed Comments:
//    -
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_createVarFromStat_valueP_percentileP(
  in integer pl_statIdx,
  in charstring pl_varName := ""
) runs on EPTF_StatMeasure_CT return integer
{
  // check type of stat:
  f_EPTF_Base_assert(%definitionId&": Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentileP));
  
  // return the already created var index if it exists:
  if (statList[pl_statIdx].statData.percentileP.createdValuePVarIdx != -1) 
  {
    f_EPTF_StatMeasure_warning(log2str("Variable for the boundaries of stat ", 
        pl_statIdx, " (",statList[pl_statIdx],") already exists: ", 
        f_EPTF_Var_getName(statList[pl_statIdx].statData.percentileP.createdValuePVarIdx)));
    return statList[pl_statIdx].statData.percentileP.createdValuePVarIdx;
  }

  var integer vl_newVarIdx;

  // assign auto-name:
  var charstring vl_statName := pl_varName;
  if (vl_statName == "") {
    vl_statName := f_EPTF_StatMeasure_getStatName(pl_statIdx) & ".valueP";
  }

  //log("vl_statName: ",vl_statName);
  f_EPTF_StatMeasure_debug("vl_statName: "&vl_statName);

  vl_newVarIdx := f_EPTF_Var_getId(vl_statName);
  if (vl_newVarIdx!=-1) {
    return vl_newVarIdx; // var already created
  }

  f_EPTF_Var_newFloat(vl_statName, 
    statList[pl_statIdx].statData.percentileP.valueP,vl_newVarIdx);

  // store new var:
  statList[pl_statIdx].statData.percentileP.createdValuePVarIdx := vl_newVarIdx;


  return vl_newVarIdx;



}


} // group percentilePStat


///////////////////////////////////////////////////////////////////////////////
// Group: percentile95Stat
//
// Purpose:
//   Functions for the percentile95 stat
//
// Description:
//   The aim of this statistics is to measure the 95 percentile of the data values.
//   The value of the statistics is the value below which the 95% of the data values falls.
///////////////////////////////////////////////////////////////////////////////
group percentile95Stat {

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStat_percentile95
// 
//  Purpose:
//    Creates a new 'percentileP' statistics with 0.95 percentileP parameter for the EPTF Variable.
//
//  Parameters:
//    pl_boundaries - *in* <EPTF_FloatList> - the list of boundaries  
//    pl_varIdx - *in* *integer* - the idx of the EPTF variable 
//          (-1 to create stat without a variable). Default: -1
//
//  Return Value:
//    *integer* - the idx of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    -
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStat_percentile95(
  in EPTF_FloatList pl_boundaries,
  in integer pl_varIdx := -1) 
runs on EPTF_StatMeasure_CT return integer 
{
  // creating a percentileP stat
  var integer vl_percentilePIdx := f_EPTF_StatMeasure_newStat_percentileP(pl_boundaries, 0.95, pl_varIdx);

  f_EPTF_StatMeasure_disableStat_percentileP(vl_percentilePIdx); // disable percentileP: the percentile95's updateFunction will update it

  var integer vl_newStatIdx := sizeof(statList);

  statList[vl_newStatIdx] := { pl_varIdx, -1, 
    { percentile95 := { vl_percentilePIdx }}, false, true };

  f_EPTF_StatMeasure_resetStat_percentile95(vl_newStatIdx);
  // enable the stat:
  f_EPTF_StatMeasure_enableStat_percentile95(vl_newStatIdx);
  
  return vl_newStatIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_setBoundaries_percentile95
// 
//  Purpose:
//    Sets new boundaries for the percentile95 statistics. Also resets the stat.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_boundaries - *in* <EPTF_FloatList> - the list of boundaries
//    pl_enableUpdate - *in boolean* - if false the EPTF Variable created for 
//                        the boundaries will not be refreshed. Default: true
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_setBoundaries_percentile95(
  in integer pl_statIdx, 
  in EPTF_FloatList pl_boundaries, 
  in boolean pl_enableUpdate := true) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_resetStat_percentile95(pl_statIdx);
  var integer vl_percentilePIdx := statList[pl_statIdx].statData.percentile95.percentilePIdx;
  f_EPTF_StatMeasure_setBoundaries_percentileP( vl_percentilePIdx, pl_boundaries, pl_enableUpdate );
  
  f_EPTF_StatMeasure_debug( "PercentileP statistics for Percentile95 (" & 
    int2str(vl_percentilePIdx) & "): " & log2str(statList[vl_percentilePIdx]));  
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_setScale_percentile95
// 
//  Purpose:
//    Sets boundaries automatically between min and max on linear/logarithmic 
//    scale for the 'percentile95' statistics. Also resets the stat.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_min - *in* *float* - the lowest boundary
//    pl_max - *in* *float* - the highest boundary
//    pl_n - *in* *integer* - the number of elements in the boudary list
//                            (should be 1 or more)
//    pl_scale - *in* <EPTF_StatMeasure_density_scale> - the scale to be used 
//                                      between min and max (default: linear)
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_setScale_percentile95(
  in integer pl_statIdx, 
  in float pl_min, 
  in float pl_max, 
  in integer pl_n, 
  in EPTF_StatMeasure_density_scale pl_scale := linear) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_resetStat_percentile95(pl_statIdx);
  var integer vl_percentilePIdx := statList[pl_statIdx].statData.percentile95.percentilePIdx;
  f_EPTF_StatMeasure_setScale_percentileP( vl_percentilePIdx, pl_min, pl_max, pl_n, pl_scale);
  
  f_EPTF_StatMeasure_debug( "PercentileP statistics for Percentile95 (" & 
    int2str(vl_percentilePIdx) & "): " & log2str(statList[vl_percentilePIdx]));   
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStat_percentile95
// 
//  Purpose:
//    Reset 'percentile95' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    -
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStat_percentile95(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  statList[pl_statIdx].reset := true;

  var integer vl_percentilePIdx := statList[pl_statIdx].statData.percentile95.percentilePIdx; 
  f_EPTF_StatMeasure_resetStat_percentileP(vl_percentilePIdx); 
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initStatValue_percentile95
// 
//  Purpose:
//    Initializes the value of 'percentile95' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Stat is initialized with zero.
//    The created variable is also updated. 
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_initStatValue_percentile95(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_resetStat_percentile95(pl_statIdx);

  var integer vl_percentilePIdx := statList[pl_statIdx].statData.percentile95.percentilePIdx; 
  f_EPTF_StatMeasure_initStatValue_percentileP(vl_percentilePIdx); 
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_addData_percentile95
// 
//  Purpose:
//    Add new data for the 'percentile95' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was given when the statistics was created, 
//    this function can be used to add new data.
//    If the statistics was created for an existing EPTF Variable data will be
//    automatically added when the value of the variable is refreshed. But 
//    this function can be used to add additional data also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_addData_percentile95(
  in integer pl_statIdx, 
  in float pl_newData) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }

  f_EPTF_StatMeasure_debug( "AddData: Percentile95: (" & 
    int2str(pl_statIdx) & ")");

  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentile95));


  // RESET
  if (statList[pl_statIdx].reset) 
  {
    f_EPTF_StatMeasure_debug( "Reset");
    f_EPTF_StatMeasure_debug( "New value: " & float2str(pl_newData));
    f_EPTF_StatMeasure_debug( "Init percentile95: " & 
      log2str(statList[pl_statIdx].statData.percentile95));

    statList[pl_statIdx].reset := false;
  } 

  var integer vl_percentilePIdx := statList[pl_statIdx].statData.percentile95.percentilePIdx;
  
  statList[vl_percentilePIdx].enabled := true;  
  f_EPTF_StatMeasure_addData_percentileP( vl_percentilePIdx, pl_newData);
  statList[vl_percentilePIdx].enabled := false;  
  
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);     
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_enableStat_percentile95
// 
//  Purpose:
//    Enable 'percentile95' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_enableStat_percentile95(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := true;

  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentile95));

  f_EPTF_Var_addPostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_percentile95_PostProc), {pl_statIdx}});

  //var integer vl_percentilePIdx := statList[pl_statIdx].statData.percentile95.percentilePIdx;
  //f_EPTF_StatMeasure_enableStat_percentileP( vl_percentilePIdx );
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_disableStat_percentile95
// 
//  Purpose:
//    Disable 'percentile95' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_disableStat_percentile95(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := false;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  
  f_EPTF_Var_removePostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_percentile95_PostProc), {pl_statIdx}});

  //var integer vl_percentilePIdx := statList[pl_statIdx].statData.percentile95.percentilePIdx;  
  //f_EPTF_StatMeasure_disableStat_percentileP( vl_percentilePIdx );
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_percentile95
// 
//  Purpose:
//    Returns the value of the 'percentile95' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_statValue - *out* <EPTF_Var_DirectContent> - the value of the stat
//
//  Return Value:
//    *boolean* - true if stat is available, false if no
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_percentile95(
  in integer pl_statIdx, 
  out float pl_statValue) 
runs on EPTF_StatMeasure_CT return boolean 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentile95));

  var integer vl_percentilePIdx := statList[pl_statIdx].statData.percentile95.percentilePIdx;
  return f_EPTF_StatMeasure_getStat_percentileP( vl_percentilePIdx, pl_statValue );
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStatIdx_density_percentile95
// 
//  Purpose:
//    Returns the idx of the 'density' statistics belonging to the given 
//   'percentile95' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the 'percentile95' statistics
//
//  Return Value:
//    *integer* - the idx of the 'density' statistics belonging to the given 
//                'percentile95' statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Do not reset or disable this statistics!
//    This index is provided only to get the value as a charstring of 
//    the mean statistics created automatically for percentile95.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStatIdx_density_percentile95(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return integer 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentile95));

  var integer vl_percentilePIdx := statList[pl_statIdx].statData.percentile95.percentilePIdx;
  return f_EPTF_StatMeasure_getStatIdx_density_percentileP( vl_percentilePIdx );
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStatIdx_max_percentile95
// 
//  Purpose:
//    Returns the idx of the 'max' statistics belonging to the given 
//   'percentile95' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the 'percentile95' statistics
//
//  Return Value:
//    *integer* - the idx of the 'max' statistics belonging to the given 
//                'percentile95' statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Do not reset or disable this statistics!
//    This index is provided only to get the value as a charstring of 
//    the mean statistics created automatically for percentile95.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStatIdx_max_percentile95(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return integer 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentile95));

  var integer vl_percentilePIdx := statList[pl_statIdx].statData.percentile95.percentilePIdx;
  return f_EPTF_StatMeasure_getStatIdx_max_percentileP( vl_percentilePIdx );
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_percentile952str
// 
//  Purpose:
//    Returns the value of the 'percentile95' statistics as a charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *charstring* - the value of the statistics as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_percentile952str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentile95));
    
  var integer vl_percentilePIdx := statList[pl_statIdx].statData.percentile95.percentilePIdx;
  return f_EPTF_StatMeasure_percentileP2str( vl_percentilePIdx );
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_createVarFromStat_max_percentile95
// 
//  Purpose:
//    Creates EPTF variable from the 'max' statistics of the 'percentile95' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the percentile95 stat
//    pl_varName - *in* *charstring* - the name of the created variable 
//                   (if empty: name is auto-generated). Default: empty
//
//  Return Value:
//    *integer* - the idx of the EPTF Variable that contains the max value
//
//  Errors:
//    -
//
//  Detailed Comments:
//    -
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_createVarFromStat_max_percentile95(
  in integer pl_statIdx,
  in charstring pl_varName := ""
) runs on EPTF_StatMeasure_CT return integer
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentile95));

  var integer vl_percentilePIdx := statList[pl_statIdx].statData.percentile95.percentilePIdx;
  return f_EPTF_StatMeasure_createVarFromStat_max_percentileP( vl_percentilePIdx, pl_varName );
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_createVarFromStat_density_percentile95
// 
//  Purpose:
//    Creates EPTF variable from the 'density' statistics contained by the 'percentile95' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the percentile95 stat
//    pl_varName - *in* *charstring* - the name of the created variable 
//                   (if empty: name is auto-generated). Default: empty
//
//  Return Value:
//    *integer* - the idx of the EPTF Variable that contains the density value
//
//  Errors:
//    -
//
//  Detailed Comments:
//    -
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_createVarFromStat_density_percentile95(
  in integer pl_statIdx,
  in charstring pl_varName := ""
) runs on EPTF_StatMeasure_CT return integer
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentile95));

  var integer vl_percentilePIdx := statList[pl_statIdx].statData.percentile95.percentilePIdx;
  return f_EPTF_StatMeasure_createVarFromStat_density_percentileP( vl_percentilePIdx, pl_varName );
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_createVarFromStat_boundaries_density_percentile95
// 
//  Purpose:
//    Creates EPTF variable from the boundaries of the 'density' statistics inside the 'percentile95' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the percentile95 stat
//    pl_varName - *in* *charstring* - the name of the created variable 
//                   (if empty: name is auto-generated). Default: empty
//
//  Return Value:
//    *integer* - the idx of the EPTF Variable that contains the boundaries of the density stat
//
//  Errors:
//    -
//
//  Detailed Comments:
//    -
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_createVarFromStat_boundaries_density_percentile95(
  in integer pl_statIdx,
  in charstring pl_varName := ""
) runs on EPTF_StatMeasure_CT return integer
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.percentile95));

  var integer vl_percentilePIdx := statList[pl_statIdx].statData.percentile95.percentilePIdx;
  return f_EPTF_StatMeasure_createVarFromStat_boundaries_density_percentileP( vl_percentilePIdx, pl_varName );
}

} // group percentile95Stat


///////////////////////////////////////////////////////////////////////////////
// Group: limitsStat
//
// Purpose:
//   Functions for the percentile95 stat
//
// Description:
//   The aim of this statistics is to measure the 95 percentile of the data values.
//   The value of the statistics is the value below which the 95% of the data values falls.
///////////////////////////////////////////////////////////////////////////////
group limitsStat{

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStat_limits
// 
//  Purpose:
//    Creates a new 'percentileP' statistics with 0.95 percentileP parameter for the EPTF Variable.
//
//  Parameters:
//    pl_limits - *in* <EPTF_StatMeasure_LimitList> - the list of limits for different LEDColors  
//    pl_referenceVarIdx - *in* *integer* - the idx of the reference EPTF variable:
//           to calculate relative value. Default: -1 (== absolute value)
//    pl_defaultColor - *in* <EPTF_LEDColor> - the default color of the LED (Default: black)
//    pl_varIdx - *in* *integer* - the idx of the EPTF variable 
//          (-1 to create stat without a variable). Default: -1
//
//  Return Value:
//    *integer* - the idx of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    -
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStat_limits(
  in integer pl_varIdx := -1,
  in EPTF_StatMeasure_LimitList pl_limits := {},
  in integer pl_referenceVarIdx := -1,
  in EPTF_LEDColors  pl_defaultColor := led_black,
  in boolean pl_enableValueInLEDText := false
) runs on EPTF_StatMeasure_CT return integer 
{
  
  // check variable type:
  if (pl_varIdx != -1) {
    var EPTF_Var_DirectContent vl_contentNew;
    f_EPTF_Var_getContent(pl_varIdx,vl_contentNew);

    f_EPTF_Base_assert(%definitionId&": Cannot create limits stat: Variable type should be float or int: Invalid variable type for stat-variable: "& f_EPTF_Var_getName(pl_varIdx),
      ischosen(vl_contentNew.floatVal) or ischosen(vl_contentNew.intVal));    
  }
  // check reference variable type:
  if (pl_referenceVarIdx != -1) {
    var EPTF_Var_DirectContent vl_contentNew;
    f_EPTF_Var_getContent(pl_referenceVarIdx,vl_contentNew);

    f_EPTF_Base_assert(%definitionId&": Cannot create limits stat: Reference variable type should be float or int: Invalid variable type for reference-variable: "& f_EPTF_Var_getName(pl_referenceVarIdx),
      ischosen(vl_contentNew.floatVal) or ischosen(vl_contentNew.intVal));    
  }

  
  var integer vl_newStatIdx := sizeof(statList);

  // sort the limit values:
  f_EPTF_StatMeasure_bubblesort_LimitList(pl_limits);

  statList[vl_newStatIdx] := { pl_varIdx, -1, 
    { limits := { pl_referenceVarIdx, pl_limits, pl_defaultColor, pl_enableValueInLEDText, {pl_defaultColor, ""} }}, false, true };

  f_EPTF_StatMeasure_resetStat_limits(vl_newStatIdx);
  // enable the stat:
  f_EPTF_StatMeasure_enableStat_limits(vl_newStatIdx);
  
  return vl_newStatIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_setLimits_limits
// 
//  Purpose:
//    Sets new limits for the limits statistics. Also resets the stat.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_limits - *in* <EPTF_StatMeasure_LimitList> - the list of limits
//    pl_enableUpdate - *in boolean* - if false the EPTF Variable created for 
//                        the boundaries will not be refreshed. Default: true
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_setLimits_limits(
  in integer pl_statIdx, 
  in EPTF_StatMeasure_LimitList pl_limits, 
  in boolean pl_enableUpdate := true) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.limits));

  // sort the limit values:
  f_EPTF_StatMeasure_bubblesort_LimitList(pl_limits);

  if (statList[pl_statIdx].statData.limits.limits==pl_limits) {
    return; // same boundary was set => nothing to do (e.g. sampledAtSync subscription)
  }
  
  statList[pl_statIdx].statData.limits.limits := pl_limits;
  f_EPTF_StatMeasure_resetStat_limits(pl_statIdx);

  // initialize the value:
  f_EPTF_StatMeasure_initValue_limits(pl_statIdx);
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx,pl_enableUpdate);

}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getLimits_limits
// 
//  Purpose:
//    Returns the limits for the limits statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    <EPTF_FloatList> - the list of boundaries
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getLimits_limits(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return EPTF_StatMeasure_LimitList
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.limits));
  return statList[pl_statIdx].statData.limits.limits;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initValue_limits
// 
//  Purpose:
//    Initializes the value for the limits statistics based on the limits value.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_initValue_limits(
  in integer pl_statIdx
) runs on EPTF_StatMeasure_CT {
  // initialize the value:
  statList[pl_statIdx].statData.limits.statValue := {statList[pl_statIdx].statData.limits.defaultColor, ""};
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStat_limits
// 
//  Purpose:
//    Reset 'limits' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    -
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStat_limits(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  statList[pl_statIdx].reset := true;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_initStatValue_limits
// 
//  Purpose:
//    Initializes the value of 'limits' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Stat is initialized with default color.
//    The created variable is also updated. 
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_initStatValue_limits(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_resetStat_limits(pl_statIdx);

  f_EPTF_StatMeasure_initValue_limits(pl_statIdx);

  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

// converts limitItem to LedColor
private function f_EPTF_StatMeasure_limit2color(in EPTF_StatMeasure_LimitItem pl_limitItem) return EPTF_LEDColors {
  if (ischosen(pl_limitItem.blueLimit)) {
    return led_blue;
  }
  if (ischosen(pl_limitItem.blackLimit)) {
    return led_black;
  }
  if (ischosen(pl_limitItem.yellowLimit)) {
    return led_yellow;
  }
  if (ischosen(pl_limitItem.greenLimit)) {
    return led_green;
  }
  if (ischosen(pl_limitItem.redLimit)) {
    return led_red;
  } else {
    // never reached
  }
  // never reached
  return led_black;
}

// converts limitItem to LedColor
private function f_EPTF_StatMeasure_limit2float(in EPTF_StatMeasure_LimitItem pl_limitItem) return float {
  if (ischosen(pl_limitItem.blueLimit)) {
    return pl_limitItem.blueLimit;
  }
  if (ischosen(pl_limitItem.blackLimit)) {
    return pl_limitItem.blackLimit;
  }
  if (ischosen(pl_limitItem.yellowLimit)) {
    return pl_limitItem.yellowLimit;
  }
  if (ischosen(pl_limitItem.greenLimit)) {
    return pl_limitItem.greenLimit;
  }
  if (ischosen(pl_limitItem.redLimit)) {
    return pl_limitItem.redLimit;
  } else {
    // never reached
  }
  // never reached
  return 0.0;
}


///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_addData_limits
// 
//  Purpose:
//    Add new data for the 'limits' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was given when the statistics was created, 
//    this function can be used to add new data.
//    If the statistics was created for an existing EPTF Variable data will be
//    automatically added when the value of the variable is refreshed. But 
//    this function can be used to add additional data also.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_addData_limits(
  in integer pl_statIdx, 
  in float pl_newData) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }

  f_EPTF_StatMeasure_debug( "AddData: limits: (" & 
    int2str(pl_statIdx) & ")");

  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.limits));


  // RESET
  if (statList[pl_statIdx].reset) 
  {
    f_EPTF_StatMeasure_debug( "Reset");
    f_EPTF_StatMeasure_debug( "New value: " & float2str(pl_newData));
    f_EPTF_StatMeasure_debug( "Init limits: " & 
      log2str(statList[pl_statIdx].statData.limits));

    statList[pl_statIdx].reset := false;
  }
  
  statList[pl_statIdx].statData.limits.statValue.color := statList[pl_statIdx].statData.limits.defaultColor;
  statList[pl_statIdx].statData.limits.statValue.text := "";
  if (statList[pl_statIdx].statData.limits.enableValueInLEDText) {
    statList[pl_statIdx].statData.limits.statValue.text := float2str(pl_newData);
  }
  
  var integer vl_nofLimits := sizeof(statList[pl_statIdx].statData.limits.limits);
  
  // calculate relative value (in percentage) if referenceVar is given:
  if (statList[pl_statIdx].statData.limits.referenceVarId != -1) {
    var EPTF_Var_DirectContent vl_contentNew;
    f_EPTF_Var_getContent(statList[pl_statIdx].statData.limits.referenceVarId,vl_contentNew);

    var float x := 0.0;
    if (ischosen(vl_contentNew.intVal)) {
      x := int2float(vl_contentNew.intVal);
    } else if (ischosen(vl_contentNew.floatVal)) {
      x := vl_contentNew.floatVal;
    }
    
    if (x != 0.0) {
      pl_newData := 100.0*(pl_newData - x)/x; // calculate the precentage
    } else {
      // use the default color in case the value of the reference var is 0
      vl_nofLimits := 0; // not to enter for-loop: return with default value
    }
    
  }

  for(var integer i:=vl_nofLimits; i>0; i:=i-1) 
  {
    if (pl_newData>f_EPTF_StatMeasure_limit2float(statList[pl_statIdx].statData.limits.limits[i-1])) {
      statList[pl_statIdx].statData.limits.statValue.color :=
        f_EPTF_StatMeasure_limit2color(statList[pl_statIdx].statData.limits.limits[i-1]);
      i:=0; // end for cycle
    }
  }
  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_enableStat_limits
// 
//  Purpose:
//    Enable 'limits' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_enableStat_limits(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := true;

  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.limits));

  f_EPTF_Var_addPostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_limits_PostProc), {pl_statIdx}});

  if (statList[pl_statIdx].statData.limits.referenceVarId != -1) {
    f_EPTF_Var_addPostProcFn(statList[pl_statIdx].statData.limits.referenceVarId,
      {refers(f_EPTF_StatMeasure_update_limits_PostProc), {pl_statIdx, vl_varIdx}});
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_disableStat_limits
// 
//  Purpose:
//    Disable 'limits' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_disableStat_limits(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  if (not statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := false;
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }
  
  f_EPTF_Var_removePostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_limits_PostProc), {pl_statIdx}});

  if (statList[pl_statIdx].statData.limits.referenceVarId != -1) {
    f_EPTF_Var_removePostProcFn(statList[pl_statIdx].statData.limits.referenceVarId,
      {refers(f_EPTF_StatMeasure_update_limits_PostProc), {pl_statIdx, vl_varIdx}});
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_limits
// 
//  Purpose:
//    Returns the value of the 'limits' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_statValue - *out* <EPTF_Var_DirectContent> - the value of the stat
//
//  Return Value:
//    *boolean* - true if stat is available, false if no
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_limits(
  in integer pl_statIdx, 
  out EPTF_StatusLED pl_statValue) 
runs on EPTF_StatMeasure_CT return boolean 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.limits));

  pl_statValue := statList[pl_statIdx].statData.limits.statValue;
  return f_EPTF_StatMeasure_valueIsAvailable(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_limits2str
// 
//  Purpose:
//    Returns the value of the 'limits' statistics as a charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *charstring* - the value of the statistics as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_limits2str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.limits));
    
  var EPTF_StatusLED vl_currentContent;
  if (f_EPTF_StatMeasure_getStat_limits(pl_statIdx, vl_currentContent)) {
    return f_EPTF_Var_directContent2str({statusLEDVal := vl_currentContent});
  } else {
    return "N/A";
  }
}

} // group limitsStat

///////////////////////////////////////////////////////////////////////////////
// Group: customStat
//
// Purpose:
//   Functions for the customStat stat
//
// Description:
//   The aim of this statistics is to define a common interface for user-defined
//   custom statistics.
///////////////////////////////////////////////////////////////////////////////
group customStat {

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_newStat_custom
// 
//  Purpose:
//    Creates a new 'custom' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_varIdx - *in* *integer* - the idx of the EPTF variable 
//          (-1 to create stat without a variable). Default: -1
//    pl_statName - *in* *charstring* - name fo new custom statistics
//    pl_newStatFn - *in* <EPTF_StatMeasure_newStat_FT> - new stat function 
//                                            pointer (default value: null)
//    pl_newStatFnArgList - *inout* <EPTF_IntegerList> - new stat function  
//                                       argument list (default value: {})
//    pl_addDataFn - *in* <EPTF_StatMeasure_addData_FT> - add data function 
//                                           pointer (default value: null)
//    pl_addDataFnArgList - *inout* <EPTF_IntegerList> - add data function 
//                               function argument list (default value: {})
//    pl_getStatFn - *in* <EPTF_StatMeasure_getStat_FT> - get stat data 
//                                        pointer (default value: null)
//    pl_getStatFnArgList - *inout* <EPTF_IntegerList> - get stat data 
//                               function argument list (default value: {})
//    pl_stat2StrFn - *in* <EPTF_StatMeasure_stat2Str_FT> - stat data to string
//                                       function pointer (default value: null)
//    pl_stat2StrFnArgList - *inout* <EPTF_IntegerList> - stat data to string 
//                                  function argument list (default value: {})  
//    pl_createVarFromStatFn - *in* <EPTF_StatMeasure_createVarFromStat_FT> - 
//           create variable from stat function pointer (default value: null)
//    pl_createVarFromStatFnArgList - *inout* <EPTF_IntegerList> - create 
//                    variable from stat argument list (default value: {})   
//    pl_resetStatFn - *in* <EPTF_StatMesure_resetStat_FT> - reset stat function
//       variable from stat function argument list pointer (default value: null)
//    pl_resetStatFnArgList - *inout* <EPTF_IntegerList> - reset stat 
//                                   function argument list (default value: {})  
//    pl_enableStatFn - *in* <EPTF_StatMeasure_enableStat_FT> - enable stat 
//                                       function pointer (default value: null)
//    pl_enableStatFnArgList - *inout* <EPTF_IntegerList> - enable stat 
//                                   function argument list (default value: {})  
//    pl_disableStatFn - *in* <EPTF_StatMeasure_disableStat_FT> - disable stat 
//                                       function pointer (default value: null)
//    pl_disableStatFnArgList - *inout* <EPTF_IntegerList> - disable stat 
//                              function argument list (default value: {})  
//
//  Return Value:
//    *integer* - the idx of the new statistics
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Function calls user defined new custom stat function.
//
//    The following data is automatically stored in the stat database /statList/
//    (at the position of the return stat index):
//      - index of EPTF Variable from which the stat has been created
//      - stat type: pl_statType (return value of function
//                                f_EPTF_StatMeasure_registerCustomStat)
//      - enabled state: default false
//      - reset state: default true
//
//
//   Function resets and enables statistics
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_newStat_custom(
  in integer pl_varIdx := -1,
  in charstring pl_statName                           := "",
  in EPTF_StatMeasure_newStat_FT pl_newStatFn         := null,
  in EPTF_IntegerList pl_newStatFnArgList             := {},
  in EPTF_StatMeasure_addData_FT pl_addDataFn         := null, 
  in EPTF_IntegerList pl_addDataFnArgList             := {},  
  in EPTF_StatMeasure_getStat_FT pl_getStatFn         := null,
  in EPTF_IntegerList pl_getStatFnArgList             := {},
  in EPTF_StatMeasure_stat2Str_FT pl_stat2StrFn       := null, 
  in EPTF_IntegerList pl_stat2StrFnArgList            := {},
  in EPTF_StatMeasure_createVarFromStat_FT pl_createVarFromStatFn := null,
  in EPTF_IntegerList pl_createVarFromStatFnArgList   := {},
  in EPTF_StatMeasure_resetStat_FT pl_resetStatFn     := null, 
  in EPTF_IntegerList pl_resetStatFnArgList           := {},
  in EPTF_StatMeasure_enableStat_FT pl_enableStatFn   := null, 
  in EPTF_IntegerList pl_enableStatFnArgList          := {},
  in EPTF_StatMeasure_disableStat_FT pl_disableStatFn := null, 
  in EPTF_IntegerList pl_disableStatFnArgList         := {}) 
runs on EPTF_StatMeasure_CT return integer 
{    
  f_EPTF_StatMeasure_debug(
    "### " & %definitionId & "(): VAR: " & int2str(pl_varIdx) & 
    " / StatName: " & pl_statName);

  var charstring vl_statName;
  var integer vl_newStatIdx := sizeof(statList);

  if (pl_statName == "") { vl_statName := "custom_" & int2str(vl_newStatIdx); }
  else { vl_statName := pl_statName; }

  statList[vl_newStatIdx] := { pl_varIdx, -1, 
    { 
      custom := {
        statName      := vl_statName, // stat name
        newStatFn     := pl_newStatFn,  newStatFnArgList        := pl_newStatFnArgList,
        addDataFn     := pl_addDataFn,  addDataFnArgList        := pl_addDataFnArgList,         
        getStatFn     := pl_getStatFn,  getStatFnArgList        := pl_getStatFnArgList,
        stat2StrFn    := pl_stat2StrFn, stat2StrFnArgList       := pl_stat2StrFnArgList,
        createVarFromStatFn                                     := pl_createVarFromStatFn, 
        createVarFromStatFnArgList                              := pl_createVarFromStatFnArgList,
        resetStatFn   := pl_resetStatFn, resetStatFnArgList     := pl_resetStatFnArgList,
        enableStatFn  := pl_enableStatFn, enableStatFnArgList   := pl_enableStatFnArgList,
        disableStatFn := pl_disableStatFn, disableStatFnArgList := pl_disableStatFnArgList 
      }       
    }, 
    false, true };

  f_EPTF_StatMeasure_debug( "Resetting statistics "  & 
    log2str(statList[vl_newStatIdx].statData.custom.resetStatFn));

  f_EPTF_StatMeasure_resetStat_custom(vl_newStatIdx);

  f_EPTF_StatMeasure_debug( "Enabling statistics "  & 
    log2str(statList[vl_newStatIdx].statData.custom.enableStatFn));

  f_EPTF_StatMeasure_enableStat_custom(vl_newStatIdx);

  if (statList[vl_newStatIdx].statData.custom.newStatFn != null) {
    statList[vl_newStatIdx].statData.custom.newStatFn.apply(
      vl_newStatIdx, 
      pl_newStatFnArgList);
  }

  f_EPTF_StatMeasure_debug( 
    "New stat index: " & int2str(vl_newStatIdx));

  return vl_newStatIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_setProperties_custom
// 
//  Purpose:
//    Creates a new 'custom' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//         
//    pl_statName - *in* *charstring* - name fo new custom statistics
//    pl_newStatFn - *in* <EPTF_StatMeasure_newStat_FT> - new stat function 
//                                            pointer (default value: null)
//    pl_newStatFnArgList - *inout* <EPTF_IntegerList> - new stat function  
//                                       argument list (default value: {})
//    pl_addDataFn - *in* <EPTF_StatMeasure_addData_FT> - add data function 
//                                           pointer (default value: null)
//    pl_addDataFnArgList - *inout* <EPTF_IntegerList> - add data function 
//                               function argument list (default value: {})
//    pl_getStatFn - *in* <EPTF_StatMeasure_getStat_FT> - get stat data 
//                                        pointer (default value: null)
//    pl_getStatFnArgList - *inout* <EPTF_IntegerList> - get stat data 
//                               function argument list (default value: {})
//    pl_stat2StrFn - *in* <EPTF_StatMeasure_stat2Str_FT> - stat data to string
//                                       function pointer (default value: null)
//    pl_stat2StrFnArgList - *inout* <EPTF_IntegerList> - stat data to string 
//                                  function argument list (default value: {})  
//    pl_createVarFromStatFn - *in* <EPTF_StatMeasure_createVarFromStat_FT> - 
//           create variable from stat function pointer (default value: null)
//    pl_createVarFromStatFnArgList - *inout* <EPTF_IntegerList> - create 
//                    variable from stat argument list (default value: {})   
//    pl_resetStatFn - *in* <EPTF_StatMesure_resetStat_FT> - reset stat function
//       variable from stat function argument list pointer (default value: null)
//    pl_resetStatFnArgList - *inout* <EPTF_IntegerList> - reset stat 
//                                   function argument list (default value: {})  
//    pl_enableStatFn - *in* <EPTF_StatMeasure_enableStat_FT> - enable stat 
//                                       function pointer (default value: null)
//    pl_enableStatFnArgList - *inout* <EPTF_IntegerList> - enable stat 
//                                   function argument list (default value: {})  
//    pl_disableStatFn - *in* <EPTF_StatMeasure_disableStat_FT> - disable stat 
//                                       function pointer (default value: null)
//    pl_disableStatFnArgList - *inout* <EPTF_IntegerList> - disable stat 
//                              function argument list (default value: {})  
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Function registers the name of the custom statistics, its functions
//    and their arguments
//    Note that statistics name is generated automatically if not 
//    presented ("")
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_setProperties_custom(
  in integer pl_statIdx,
  in charstring pl_statName                           := "",
  in EPTF_StatMeasure_newStat_FT pl_newStatFn         := null,
  in EPTF_IntegerList pl_newStatFnArgList             := {},
  in EPTF_StatMeasure_addData_FT pl_addDataFn         := null, 
  in EPTF_IntegerList pl_addDataFnArgList             := {},  
  in EPTF_StatMeasure_getStat_FT pl_getStatFn         := null,
  in EPTF_IntegerList pl_getStatFnArgList             := {},
  in EPTF_StatMeasure_stat2Str_FT pl_stat2StrFn       := null, 
  in EPTF_IntegerList pl_stat2StrFnArgList            := {},
  in EPTF_StatMeasure_createVarFromStat_FT pl_createVarFromStatFn := null,
  in EPTF_IntegerList pl_createVarFromStatFnArgList   := {},
  in EPTF_StatMeasure_resetStat_FT pl_resetStatFn     := null, 
  in EPTF_IntegerList pl_resetStatFnArgList           := {},
  in EPTF_StatMeasure_enableStat_FT pl_enableStatFn   := null, 
  in EPTF_IntegerList pl_enableStatFnArgList          := {},
  in EPTF_StatMeasure_disableStat_FT pl_disableStatFn := null, 
  in EPTF_IntegerList pl_disableStatFnArgList         := {})
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_debug(
    "### " & %definitionId & "()"); 

  var charstring vl_statName;

  if (pl_statName == "") { vl_statName := "custom_" & int2str(pl_statIdx); }
  else { vl_statName := pl_statName; }

  statList[pl_statIdx].statData.custom := {
    statName      := vl_statName, // stat name
    newStatFn     := pl_newStatFn,  newStatFnArgList        := pl_newStatFnArgList,
    addDataFn     := pl_addDataFn,  addDataFnArgList        := pl_addDataFnArgList,         
    getStatFn     := pl_getStatFn,  getStatFnArgList        := pl_getStatFnArgList,
    stat2StrFn    := pl_stat2StrFn, stat2StrFnArgList       := pl_stat2StrFnArgList,
    createVarFromStatFn                                     := pl_createVarFromStatFn, 
    createVarFromStatFnArgList                              := pl_createVarFromStatFnArgList,
    resetStatFn   := pl_resetStatFn, resetStatFnArgList     := pl_resetStatFnArgList,
    enableStatFn  := pl_enableStatFn, enableStatFnArgList   := pl_enableStatFnArgList,
    disableStatFn := pl_disableStatFn, disableStatFnArgList := pl_disableStatFnArgList 
  };

  f_EPTF_StatMeasure_debug( "Resetting statistics "  & 
    log2str(statList[pl_statIdx].statData.custom.resetStatFn));

  f_EPTF_StatMeasure_resetStat_custom(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_resetStat_custom
// 
//  Purpose:
//    Reset 'custom' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Stat reset is automatically stored in the stat database /statList/
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_resetStat_custom(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_debug(
    "### " & %definitionId & "()");

  statList[pl_statIdx].reset := true;

  if (statList[pl_statIdx].statData.custom.resetStatFn != null) {
    statList[pl_statIdx].statData.custom.resetStatFn.apply(
      pl_statIdx,
      statList[pl_statIdx].statData.custom.resetStatFnArgList);
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_addData_custom
// 
//  Purpose:
//    Add new data for the 'custom' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    If no variable was given when the statistics was created, 
//    this function can be used to add new data.
//
//    If the statistics was created for an existing EPTF Variable data will be
//    automatically added when the value of the variable is refreshed. But 
//    this function can be used to add additional data also.
//
//    Function updates created variable if one is created from the 
//    statistics.
//
//    Function takes effect only if enable state is true in the stat 
//    database /statList/
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_addData_custom(
  in integer pl_statIdx, 
  in EPTF_Var_DirectContent pl_newData) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_debug(
    "### " & %definitionId & "(): NewData: " & log2str(pl_newData));

  if (statList[pl_statIdx].enabled == false) {
    return;
  }

  if (statList[pl_statIdx].statData.custom.addDataFn != null) {
    statList[pl_statIdx].statData.custom.addDataFn.apply(
      pl_statIdx,
      statList[pl_statIdx].statData.custom.addDataFnArgList,
      pl_newData);
  }

  f_EPTF_StatMeasure_updateCreatedVar(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_enableStat_custom
// 
//  Purpose:
//    Enable 'custom' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Function takes effect only if enable state is true in the stat 
//    database /statList/
//
//    If a variable is created from the statistics, the post processing 
//    function of custom statistics will be subscribed to it. The function
//    automatically calls <f_EPTF_StatMeasure_addData_custom> if the
//    variable changes.
//
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_enableStat_custom(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_debug(
    "### " & %definitionId & "()");

  if (statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := true;  

  if (statList[pl_statIdx].statData.custom.enableStatFn != null) {
    statList[pl_statIdx].statData.custom.enableStatFn.apply(
      pl_statIdx,
      statList[pl_statIdx].statData.custom.enableStatFnArgList); 
  }

  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }

  f_EPTF_StatMeasure_debug( "Adding post processing function to CUSTOM!");

  f_EPTF_Var_addPostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_custom_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_disableStat_custom
// 
//  Purpose:
//    Disable 'custom' statistics for the EPTF Variable.
//
//  Parameters:
//    pl_idx - *in* *integer* - the idx of the EPTF_Var
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Function takes effect only if enable state is true in the stat 
//    database /statList/
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_disableStat_custom(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_debug(
    "### " & %definitionId & "()");

  if (not statList[pl_statIdx].enabled) {
    return;
  }
  statList[pl_statIdx].enabled := false;

  if (statList[pl_statIdx].statData.custom.disableStatFn != null) {
    statList[pl_statIdx].statData.custom.disableStatFn.apply(
      pl_statIdx,
      statList[pl_statIdx].statData.custom.disableStatFnArgList);
  }

  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  if (vl_varIdx==-1) {
    return;
  }

  f_EPTF_StatMeasure_debug( "Removing post processing function from CUSTOM!");

  f_EPTF_Var_removePostProcFn(vl_varIdx,
    {refers(f_EPTF_StatMeasure_update_custom_PostProc), {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStat_custom
// 
//  Purpose:
//    Returns the value of the 'custom' statistics
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_statValue - *out* <EPTF_Var_DirectContent> - the value of the stat
//
//  Return Value:
//    *boolean* - true if stat is available, false if no (pl_statValue must
//                 be bound any case)
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStat_custom(
  in integer pl_statIdx, 
  out EPTF_Var_DirectContent pl_statValue) 
runs on EPTF_StatMeasure_CT return boolean 
{
  f_EPTF_StatMeasure_debug(
    "### " & %definitionId & "()");

  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.custom));

  if (statList[pl_statIdx].statData.custom.getStatFn != null) {
    return statList[pl_statIdx].statData.custom.getStatFn.apply(
      pl_statIdx,
      statList[pl_statIdx].statData.custom.getStatFnArgList, 
      pl_statValue);
  }
  else {
    f_EPTF_StatMeasure_error(
      "<f_EPTF_StatMeasure_getStat_custom> function for custom statistics (" & 
      f_EPTF_StatMeasure_getStatName(pl_statIdx) & ") is undefined!");
    f_EPTF_Base_stop();
  }

  return false;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_custom2str
// 
//  Purpose:
//    Returns the value of the 'delta' statistics as a charstring
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *charstring* - the value of the statistics as a charstring
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_custom2str(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  f_EPTF_StatMeasure_debug(
    "### " & %definitionId & "()");

  if (statList[pl_statIdx].statData.custom.stat2StrFn != null) {
    return statList[pl_statIdx].statData.custom.stat2StrFn.apply(
      pl_statIdx,
      statList[pl_statIdx].statData.custom.stat2StrFnArgList);
  } 
  else {
    return "Stat2str function undefined";
  }
} 

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_createVarFromStat_custom
// 
//  Purpose:
//    Create variable from 'custom' statistics.
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the statistics
//    pl_varName - *in* <charstring*> - variable name
//
//  Return Value:
//    *integer* - index of created variable
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Function calls registered 'createVarFromStatFn'  function. It should
//    create a variable with the provided name (pl_varName). The type of
//    this variable must be the type of the 'custom' statistics. The function
//    must return the index of the created variable.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_createVarFromStat_custom(
  in integer pl_statIdx, 
  in charstring pl_varName)
runs on EPTF_StatMeasure_CT return integer 
{
  f_EPTF_StatMeasure_debug(
    "### " & %definitionId & "()");

  if (statList[pl_statIdx].statData.custom.createVarFromStatFn != null) {
    return
      statList[pl_statIdx].statData.custom.createVarFromStatFn.apply(
        pl_statIdx,
        statList[pl_statIdx].statData.custom.createVarFromStatFnArgList,
      pl_varName);
  }
  else {
    return -1;
  }
}

} // group customStat
//..


///////////////////////////////////////////////////////////////////////////////
// private
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Group: Private
//
// Purpose:
//   Private functions. These functions must not be used by the user 
//   of <EPTF_StatMeasure_CT>
//
// Elements:
///////////////////////////////////////////////////////////////////////////////
group Private {


///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_registerCreatedVar
// 
//  Purpose:
//    Registers the new variable idx into the stat
//
//  Parameters:
//      pl_statIdx - *integer* -  index of the stat, 
//      pl_varIdx - *integer* -  index of the new EPTF Variable, created form the stat
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_registerCreatedVar(
  in integer pl_statIdx, 
  in integer pl_varIdx) 
runs on EPTF_StatMeasure_CT 
{
  // store new var idx:
  statList[pl_statIdx].createdVarIdx := pl_varIdx;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_updateCreatedVar
// 
//  Purpose:
//    Refreshes all created variables for the stat
//
//  Parameters:
//      pl_statIdx - *in* *integer* -  index of the stat, 
//      pl_enableRefresh - *in* *boolean* - if false: only the content of the 
//                created variables will be updated. The refresh mechanism is 
//                not initiated. Default: true
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_updateCreatedVar(
  in integer pl_statIdx, 
  in boolean pl_enableRefresh := true) 
runs on EPTF_StatMeasure_CT 
{
  //log("### f_EPTF_StatMeasure_updateCreatedVar()");
  
  if (statList[pl_statIdx].createdVarIdx==-1) {
    f_EPTF_StatMeasure_debug("No created var");
    return; // no created var
  }

  var EPTF_StatMeasure_statType vl_statType := 
    f_EPTF_StatMeasure_getStatType(pl_statIdx);
  if (vl_statType == content) {
    return; // do nothing content is there
  }

  var EPTF_Var_DirectContent pl_newContent;
  f_EPTF_StatMeasure_stat2Var(pl_statIdx,pl_newContent);
  f_EPTF_Var_setContent(statList[pl_statIdx].createdVarIdx,pl_newContent);
  if (pl_enableRefresh) {
    f_EPTF_Var_refreshContent(statList[pl_statIdx].createdVarIdx);
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_registerCreatedVarForBoundaries_density
// 
//  Purpose:
//    Registers the new variable idx into the stat
//
//  Parameters:
//      pl_statIdx - *integer* -  index of the stat, 
//      pl_varIdx - *integer* -  index of the new EPTF Variable, 
//                               created form the stat
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Stores the var index and
//    registers postProc function to update the boundaries of the statistics
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_registerCreatedVarForBoundaries_density(
  in integer pl_statIdx, 
  in integer pl_varIdx) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.density));

  // store new var:
  statList[pl_statIdx].statData.density.createdBoundaryVarIdx := pl_varIdx;

  // add postProc to update the stat:
  f_EPTF_Var_addPostProcFn(pl_varIdx,
    {refers(f_EPTF_StatMeasure_update_boundaries_density_PostProc), 
    {pl_statIdx}});
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_updateCreatedVarForBoundaries_density
// 
//  Purpose:
//    Refreshes the created variables for the boundaries of the given 
//    statistics
//
//  Parameters:
//      pl_statIdx - *in* *integer* -  index of the stat, 
//      pl_enableRefresh - *in* *boolean* - if false: only the content of 
//                     the created variables will be updated. The refresh 
//                     mechanism is not initiated. Default: true
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_updateCreatedVarForBoundaries_density(
  in integer pl_statIdx, 
  in boolean pl_enableRefresh := true) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.density));

  if (statList[pl_statIdx].statData.density.createdBoundaryVarIdx==-1) {
    return; // no variable created
  }

  var EPTF_Var_DirectContent pl_newContent;
  pl_newContent := { 
    floatlistVal := statList[pl_statIdx].statData.density.boundaries 
  };
  f_EPTF_Var_setContent(
    statList[pl_statIdx].statData.density.createdBoundaryVarIdx,pl_newContent);
  if (pl_enableRefresh) {
    f_EPTF_Var_refreshContent(
      statList[pl_statIdx].statData.density.createdBoundaryVarIdx);
  }
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_stat2Var
// 
//  Purpose:
//    Converts the value of any statistics to direct content to be set to the 
//    content of the assigned variable
//
//  Parameters:
//      pl_statIdx - *integer* -  index of the stat,
//
//  Return Value:
//    *boolean* - true if the value of the statistics is available
//
//  Errors:
//    -
//
//  Detailed Comments:
//    This function is used in the calcFn function of the variable created 
//    from the stat. Works for all statistics types.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_stat2Var(
  in integer pl_statIdx, 
  inout EPTF_Var_DirectContent pl_retVal) 
runs on EPTF_StatMeasure_CT 
{
  var EPTF_StatMeasure_statType vl_statType := 
    f_EPTF_StatMeasure_getStatType(pl_statIdx);

  f_EPTF_StatMeasure_debug( "Stattype: " & log2str(vl_statType));

  if (vl_statType == content) {
    return; // do nothing, content is there
  }

  // convert statValue to EPTF_Var_DirectContent:
  if (vl_statType == delta) {
    pl_retVal := statList[pl_statIdx].statData.delta.statValue;
  } else 
  if (vl_statType == deltaSum) {
    pl_retVal := statList[pl_statIdx].statData.deltaSum.statValue;
  } else 
  if (vl_statType == min) {
    pl_retVal := statList[pl_statIdx].statData.min.statValue;
  } else 
  if (vl_statType == max) {
    pl_retVal := statList[pl_statIdx].statData.max.statValue;
  } else 
  if (vl_statType == mean) {
    pl_retVal := { 
      floatVal := statList[pl_statIdx].statData.mean.statValue 
    };
  } else 
  if (vl_statType == standardDev) {
    pl_retVal := { 
      floatVal := statList[pl_statIdx].statData.standardDev.statValue 
    };
  } else 
  if (vl_statType == EPS) {
    pl_retVal := { 
      floatVal := statList[pl_statIdx].statData.EPS.statValue 
        };
  } else 
  if (vl_statType == chrono) {
    pl_retVal := { 
      floatVal := statList[pl_statIdx].statData.chrono.statValue 
    };
  } else 
  if (vl_statType == density) {
    pl_retVal := { 
      integerlistVal := statList[pl_statIdx].statData.density.statValue 
    };
  }
  if (vl_statType == percentileP) {
    pl_retVal := { 
      floatVal := statList[pl_statIdx].statData.percentileP.statValue 
    };
  }  
  if (vl_statType == percentile95) {
    pl_retVal := { 
      floatVal := statList[ statList[pl_statIdx].statData.percentile95.percentilePIdx ].statData.percentileP.statValue 
    };
  }
  if (vl_statType == limits) {
    pl_retVal := { 
      statusLEDVal := statList[pl_statIdx].statData.limits.statValue 
    };
  }
  if (vl_statType == custom) {
    if (not f_EPTF_StatMeasure_getStat_custom(pl_statIdx, pl_retVal)) {
      f_EPTF_StatMeasure_debug(log2str(
        "Custom stat at ",pl_statIdx," is not available!"));
    };
  }
  //...
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_stat2Var_calcFn
// 
//  Purpose:
//    Converts the value of any statistics to direct content to be set to 
//    the content of the assigned variable
//
//  Parameters:
//      pl_idx - *integer* -  index of the EPTF Variable, 
//      pl_argList - <EPTF_IntegerList> - the arguments (That are EPTF Variable
//                   indexes, i.e. the provider list) : {} empty list, not used
//      pl_nonVarArgList - <EPTF_IntegerList> - the custom arguments : [0]: statIndex
//      pl_retVal - <EPTF_Var_DirectContent> - the return value
//
//  Return Value:
//    *boolean* - true if the value of the statistics is available
//
//  Errors:
//    -
//
//  Detailed Comments:
//    This function is used as the calcFn function of the variable created 
//    from the stat. Works for all statistics types.
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_stat2Var_calcFn(
  in integer pl_idx, 
  in EPTF_IntegerList pl_argList, 
  in EPTF_IntegerList pl_nonVarArgList, 
  inout EPTF_Var_DirectContent pl_retVal) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Missing stat Idx from customArgs of calcFn: " & 
    "calcVariableContent", sizeof(pl_nonVarArgList)>0);

  var integer vl_statIdx := pl_nonVarArgList[0];
  var EPTF_StatMeasure_statType vl_statType := 
    f_EPTF_StatMeasure_getStatType(vl_statIdx);
  if (vl_statType == content) {
    return; // do nothing, content is there
  }
  
  f_EPTF_StatMeasure_stat2Var(vl_statIdx, pl_retVal);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_valueIsAvailable
// 
//  Purpose:
//    Returns the true if the value of the statistics is available
//
//  Parameters:
//    pl_statIdx - *in* *integer* - the idx of the stat
//
//  Return Value:
//    *boolean* - true if the value of the statistics is available
//
//  Errors:
//    -
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_valueIsAvailable(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return boolean 
{
  return not statList[pl_statIdx].reset;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_update_delta_PostProc
// 
//  Purpose:
//    This function is registered as a postProc function for an 
//    EPTF Variable to calculate the delta statistics.
//
//  Parameters:
//    pl_argList[0]: statIdx - index of the statistics to update
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_update_delta_PostProc(
  in integer pl_idx, 
  in EPTF_IntegerList pl_argList) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid size.",
    sizeof(pl_argList)==1);

  var integer pl_statIdx := pl_argList[0];

  // pl_idx is the same as:
  //var integer pl_idx := statList[pl_statIdx].varIdx;
  var EPTF_Var_DirectContent vl_contentNew;
  f_EPTF_Var_getContent(pl_idx,vl_contentNew);

  f_EPTF_StatMeasure_addData_delta(pl_statIdx,vl_contentNew);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_update_deltaSum_PostProc
// 
//  Purpose:
//    This function is registered as a postProc function for an 
//    EPTF Variable to calculate the deltaSum statistics.
//
//  Parameters:
//    pl_argList[0]: statIdx - index of the statistics to update
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_update_deltaSum_PostProc(
  in integer pl_idx, 
  in EPTF_IntegerList pl_argList) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid size.",
    sizeof(pl_argList)==1);

  var integer pl_statIdx := pl_argList[0];

  // pl_idx is the same as:
  //var integer pl_idx := statList[pl_statIdx].varIdx;
  var EPTF_Var_DirectContent vl_contentNew;
  f_EPTF_Var_getContent(pl_idx,vl_contentNew);

  f_EPTF_StatMeasure_addData_deltaSum(pl_statIdx,vl_contentNew);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_update_min_PostProc
// 
//  Purpose:
//    This function is registered as a postProc function for an 
//    EPTF Variable to calculate the min statistics.
//
//  Parameters:
//    pl_argList[0]: statIdx - index of the statistics to update
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_update_min_PostProc(
  in integer pl_idx, 
  in EPTF_IntegerList pl_argList) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid size.",
    sizeof(pl_argList)==1);

  var integer pl_statIdx := pl_argList[0];

  // pl_idx is the same as:
  //var integer pl_idx := statList[pl_statIdx].varIdx;
  var EPTF_Var_DirectContent vl_contentNew;
  f_EPTF_Var_getContent(pl_idx,vl_contentNew);

  f_EPTF_StatMeasure_addData_min(pl_statIdx,vl_contentNew);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_update_max_PostProc
// 
//  Purpose:
//    This function is registered as a postProc function for an 
//    EPTF Variable to calculate the max statistics.
//
//  Parameters:
//    pl_argList[0]: statIdx - index of the statistics to update
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_update_max_PostProc(
  in integer pl_idx, 
  in EPTF_IntegerList pl_argList) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid size.",
    sizeof(pl_argList)==1);

  var integer pl_statIdx := pl_argList[0];

  // pl_idx is the same as:
  //var integer pl_idx := statList[pl_statIdx].varIdx;
  var EPTF_Var_DirectContent vl_contentNew;
  f_EPTF_Var_getContent(pl_idx,vl_contentNew);

  f_EPTF_StatMeasure_addData_max(pl_statIdx,vl_contentNew);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_update_mean_PostProc
// 
//  Purpose:
//    This function is registered as a postProc function for an 
//      EPTF Variable to calculate the mean statistics.
//
//  Parameters:
//    pl_argList[0]: statIdx - index of the statistics to update
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_update_mean_PostProc(
  in integer pl_idx, 
  in EPTF_IntegerList pl_argList) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid size",
    sizeof(pl_argList)==1);

  var integer pl_statIdx := pl_argList[0];

  // pl_idx is the same as:
  //var integer pl_idx := statList[pl_statIdx].varIdx;
  var EPTF_Var_DirectContent vl_contentNew;
  f_EPTF_Var_getContent(pl_idx,vl_contentNew);

  var float x;
  if (ischosen(vl_contentNew.intVal)) {
    x := int2float(vl_contentNew.intVal);
  } else if (ischosen(vl_contentNew.floatVal)) {
    x := vl_contentNew.floatVal;
  }
  f_EPTF_StatMeasure_addData_mean(pl_statIdx,x);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_update_standardDev_PostProc
// 
//  Purpose:
//    This function is registered as a postProc function for an 
//      EPTF Variable to calculate the standardDev statistics.
//
//  Parameters:
//    pl_argList[0]: statIdx - index of the statistics to update
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_update_standardDev_PostProc(
  in integer pl_idx, 
  in EPTF_IntegerList pl_argList) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid size",
    sizeof(pl_argList)==1);

  var integer pl_statIdx := pl_argList[0];

  // pl_idx is the same as:
  //var integer pl_idx := statList[pl_statIdx].varIdx;
  var EPTF_Var_DirectContent vl_contentNew;
  f_EPTF_Var_getContent(pl_idx,vl_contentNew);

  var float x;
  if (ischosen(vl_contentNew.intVal)) {
    x := int2float(vl_contentNew.intVal);
  } else if (ischosen(vl_contentNew.floatVal)) {
    x := vl_contentNew.floatVal;
  }
  f_EPTF_StatMeasure_addData_standardDev(pl_statIdx,x);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_update_density_PostProc
// 
//  Purpose:
//    This function is registered as a postProc function for an 
//    EPTF Variable to calculate the density statistics.
//
//  Parameters:
//    pl_argList[0]: statIdx - index of the statistics to update
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_update_density_PostProc(
  in integer pl_idx, 
  in EPTF_IntegerList pl_argList) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid size",
    sizeof(pl_argList)==1);

  var integer pl_statIdx := pl_argList[0];

  // pl_idx is the same as:
  //var integer pl_idx := statList[pl_statIdx].varIdx;
  var EPTF_Var_DirectContent vl_contentNew;
  f_EPTF_Var_getContent(pl_idx,vl_contentNew);

  var float x;
  if (ischosen(vl_contentNew.intVal)) {
    x := int2float(vl_contentNew.intVal);
  } else if (ischosen(vl_contentNew.floatVal)) {
    x := vl_contentNew.floatVal;
  }
  f_EPTF_StatMeasure_addData_density(pl_statIdx,x);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_update_boundaries_density_PostProc
// 
//  Purpose:
//    This function is registered as a postProc function for the 
//    EPTF Variable created for the boundaries of the density statistics
//    to update boundaries of the density statistics when value of the the 
//    variable is adjusted.
//
//  Parameters:
//    pl_argList[0]: statIdx - index of the statistics to update
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_update_boundaries_density_PostProc(
  in integer pl_idx, 
  in EPTF_IntegerList pl_argList) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid size",
    sizeof(pl_argList)==1);

  var integer pl_statIdx := pl_argList[0];

  // pl_idx is the same as:
  //var integer pl_idx := statList[pl_statIdx].statData.density.createdBoundaryVarIdx;
  var EPTF_Var_DirectContent vl_contentNew;
  f_EPTF_Var_getContent(pl_idx,vl_contentNew);

  // set the boundaries without updating the variable to prevent infinite update loop:
  f_EPTF_StatMeasure_setBoundaries_density(
    pl_statIdx,vl_contentNew.floatlistVal, false);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_addData_EPS_PostProc
// 
//  Purpose:
//    This function is registered as a postProc function for an 
//    EPTF Variable to generate a new sample for the EPS statistics.
//
//  Parameters:
//    pl_argList[0]: statIdx - index of the statistics to update
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Wrapper around <f_EPTF_StatMeasure_addData_EPS> in the format of 
//    a postProc function
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_addData_EPS_PostProc(
  in integer pl_idx, 
  in EPTF_IntegerList pl_argList) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid size", 
    sizeof(pl_argList)==1);

  var integer pl_statIdx := pl_argList[0];

  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.EPS));

  f_EPTF_StatMeasure_addData_EPS(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_addData_chrono_PostProc
// 
//  Purpose:
//    This function is registered as a postProc function for an 
//    EPTF Variable to generate a new sample for the chrono statistics.
//
//  Parameters:
//    pl_argList[0]: statIdx - index of the statistics to update
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    Wrapper around <f_EPTF_StatMeasure_addData_chrono> in the format of a 
//    postProc function
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_addData_chrono_PostProc(
  in integer pl_idx, 
  in EPTF_IntegerList pl_argList) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid size",
    sizeof(pl_argList)==1);

  var integer pl_statIdx := pl_argList[0];

  f_EPTF_Base_assert("Invalid stat type.",
    ischosen(statList[pl_statIdx].statData.chrono));

  f_EPTF_StatMeasure_addData_chrono(pl_statIdx);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_update_percentileP_PostProc
// 
//  Purpose:
//    This function is registered as a postProc function for an 
//    EPTF Variable to calculate the percentileP statistics.
//
//  Parameters:
//    pl_argList[0]: statIdx - index of the statistics to update
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_update_percentileP_PostProc(
  in integer pl_idx, 
  in EPTF_IntegerList pl_argList) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid size.",
    sizeof(pl_argList)==1);

  var integer pl_statIdx := pl_argList[0];

  // pl_idx is the same as:
  //var integer pl_idx := statList[pl_statIdx].varIdx;
  var EPTF_Var_DirectContent vl_contentNew;
  f_EPTF_Var_getContent(pl_idx,vl_contentNew);

  var float vl_data;
  if (ischosen(vl_contentNew.intVal)) {
    vl_data := int2float(vl_contentNew.intVal);
  } else if (ischosen(vl_contentNew.floatVal)) {
    vl_data := vl_contentNew.floatVal;
  }

  f_EPTF_StatMeasure_addData_percentileP(pl_statIdx,vl_data);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_update_percentile95_PostProc
// 
//  Purpose:
//    This function is registered as a postProc function for an 
//    EPTF Variable to calculate the percentile95 statistics.
//
//  Parameters:
//    pl_argList[0]: statIdx - index of the statistics to update
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_update_percentile95_PostProc(
  in integer pl_idx, 
  in EPTF_IntegerList pl_argList) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid size.",
    sizeof(pl_argList)==1);

  var integer pl_statIdx := pl_argList[0];

  // pl_idx is the same as:
  //var integer pl_idx := statList[pl_statIdx].varIdx;
  var EPTF_Var_DirectContent vl_contentNew;
  f_EPTF_Var_getContent(pl_idx,vl_contentNew);

  var float vl_data;
  if (ischosen(vl_contentNew.intVal)) {
    vl_data := int2float(vl_contentNew.intVal);
  } else if (ischosen(vl_contentNew.floatVal)) {
    vl_data := vl_contentNew.floatVal;
  }

  f_EPTF_StatMeasure_addData_percentile95(pl_statIdx,vl_data);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_update_limits_PostProc
// 
//  Purpose:
//    This function is registered as a postProc function for an 
//      EPTF Variable to calculate the limits statistics.
//
//  Parameters:
//    pl_argList[0]: statIdx - index of the statistics to update
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_update_limits_PostProc(
  in integer pl_idx, 
  in EPTF_IntegerList pl_argList) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_Base_assert("Invalid size",
    sizeof(pl_argList)==1 or sizeof(pl_argList)==2);

  var integer pl_statIdx := pl_argList[0];
  
  var integer vl_varIdx := pl_idx;
  if (sizeof(pl_argList)==2) {
    vl_varIdx := pl_argList[1]; // the variable the stat is created from
  }

  // pl_idx is the same as:
  //var integer pl_idx := statList[pl_statIdx].varIdx;
  var EPTF_Var_DirectContent vl_contentNew;
  f_EPTF_Var_getContent(vl_varIdx,vl_contentNew);

  var float x := 0.0;
  if (ischosen(vl_contentNew.intVal)) {
    x := int2float(vl_contentNew.intVal);
  } else if (ischosen(vl_contentNew.floatVal)) {
    x := vl_contentNew.floatVal;
  }
  f_EPTF_StatMeasure_addData_limits(pl_statIdx,x);
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_update_custom_PostProc
// 
//  Purpose:
//    This function is registered as a postProc function for an 
//    EPTF Variable to calculate a user defined custom statistics.
//
//  Parameters:
//    pl_argList[0]: statIdx - index of the statistics to update
//
//  Detailed Comments:
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_update_custom_PostProc(
  in integer pl_idx,
  in EPTF_IntegerList pl_argList) 
runs on EPTF_StatMeasure_CT 
{
  f_EPTF_StatMeasure_debug(
    "### " & %definitionId & "()");

  f_EPTF_Base_assert("Invalid size.",
    sizeof(pl_argList)==1);

  var integer pl_statIdx := pl_argList[0];

  // pl_idx is the same as:
  //var integer pl_idx := statList[pl_statIdx].varIdx;
  var EPTF_Var_DirectContent vl_contentNew;
  f_EPTF_Var_getContent(pl_idx,vl_contentNew);

  f_EPTF_StatMeasure_debug(
    "New content: " & log2str(vl_contentNew));

  f_EPTF_StatMeasure_addData_custom(pl_statIdx, vl_contentNew);
}
//...

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_getStatName
// 
//  Purpose:
//    Returns the name for a given stat : "EPTF_StatMeasure."+id+"."+varname+".stat."+statType.
//
//  Parameters:
//    pl_statIdx - *integer* - index of the statistics
//
//  Detailed Comments:
//    In the generated name id is the id of the stat,
//    varname is the name of the EPTF Variable 
//    the stat is created from.
//    If it is a standalone statistics, it is: standAloneStat.<statIdx>
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_getStatName(
  in integer pl_statIdx) 
runs on EPTF_StatMeasure_CT return charstring 
{
  // assign auto-name:
  var EPTF_StatMeasure_statType vl_statType := 
    f_EPTF_StatMeasure_getStatType(pl_statIdx);
  var integer vl_varIdx := f_EPTF_StatMeasure_getVarIdx(pl_statIdx);
  var charstring vl_statName := "N/A";
  var charstring vl_varName := "standAloneStat." & int2str(pl_statIdx);
  if (vl_varIdx!= -1) {
    vl_varName := f_EPTF_Var_getName(vl_varIdx);
  }

  if (vl_statType == delta) {
    vl_statName := "delta";
  } else if (vl_statType == deltaSum) {
    vl_statName := "deltaSum";
  } else if (vl_statType == min) {
    vl_statName := "min";
  } else if (vl_statType == max) {
    vl_statName := "max";
  } else if (vl_statType == mean) {
    vl_statName := "mean";
  } else if (vl_statType == standardDev) {
    vl_statName := "standardDev";
  } else if (vl_statType == EPS) {
    vl_statName := "EPS";
  } else if (vl_statType == chrono) {
    vl_statName := "chrono";
  } else if (vl_statType == density) {
    vl_statName := "density";
  } else if (vl_statType == percentileP) {
    vl_statName := "percentileP";
  }else if (vl_statType == percentile95) {
    vl_statName := "percentile95";
  }else if (vl_statType == limits) {
    vl_statName := "limits";
  } else if (vl_statType == custom) {
    vl_statName := 
      statList[pl_statIdx].statData.custom.statName;
  }
  //...
  return "EPTF_StatMeasure."&int2str(pl_statIdx)&"."&vl_varName & ".stat." & vl_statName;
}

private function f_EPTF_StatMeasure_integerList2str(
  in EPTF_IntegerList pl_integerList) 
return charstring 
{
  var charstring vl_result := "{";
  for (var integer i:=0; i<sizeof(pl_integerList); i:=i+1) {
    if (i>0) {
      vl_result := vl_result & ",";// shouldn't contain space because it's a separator char for gnuplot
    }
    vl_result := vl_result & int2str(pl_integerList[i]);
  }
  vl_result := vl_result & "}";
  return vl_result;
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_cleanup_CT
// 
//  Purpose:
//    This function should be called before the <EPTF_StatMeasure_CT> component
//    shuts down.
//
//  Parameters:
//    -
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    The function is registered by <f_EPTF_Base_RegisterCleanup> as a 
//    cleanup function in the init function for the <EPTF_StatMeasure_CT> 
//    component.
//    This function makes it possible to be able to shut down the
//    <EPTF_StatMeasure_CT> component gracefully.
//    
///////////////////////////////////////////////////////////////////////////////
private function f_EPTF_StatMeasure_cleanup_CT() 
runs on EPTF_StatMeasure_CT 
{
  if (v_EPTF_StatMeasure_initialized == false) {
    return;
  }

  v_EPTF_StatMeasure_initialized := false;
  f_EPTF_StatMeasure_LogAll("----- STATMEASURE CLEANUP DONE -------");
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_bubblesort
// 
//  Purpose:
//    Sorts the argument in increasing order using the bubble-sort algorithm.
//
//  Parameters:
//    -
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    See more detailes at: http://www.softpanorama.org/Algorithms/Sorting/bubblesort.shtml.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_bubblesort(inout EPTF_FloatList pl_list) {
  var integer n := sizeof(pl_list);
  var integer k;
  var integer bound := n-1;
  var float t;
  var integer last_swap;

  while (bound!=0) {
    last_swap := 0;
    for ( k:=0; k<bound; k:=k+1 ) {
       t := pl_list[k]; // t is a maximum of A[0]..A[k] 
       if ( t > pl_list[k+1] ) {
         pl_list[k] := pl_list[k+1]; pl_list[k+1] := t; //swap
         last_swap := k; // mark the last swap position 
       }//if
    }//for
    bound:=last_swap; // elements after bound already sorted        
  }//while
}

///////////////////////////////////////////////////////////////////////////////
//  Function: f_EPTF_StatMeasure_bubblesort_LimitList
// 
//  Purpose:
//    Sorts the argument in increasing order using the bubble-sort algorithm.
//
//  Parameters:
//    -
//
//  Return Value:
//    -
//
//  Errors:
//    -
//
//  Detailed Comments:
//    See more detailes at: http://www.softpanorama.org/Algorithms/Sorting/bubblesort.shtml.
//    
///////////////////////////////////////////////////////////////////////////////
public function f_EPTF_StatMeasure_bubblesort_LimitList(inout EPTF_StatMeasure_LimitList pl_list) {
  var integer n := sizeof(pl_list);
  var integer k;
  var integer bound := n-1;
  var EPTF_StatMeasure_LimitItem t;
  var integer last_swap;

  while (bound!=0) {
    last_swap := 0;
    for ( k:=0; k<bound; k:=k+1 ) {
       t := pl_list[k]; // t is a maximum of A[0]..A[k] 
       if ( f_EPTF_StatMeasure_limit2float(t) > f_EPTF_StatMeasure_limit2float(pl_list[k+1]) ) {
         pl_list[k] := pl_list[k+1]; pl_list[k+1] := t; //swap
         last_swap := k; // mark the last swap position 
       }//if
    }//for
    bound:=last_swap; // elements after bound already sorted        
  }//while
}

group Logging {

  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_StatMeasure_error
  // 
  //  Purpose:
  //    Function to log an error from StatMeasure feature.
  //
  //  Parameters:
  //    - pl_message - *in* *charstring* - the message to log
  //
  //  Return Value:
  //    -
  //
  //  Errors & assertions:
  //    - 
  //
  //  Detailed Comments:
  //    -
  //
  ///////////////////////////////////////////////////////////
  private function f_EPTF_StatMeasure_error(in charstring pl_message)
  runs on EPTF_StatMeasure_CT
  {
    f_EPTF_Logging_error(true, tsp_EPTF_StatMeasure_loggingComponentMask&": "&pl_message);
    f_EPTF_Base_stopAll();
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_StatMeasure_warning
  // 
  //  Purpose:
  //    Function to log a warning from StatMeasure feature.
  //
  //  Parameters:
  //    - pl_message - *in* *charstring* - the message to log
  //
  //  Return Value:
  //    -
  //
  //  Errors & assertions:
  //    - 
  //
  //  Detailed Comments:
  //    -
  //
  ///////////////////////////////////////////////////////////
  private function f_EPTF_StatMeasure_warning(in charstring pl_message)
  runs on EPTF_StatMeasure_CT
  {
    f_EPTF_Logging_warningV2(pl_message, v_StatMeasure_loggingMaskId, {c_EPTF_StatMeasure_loggingClassIdx_Warning});
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_StatMeasure_debug
  // 
  //  Purpose:
  //    Function to log a debug message from StatMeasure feature.
  //
  //  Parameters:
  //    - pl_message - *in* *charstring* - the message to log
  //
  //  Return Value:
  //    -
  //
  //  Errors & assertions:
  //    - 
  //
  //  Detailed Comments:
  //    -
  //
  ///////////////////////////////////////////////////////////
  private function f_EPTF_StatMeasure_debug(in charstring pl_message)
  runs on EPTF_StatMeasure_CT
  {
    f_EPTF_Logging_debugV2(pl_message, v_StatMeasure_loggingMaskId, {c_EPTF_StatMeasure_loggingClassIdx_Debug});
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_StatMeasure_debugEnabled
  // 
  //  Purpose:
  //    Function to check if debug is enabled for StatMeasure
  //
  //  Parameters:
  //    -
  //
  //  Return Value:
  //    *boolean* - true if debug enalbed
  //
  //  Errors & assertions:
  //    - 
  //
  //  Detailed Comments:
  //    -
  //
  ///////////////////////////////////////////////////////////
  private function f_EPTF_StatMeasure_debugEnabled()
  runs on EPTF_StatMeasure_CT
  return boolean
  {
    return f_EPTF_Logging_isEnabled(v_StatMeasure_loggingMaskId, c_EPTF_StatMeasure_loggingClassIdx_Debug);
  }
} // group Logging

} // group Private

} // module
