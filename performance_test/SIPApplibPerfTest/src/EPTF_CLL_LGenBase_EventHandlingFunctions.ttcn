/******************************************************************************
 * Copyright (c) 2000-2018 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.html
 ******************************************************************************///  File:     EPTF_CLL_LGenBase_EventHandlingFunctions.ttcn
//  Rev:      <RnXnn>
//  Prodnr:   CNL 113 512
//  Updated:  2010-07-16
//  Contact:  http://ttcn.ericsson.se
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
//  Module: EPTF_CLL_LGenBase_EventHandlingFunctions
// 
//  Purpose:
//    This module provides functions related to event dispatching 
//    and receiving in TitanSim load generators
// 
//  Module Parameters:
//    -
// 
//  Module depends on:
//    <>
// 
//  Current Owner:
//    ELSZSKU
// 
//  Last Review Date:
//    2008-
// 
//  Detailed Comments:
// 
///////////////////////////////////////////////////////////
module EPTF_CLL_LGenBase_EventHandlingFunctions
{
import from EPTF_CLL_Base_Functions all;
import from EPTF_CLL_Common_Definitions all;
import from EPTF_CLL_StatMeasure_Functions all
import from EPTF_CLL_LGenBase_ConfigDefinitions all;
import from EPTF_CLL_LGenBase_ConfigFunctions all;
import from EPTF_CLL_LGenBase_LoggingFunctions all;
import from EPTF_CLL_FBQ_Definitions all;
import from EPTF_CLL_FBQ_Functions all;
import from EPTF_CLL_HashMapInt2Int_Functions all;
import from EPTF_CLL_HashMapStr2Int_Functions all;
import from EPTF_CLL_Scheduler_Definitions all;
import from EPTF_CLL_LGenBase_ExternalFunctions all;
import from EPTF_CLL_Variable_Functions all;
import from EPTF_CLL_Variable_Definitions all;
import from EPTF_CLL_StatHandlerClient_Functions all;
import from EPTF_CLL_LGenBase_Definitions all;
import from EPTF_CLL_RBTScheduler_Functions all;
import from EPTF_CLL_Common_IndexArrayFunctions all
import from EPTF_CLL_Common_Functions all
import from TCCConversion_Functions all

friend module EPTF_CLL_LGenBase_StepFunctions; // f_EPTF_LGenBase_TimerActionHandler
friend module EPTF_CLL_LGenBase_TrafficFunctions; // f_EPTF_LGenBase_activateFsmGroup

group Dispatch{
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_dispatchEvent
  // 
  //  Purpose:
  //    Report an event to the appropriate listeners.
  //
  //  Parameters:
  //    pl_event - *in* - <EPTF_LGenBase_EventDescriptor> - the event occured 
  //
  //  Return Value:
  //    -
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_dispatchEvent(in EPTF_LGenBase_ReportedEventDescriptor pl_event) 
  runs on EPTF_LGenBase_Private_CT{
    if (c_EPTF_Common_debugSwitch){
      f_EPTF_Base_assert(%definitionId&": Invalid behavior index. Special LGenBase events (events with negative behavior index) must not be dispatched!", 
        pl_event.event.bIdx > -1);
    }
    if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
      f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId,": dispatching event:=", pl_event))
    }
    f_EPTF_LGenBase_privateDispatchEvent(pl_event, false, pl_event.event.bIdx, pl_event.event.iIdx);
  }
  
  private function f_EPTF_LGenBase_fillSourceFromStep(
    inout EPTF_LGenBase_ReportedEventDescriptor pl_event,
    in EPTF_LGenBase_TestStepArgs pl_args) 
  runs on EPTF_LGenBase_Private_CT{
    pl_event.event.source.eIdx := pl_args.eIdx
    pl_event.event.source.fsmCtxIdx := pl_args.refContext.fCtxIdx
  }
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_dispatchEventFromStep
  // 
  //  Purpose:
  //    Report an event to the appropriate listeners, and
  //    fills up the source from the incoming step arguments.
  //
  //  Parameters:
  //    pl_event - *in* - <EPTF_LGenBase_EventDescriptor> - the event occured 
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_dispatchEventFromStep(
    inout EPTF_LGenBase_ReportedEventDescriptor pl_event,
    in EPTF_LGenBase_TestStepArgs pl_args) 
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_LGenBase_fillSourceFromStep(pl_event,pl_args)
    f_EPTF_LGenBase_dispatchEvent(pl_event);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_postEventFromStep
  // 
  //  Purpose:
  //    Post an event to the appropriate listeners, and
  //    fills up the source from the incoming step arguments.
  //
  //  Parameters:
  //    pl_event - *in* - <EPTF_LGenBase_EventDescriptor> - the event occured 
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_postEventFromStep(
    inout EPTF_LGenBase_ReportedEventDescriptor pl_event,
    in EPTF_LGenBase_TestStepArgs pl_args) 
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_LGenBase_fillSourceFromStep(pl_event,pl_args)
    f_EPTF_LGenBase_postEvent(pl_event);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_postEvent
  // 
  //  Purpose:
  //    Report an event to the appropriate listeners after processing 
  //    all running event dispatching
  //
  //  Parameters:
  //    pl_event - *in* - <EPTF_LGenBase_EventDescriptor> - the event occured 
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_postEvent(in EPTF_LGenBase_ReportedEventDescriptor pl_event) 
  runs on EPTF_LGenBase_Private_CT{
    if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
      f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId,": posting event:=", pl_event))
    }
    if(0 != v_LGenBase_reportEventIsRunning){
      var integer vl_slot := f_EPTF_FBQ_getOrCreateFreeSlot(v_LGenBase_postedEventsQueue);
      v_LGenBase_postedEvents[vl_slot] := pl_event;
      f_EPTF_FBQ_moveFromFreeToBusyTail(vl_slot, v_LGenBase_postedEventsQueue);
    }else{
      f_EPTF_LGenBase_dispatchEvent(pl_event);
      f_EPTF_LGenBase_checkEvents2Post();
    }
  }    
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_dispatchReply
  // 
  //  Purpose:
  //    Dispatches an event to the source FSM of the currently received event.
  //
  //  Parameters:
  //    - pl_behaviorIdx - *in* - *integer* - the behavior index of the event
  //    - pl_inputIdx - *in* - *integer* - the input index of the event
  //    - reportedArgs - <EPTF_IntegerList> - the actual reported arguments of
  //      the event determined by the reporter
  //    - pl_ptr - *in* <EPTF_LGenBase_TestStepArgs> - arguments for the test
  //      step the function has been called from.
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_dispatchReply(
    in integer pl_behaviorIdx,
    in integer pl_inputIdx,
    in EPTF_IntegerList pl_reportedArgs,
    in EPTF_LGenBase_TestStepArgs pl_args) 
  runs on EPTF_LGenBase_Private_CT {
    if (c_EPTF_Common_debugSwitch) { f_EPTF_LGenBase_checkFsmSource(%definitionId, pl_args) };
    f_EPTF_LGenBase_dispatchEvent({
        {
          pl_behaviorIdx,
          pl_inputIdx,
          {pl_args.reportedEvent.event.source.eIdx,
            pl_args.reportedEvent.event.source.fsmCtxIdx},
          {pl_args.eIdx, pl_args.refContext.fCtxIdx}
        },
        pl_reportedArgs
      });
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_postReply
  // 
  //  Purpose:
  //    Posts an event to the source FSM of the currently received event.
  //
  //  Parameters:
  //    - pl_behaviorIdx - *in* - *integer* - the behavior index of the event
  //    - pl_inputIdx - *in* - *integer* - the input index of the event
  //    - reportedArgs - <EPTF_IntegerList> - the actual reported arguments of
  //      the event determined by the reporter
  //    - pl_ptr - *in* <EPTF_LGenBase_TestStepArgs> - arguments for the test
  //      step the function has been called from.
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_postReply(
    in integer pl_behaviorIdx,
    in integer pl_inputIdx,
    in EPTF_IntegerList pl_reportedArgs,
    in EPTF_LGenBase_TestStepArgs pl_args) 
  runs on EPTF_LGenBase_Private_CT{
    if (c_EPTF_Common_debugSwitch) { f_EPTF_LGenBase_checkFsmSource(%definitionId, pl_args) };
    f_EPTF_LGenBase_postEvent({
        {
          pl_behaviorIdx,
          pl_inputIdx,
          {pl_args.reportedEvent.event.source.eIdx,
            pl_args.reportedEvent.event.source.fsmCtxIdx},
          {pl_args.eIdx, pl_args.refContext.fCtxIdx}
        },
        pl_reportedArgs
      });
  }
  
}

group ListenerManagement{
  group eventFromSibling{
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_activateSiblingListener
    // 
    //  Purpose:
    //    Activates a listener listening to an event with the specified behavior and input index
    //    From a specified FSM to the given FSM
    //
    //  Parameters:
    //    pl_bIdx - *in* *integer* - the index of the registered behavior returned by the <f_EPTF_LGenBase_declareBehaviorType> function 
    //    pl_iIdx - *in* *integer* - the index of the registered FSM input returned by the <f_EPTF_LGenBase_declareFsmEvent> function
    //    pl_siblingIdx  - *in* *integer* - the sibling index of the source FSM
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_activateSiblingListener(
      in integer pl_bIdx,
      in integer pl_iIdx,
      in integer pl_eIdx,
      in integer pl_fCtxIdx,
      in integer pl_siblingIdx,
      in integer pl_listenerIdx)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      //TODO asserts
      //Where to store?
      //FSM event - store it in the FSM context
      //Get the fsmCtxIdx from the sibling Idx
      //First get the TC idx
      var integer vl_tcIdx := f_EPTF_LGenBase_tcIdxOfFSM(pl_eIdx, pl_fCtxIdx)
      if(c_EPTF_Common_debugSwitch){
        f_EPTF_Base_assert(%definitionId&": The specified FSM context #"&int2str(pl_fCtxIdx)&
          " of entity#"&int2str(pl_eIdx)&" is not joined to a traffic case.", -1 < vl_tcIdx)
        f_EPTF_Base_assert(%definitionId&": Invalid sibling index#"&int2str(pl_siblingIdx)&
          " of entity#"&int2str(pl_eIdx)&" traffic case "&v_LGenBase_trafficCases[vl_tcIdx].uniqueName, 
          sizeof(v_LGenBase_trafficCases[vl_tcIdx].fsmList)>=pl_siblingIdx)
      }
      //Get the FSM ctx idx
      var integer vl_fsmIdxOfSibling := f_EPTF_LGenBase_fsmCtxIdxOfSibling(pl_eIdx, vl_tcIdx, pl_siblingIdx)
      
      
      var integer vl_idx := f_EPTF_FBQ_getOrCreateFreeSlot(v_LGenBase_genericEventListeners[pl_bIdx][pl_iIdx]);
      f_EPTF_FBQ_setQueueDidx(vl_idx, {pl_listenerIdx}, v_LGenBase_genericEventListeners[pl_bIdx][pl_iIdx]);
      f_EPTF_FBQ_moveFromFreeToBusyTail(vl_idx, v_LGenBase_genericEventListeners[pl_bIdx][pl_iIdx]);
      return vl_idx;
    }
    
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_deactivateSiblingListener
    // 
    //  Purpose:
    //    Dectivates a listener listening to an event with the specified behavior and input index
    //
    //  Parameters:
    //    pl_bIdx - *in* *integer* - the index of the registered behavior returned by the <f_EPTF_LGenBase_declareBehaviorType> function 
    //    pl_iIdx - *in* *integer* - the index of the registered FSM input returned by the <f_EPTF_LGenBase_declareFsmEvent> function 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_deactivateSiblingListener(
      in integer pl_bIdx,
      in integer pl_iIdx,
      in integer pl_eIdx,
      in integer pl_fIdx,
      in integer pl_siblingIdx,
      in integer pl_listenerIdx)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      //TODO asserts
      f_EPTF_FBQ_moveFromBusyToFreeTail(pl_listenerIdx, v_LGenBase_genericEventListeners[pl_bIdx][pl_iIdx]);
      return f_EPTF_FBQ_getQueueData(pl_listenerIdx, v_LGenBase_genericEventListeners[pl_bIdx][pl_iIdx],0);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_addBehaviorListener
    // 
    //  Purpose:
    //    Adds the listener to the database by the <f_EPTF_LGenBase_addListener>
    //    and activates it by the <f_EPTF_LGenBase_activateBehaviorListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_addSiblingListener(
      in integer pl_bIdx,
      in integer pl_iIdx, 
      in integer pl_eIdx,
      in integer pl_fIdx,
      in integer pl_siblingIdx,
      in EPTF_LGenBase_EventListener_FT pl_fn,
      in EPTF_IntegerList pl_args
    ) 
    runs on EPTF_LGenBase_Private_CT return integer{
      //TODO asserts
      var integer vl_listenerIdx := f_EPTF_LGenBase_addListener(pl_fn, pl_args);
      return f_EPTF_LGenBase_activateSiblingListener(pl_bIdx, pl_iIdx, pl_eIdx, pl_fIdx, pl_siblingIdx, vl_listenerIdx)
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeBehaviorListener
    // 
    //  Purpose:
    //    Deactivates the listener by the <f_EPTF_LGenBase_deactivateBehaviorListener>
    //    and removes it from the listener database by the <f_EPTF_LGenBase_removeListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeSiblingListener(
      in integer pl_bIdx,
      in integer pl_iIdx, 
      in integer pl_eIdx,
      in integer pl_fIdx,
      in integer pl_siblingIdx,
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT{
      //TODO asserts
      var integer vl_listenerIdx := f_EPTF_LGenBase_deactivateSiblingListener(pl_bIdx, pl_iIdx, pl_eIdx, pl_fIdx, pl_siblingIdx, pl_idx2Remove)
      f_EPTF_LGenBase_removeListener(vl_listenerIdx);
    }
  }
  group eventTypeBehavior         {
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_activateBehaviorListener
    // 
    //  Purpose:
    //    Activates a listener listening to an event of a specified behavior
    //
    //  Parameters:
    //    pl_bIdx - *in* *integer* - the index of the registered behavior returned by the <f_EPTF_LGenBase_declareBehaviorType> function 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_activateBehaviorListener(
      in integer pl_bIdx, 
      in integer pl_listenerIdx)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      f_EPTF_Base_assert(%definitionId&" Invalid behavior index", 
        (pl_bIdx>=0 and pl_bIdx<sizeof(v_LGenBase_behaviorTypes))
      );
      var integer vl_idx := f_EPTF_FBQ_getOrCreateFreeSlot(v_LGenBase_behaviorTypes[pl_bIdx].listeners);
      f_EPTF_FBQ_setQueueDidx(vl_idx, {pl_listenerIdx}, v_LGenBase_behaviorTypes[pl_bIdx].listeners);
      f_EPTF_FBQ_moveFromFreeToBusyTail(vl_idx, v_LGenBase_behaviorTypes[pl_bIdx].listeners);
      v_LGenBase_hasBehaviorListener := true
      return vl_idx;
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_deactivateBehaviorListener
    // 
    //  Purpose:
    //    Deactivates a listener activated by the <f_EPTF_LGenBase_activateBehaviorListener> function
    //
    //  Parameters:
    //    pl_bIdx - *in* *integer* - the index of the registered behavior returned by the <f_EPTF_LGenBase_declareBehaviorType> function 
    //    pl_idx2Remove - *in* *integer* - the index of the activated listener, returned by the <f_EPTF_LGenBase_activateBehaviorListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_deactivateBehaviorListener(
      in integer pl_bIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      f_EPTF_Base_assert(%definitionId&" Invalid entity index", 
        (pl_bIdx>=0 and pl_bIdx<sizeof(v_LGenBase_behaviorTypes))
      );
      f_EPTF_FBQ_moveFromBusyToFreeTail(pl_idx2Remove, v_LGenBase_behaviorTypes[pl_bIdx].listeners);
      v_LGenBase_hasBehaviorListener := 0 != f_EPTF_FBQ_getLengthOfBusyChain(v_LGenBase_behaviorTypes[pl_bIdx].listeners)
      return f_EPTF_FBQ_getQueueData(pl_idx2Remove, v_LGenBase_behaviorTypes[pl_bIdx].listeners, 0);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_addBehaviorListener
    // 
    //  Purpose:
    //    Adds the listener to the database by the <f_EPTF_LGenBase_addListener>
    //    and activates it by the <f_EPTF_LGenBase_activateBehaviorListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_addBehaviorListener(
      in integer pl_bIdx,
      in EPTF_LGenBase_EventListener_FT pl_fn,
      in EPTF_IntegerList pl_args
    ) 
    runs on EPTF_LGenBase_Private_CT return integer{
      var integer vl_listenerIdx := f_EPTF_LGenBase_addListener(pl_fn, pl_args);
      return f_EPTF_LGenBase_activateBehaviorListener(pl_bIdx, vl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeBehaviorListener
    // 
    //  Purpose:
    //    Deactivates the listener by the <f_EPTF_LGenBase_deactivateBehaviorListener>
    //    and removes it from the listener database by the <f_EPTF_LGenBase_removeListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeBehaviorListener(
      in integer pl_eIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT{
      f_EPTF_Base_assert(%definitionId&" Invalid entity index", 
        (pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities))
      );
      var integer vl_listenerIdx := f_EPTF_LGenBase_deactivateBehaviorListener(pl_eIdx, pl_idx2Remove);
      f_EPTF_LGenBase_removeListener(vl_listenerIdx);
    }
  }; 
  
  group eventTypeGeneral          {
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_activateGeneralListener
    // 
    //  Purpose:
    //    Activates a listener listening to an event with the specified behavior and input index
    //
    //  Parameters:
    //    pl_bIdx - *in* *integer* - the index of the registered behavior returned by the <f_EPTF_LGenBase_declareBehaviorType> function 
    //    pl_iIdx - *in* *integer* - the index of the registered FSM input returned by the <f_EPTF_LGenBase_declareFsmEvent> function 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_activateGeneralListener(
      in integer pl_bIdx,
      in integer pl_iIdx, 
      in integer pl_listenerIdx)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      var integer vl_idx := f_EPTF_FBQ_getOrCreateFreeSlot(v_LGenBase_genericEventListeners[pl_bIdx][pl_iIdx]);
      //v_LGenBase_genericEventListeners[pl_eventDesc.bIdx][pl_eventDesc.iIdx].list[vl_idx] := pl_listenerIdx;
      f_EPTF_FBQ_setQueueDidx(vl_idx, {pl_listenerIdx}, v_LGenBase_genericEventListeners[pl_bIdx][pl_iIdx]);
      f_EPTF_FBQ_moveFromFreeToBusyTail(vl_idx, v_LGenBase_genericEventListeners[pl_bIdx][pl_iIdx]);
      return vl_idx;
    }
    
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_deactivateGeneralListener
    // 
    //  Purpose:
    //    Dectivates a listener listening to an event with the specified behavior and input index
    //
    //  Parameters:
    //    pl_bIdx - *in* *integer* - the index of the registered behavior returned by the <f_EPTF_LGenBase_declareBehaviorType> function 
    //    pl_iIdx - *in* *integer* - the index of the registered FSM input returned by the <f_EPTF_LGenBase_declareFsmEvent> function 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_deactivateGeneralListener(
      in integer pl_bIdx,
      in integer pl_iIdx, 
      in integer pl_listenerIdx)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      f_EPTF_FBQ_moveFromBusyToFreeTail(pl_listenerIdx, v_LGenBase_genericEventListeners[pl_bIdx][pl_iIdx]);
      return f_EPTF_FBQ_getQueueData(pl_listenerIdx, v_LGenBase_genericEventListeners[pl_bIdx][pl_iIdx],0);
    }
    
    ////////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_addGenericEventListener
    // 
    //  Purpose:
    //    It is used for activating an event listener at the generic-events level.
    //
    //  Parameters:
    //  - pl_event - *in* <EPTF_LGenBase_ReportableEventDescriptor> - the event to
    //    be listened to, must be a regular event with target field omit-ed, asserted
    //  - pl_descr - *in* <EPTF_LGenBase_EventListenerDescriptor> - the listener
    //    to be activated
    //
    //  Return Value:
    //    - 
    //    index of the particular event
    //
    //  Errors:
    //
    //  Detailed Comments:
    //
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_addGenericEventListener(
      in EPTF_LGenBase_ReportableEventDescriptor pl_event,
      in EPTF_LGenBase_EventListenerDescriptor pl_descr
    ) 
    runs on EPTF_LGenBase_Private_CT return integer{
      f_EPTF_LGenBase_loggingWarning(%definitionId&": The obsolete f_EPTF_LGenBase_addGenericEventListener has been called."& 
        " Use the f_EPTF_LGenBase_addGeneralEventListener instead.");
      f_EPTF_Base_assert(%definitionId&" Event target field must be omit", 
        not ispresent(pl_event.target));
      return f_EPTF_LGenBase_addGeneralEventListener(pl_event.bIdx, pl_event.iIdx,pl_descr.fn, pl_descr.args)
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_addGeneralEventListener
    // 
    //  Purpose:
    //    Adds the listener to the database by the <f_EPTF_LGenBase_addListener>
    //    and activates it by the <f_EPTF_LGenBase_activateGeneralListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_addGeneralEventListener(
      in integer pl_bIdx,
      in integer pl_iIdx,
      in EPTF_LGenBase_EventListener_FT pl_fn,
      in EPTF_IntegerList pl_args
    ) 
    runs on EPTF_LGenBase_Private_CT return integer{
      f_EPTF_Base_assert(%definitionId&" behavior type index", 
        (pl_bIdx>=0 and pl_bIdx<sizeof(v_LGenBase_behaviorTypes))
      );
      f_EPTF_Base_assert(%definitionId&" Event/input index", 
        pl_iIdx>=0 
        and pl_iIdx<sizeof(v_LGenBase_fsmEvents[pl_bIdx]));
      var integer vl_listenerIdx := f_EPTF_LGenBase_addListener(pl_fn, pl_args);
      return f_EPTF_LGenBase_activateGeneralListener(pl_bIdx,pl_iIdx,vl_listenerIdx);
    }
    
    ////////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeGenericEventListener
    // 
    //  Purpose:
    //    Obsolete function to deactivating an event listener at the generic-events level.
    //    Use f_EPTF_LGenBase_removeGeneralEventListener instead
    ////////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeGenericEventListener(
      in integer pl_bIdx,
      in integer pl_iIdx,
      in integer pl_idx2Remove
    ) 
    runs on EPTF_LGenBase_Private_CT{
      f_EPTF_LGenBase_removeGeneralEventListener( pl_bIdx, pl_iIdx, pl_idx2Remove);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeGeneralEventListener
    // 
    //  Purpose:
    //    Deactivates the listener by the <f_EPTF_LGenBase_deactivateGeneralListener>
    //    and removes it from the listener database by the <f_EPTF_LGenBase_removeListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeGeneralEventListener(
      in integer pl_bIdx,
      in integer pl_iIdx,
      in integer pl_idx2Remove
    ) 
    runs on EPTF_LGenBase_Private_CT{
      f_EPTF_Base_assert(%definitionId&" Invalid behavior type index", 
        (pl_bIdx>=0 and pl_bIdx<sizeof(v_LGenBase_behaviorTypes))
      );
      f_EPTF_Base_assert(%definitionId&" Invalid event/input index", 
        pl_iIdx>=0 
        and pl_iIdx<sizeof(v_LGenBase_fsmEvents[pl_bIdx]));
      f_EPTF_Base_assert(%definitionId&" Invalid listener reference index", pl_idx2Remove>=0);
      var integer vl_listenerIdx :=
      f_EPTF_LGenBase_deactivateGeneralListener(pl_bIdx, pl_iIdx, pl_idx2Remove);
      f_EPTF_LGenBase_removeListener(vl_listenerIdx);
    }  
  }; //group eventTypeGeneral 
  
  group eventTypeEntity           {
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_activateEntityListener
    // 
    //  Purpose:
    //    Activates a listener listening to an event with the specified behavior, input index and target entity index
    //
    //  Parameters:
    //    pl_bIdx - *in* *integer* - the index of the registered behavior returned by the <f_EPTF_LGenBase_declareBehaviorType> function 
    //    pl_iIdx - *in* *integer* - the index of the registered FSM input returned by the <f_EPTF_LGenBase_declareFsmEvent> function 
    //    pl_eIdx - *in* *integer* - the index of the target entity 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function  f_EPTF_LGenBase_activateEntityListener(
      in integer pl_bIdx,
      in integer pl_iIdx, 
      in integer pl_eIdx, 
      in integer pl_listenerIdx)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
        f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId,": Behavior: ",f_EPTF_LGenBase_bIdx2Str(pl_bIdx),
            " Input: ",f_EPTF_LGenBase_iIdx2Str(pl_bIdx, pl_iIdx),
            " Entity#",pl_eIdx," Listener idx: ",pl_listenerIdx))
      }
      //Is there registered listener?
      var integer vl_listenerListIdx
      if(not f_EPTF_int2int_HashMap_Find(
          v_LGenBase_behaviorTypes[pl_bIdx].entityListenerHashmapRefs[pl_iIdx], 
          pl_eIdx,
          vl_listenerListIdx)){
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
          f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId,": Entity#",pl_eIdx," not found in listener hashmap of behavior ",
              f_EPTF_LGenBase_bIdx2Str(pl_bIdx), " input ",f_EPTF_LGenBase_iIdx2Str(pl_bIdx,pl_iIdx)))
        }
        //No, there isn't. Let's create one.
        vl_listenerListIdx := f_EPTF_Common_IndexArray_setNewElement(v_LGenBase_entities[pl_eIdx].entityListenerListsQueue);
        v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx] := c_EPTF_LGenBase_emptyArrayListenerList;
        f_EPTF_int2int_HashMap_Insert(
          v_LGenBase_behaviorTypes[pl_bIdx].entityListenerHashmapRefs[pl_iIdx],
          pl_eIdx, 
          vl_listenerListIdx)
      }
      return f_EPTF_Common_IndexArray_setNewElement(v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx], pl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_deactivateEntityListener
    // 
    //  Purpose:
    //    Dectivates a listener listening to an event with the specified behavior, input index and target entity index
    //
    //  Parameters:
    //    pl_bIdx - *in* *integer* - the index of the registered behavior returned by the <f_EPTF_LGenBase_declareBehaviorType> function 
    //    pl_iIdx - *in* *integer* - the index of the registered FSM input returned by the <f_EPTF_LGenBase_declareFsmEvent> function 
    //    pl_eIdx - *in* *integer* - the absolute index of the entity 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_deactivateEntityListener(
      in integer pl_bIdx,
      in integer pl_iIdx, 
      in integer pl_eIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      var integer vl_listenerListIdx;
      if(not f_EPTF_int2int_HashMap_Find(
          v_LGenBase_behaviorTypes[pl_bIdx].entityListenerHashmapRefs[pl_iIdx], 
          pl_eIdx, 
          vl_listenerListIdx)){
        f_EPTF_LGenBase_loggingWarning(%definitionId&": Invalid index.")
        return -1;
      }
      var integer vl_ret := f_EPTF_Common_IndexArray_freeElement(v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx],pl_idx2Remove);
      if(f_EPTF_Common_IndexArray_arrayIsEmpty(
          v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx])){
        //There are no more listeners. Remove the list and the reference from the hashmap
        var integer vl_pos := f_EPTF_Common_IndexArray_freeElement(v_LGenBase_entities[pl_eIdx].entityListenerListsQueue,vl_listenerListIdx);
        f_EPTF_Base_assert(%definitionId&" Invalid element in entity listener list!",vl_pos >= 0)
        f_EPTF_int2int_HashMap_Erase(
          v_LGenBase_behaviorTypes[pl_bIdx].entityListenerHashmapRefs[pl_iIdx],
          pl_eIdx)
      }
      return vl_ret;
    }
    
    ////////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_addEntityEventListener
    // 
    //  Purpose:
    //    It is used for activating an event listener at the entity-events level.
    //
    //  Parameters:
    //  - pl_event - *in* <EPTF_LGenBase_ReportableEventDescriptor> - the event to
    //    be listened to, must be valid, target field must be present, asserted
    //  - pl_descr - *in* <EPTF_LGenBase_EventListenerDescriptor> - the listener
    //    to be activated
    //
    //  Return Value:
    //    - 
    //    index of the particular event
    //
    //  Errors:
    //
    //  Detailed Comments:
    //
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_addEntityEventListener(
      in EPTF_LGenBase_ReportableEventDescriptor pl_event,
      in EPTF_LGenBase_EventListenerDescriptor pl_descr
    ) 
    runs on EPTF_LGenBase_Private_CT return integer{
      f_EPTF_LGenBase_loggingWarning(%definitionId&": The obsolete f_EPTF_LGenBase_addEntityEventListener has been called."& 
        " Use the f_EPTF_LGenBase_addEntityEventListener2 instead.");
      return f_EPTF_LGenBase_addEntityEventListener2(
        pl_event.bIdx, pl_event.iIdx, pl_event.target.eIdx, pl_descr.fn, pl_descr.args)
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_addEntityEventListener2
    // 
    //  Purpose:
    //    Adds the listener to the database by the <f_EPTF_LGenBase_addListener>
    //    and activates it by the <f_EPTF_LGenBase_activateEntityListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_addEntityEventListener2(      
      in integer pl_bIdx,
      in integer pl_iIdx, 
      in integer pl_eIdx, 
      in EPTF_LGenBase_EventListener_FT pl_fn,
      in EPTF_IntegerList pl_args)
    runs on EPTF_LGenBase_Private_CT return integer{
      f_EPTF_Base_assert(%definitionId&" behavior type index", 
        (pl_bIdx>=0 and pl_bIdx<sizeof(v_LGenBase_behaviorTypes))
      );
      f_EPTF_Base_assert(%definitionId&" Event/input index", 
        pl_iIdx>=0 
        and pl_iIdx<sizeof(v_LGenBase_fsmEvents[pl_bIdx]));
      f_EPTF_Base_assert(%definitionId&" Entity index", 
        pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities));
      var integer vl_listenerIdx := f_EPTF_LGenBase_addListener(pl_fn, pl_args);
      return f_EPTF_LGenBase_activateEntityListener(pl_bIdx, pl_iIdx, pl_eIdx, vl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeEntityEventListener2
    // 
    //  Purpose:
    //    Deactivates the listener by the <f_EPTF_LGenBase_deactivateEntityListener>
    //    and removes it from the listener database by the <f_EPTF_LGenBase_removeListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeEntityEventListener2(
      in integer pl_bIdx,
      in integer pl_iIdx,
      in integer pl_eIdx,
      in integer pl_idx2Remove
    ) 
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_listenerIdx := f_EPTF_LGenBase_deactivateEntityListener(pl_bIdx, pl_iIdx, pl_eIdx, pl_idx2Remove);
      f_EPTF_LGenBase_removeListener(vl_listenerIdx);
    }
    ////////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeEntityEventListener
    // 
    //  Purpose:
    //    It is used for deactivating an event listener at the entity-events level.
    ////////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeEntityEventListener(
      in integer pl_bIdx,
      in integer pl_iIdx,
      in integer pl_eIdx
    ) 
    runs on EPTF_LGenBase_Private_CT{
      f_EPTF_Base_assert(%definitionId&" behavior type index", 
        (pl_bIdx>=0 and pl_bIdx<sizeof(v_LGenBase_behaviorTypes))
      );
      f_EPTF_Base_assert(%definitionId&" Event/input index", 
        pl_iIdx>=0 
        and pl_iIdx<sizeof(v_LGenBase_fsmEvents[pl_bIdx]));
      f_EPTF_Base_assert(%definitionId&" Entity index", 
        pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities));
      
      f_EPTF_LGenBase_loggingWarning(%definitionId&": The obsolete f_EPTF_LGenBase_removeEntityEventListener function has been called."&
         "This function removes all the entity listeners listening to the entity event having behavior "&
         int2str(pl_bIdx)&", input index "& int2str(pl_iIdx)&", target entity "& int2str(pl_eIdx))
      var integer vl_listenerListIdx;
      if (not f_EPTF_int2int_HashMap_Find (v_LGenBase_behaviorTypes[pl_bIdx].entityListenerHashmapRefs[pl_iIdx],
          pl_eIdx,
          vl_listenerListIdx)) {
        return
      }
      var integer vl_idx := -1;
      while ( not f_EPTF_Common_IndexArray_arrayIsEmpty(v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx]))
      {
        vl_idx := f_EPTF_Common_IndexArray_getFirstBusyIdx(v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx])
        f_EPTF_LGenBase_removeEntityEventListener2(pl_bIdx, pl_iIdx, pl_eIdx, vl_idx);
      }
    }
  } //eventTypeEntity
  
  group eventTypeFSM              {
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_activateFsm
    // 
    //  Purpose:
    //    Activates the given FSM on the specified entity with the specified initial state.
    //
    //  Parameters:
    //    - pl_eIdx - *in* - *integer* - index of the entity on which the FSM is
    //      being activated 
    //    - pl_tIdx - *in* - *integer* - ref. to the FSM table (i.e., to the
    //      entity-independent state-transition ruleset)
    //    - pl_sIdx - *in* - *integer* - the FSM-table-local state index indicating
    //      the assumed initial state of the entity w.r.t. to the table
    //    - pl_tcIdx - *in* - *integer* - if the FSM table was activated from the 
    //      <f_EPTF_LGenBase_initTCInternal> function, then the traffic case index, else it must be -1
    //
    //  Return Value:
    //    - integer - the index of the FSM context of the entity w.r.t. the activated FSM 
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_activateFsm(
      in integer pl_eIdx, 
      in integer pl_tIdx,
      in integer pl_sIdx,
      in integer pl_tcIdx := -1) 
    runs on EPTF_LGenBase_Private_CT 
    return integer 
    {
      if(-1 < pl_tcIdx){
        f_EPTF_LGenBase_loggingWarning(%definitionId&": The obsolete traffic case index argument has been called "&
          "with an invalid value: "&log2str(pl_tcIdx)&" It has been replaced with -1!")
      }
      f_EPTF_Base_assert(%definitionId&" Entity index: "&int2str(pl_eIdx)&" > sizeof(v_LGenBase_entities) ["&int2str(sizeof(v_LGenBase_entities))&"]", 
        pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&" FSM table index", 
        pl_tIdx>=0 and pl_tIdx<sizeof(v_LGenBase_fsmTables)); 
      f_EPTF_Base_assert(%definitionId&" initial state of FSM context", 
        pl_sIdx>=0 and pl_sIdx<sizeof(v_LGenBase_fsmTables[pl_tIdx].stateList)); 
      
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
        f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId,": Activating FSM[",pl_tIdx,"]:=",v_LGenBase_fsmTables[pl_tIdx].name,
            "\nfor entity ", f_EPTF_LGenBase_getEntityName(pl_eIdx), 
            ",\nwith initial state ",v_LGenBase_fsmTables[pl_tIdx].stateList[pl_sIdx],
            ",\nentity ctx before:=", v_LGenBase_entities[pl_eIdx]))
      }
      if(0 < sizeof(v_LGenBase_fsmTables[pl_tIdx].referredFsmList)){
        f_EPTF_LGenBase_loggingError(%definitionId&" - An FSM which refers to a sibling FSM, cannot be activated by activateFsm, use traffic case instead! FSM name: " &v_LGenBase_fsmTables[pl_tIdx].name);
      }      
      var integer vl_ret := f_EPTF_LGenBase_activateFsmGroup(
        pl_tIdx,
        pl_sIdx,
        {entityData := {pl_eIdx}})
      f_EPTF_LGenBase_resetFSMStats(pl_eIdx, vl_ret)
      return vl_ret
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_resetFSMStats
    //
    //  Purpose:
    //    Resets the statistics of an FSM which is not attached to a traffic case
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_resetFSMStats(
      in integer pl_eAbsIdx,
      in integer pl_fsmCtxIdx)
    runs on EPTF_LGenBase_Private_CT
    {
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTrafficVerbose)){
        f_EPTF_LGenBase_loggingDebugTrafficVerbose(%definitionId&": "&log2str(v_LGenBase_entities[pl_eAbsIdx]))
      }
      var integer vl_fsmTableIdx := v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fsmCtxIdx].tableIdx
      //reset variables
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
        f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Entity#"&log2str(pl_eAbsIdx))
        f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": fsmIdx: "&log2str(pl_fsmCtxIdx))
        f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": varList: "&log2str(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fsmCtxIdx].varList))
        f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": declared: "&log2str(v_LGenBase_fsmTables[vl_fsmTableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeFSM]))
      }
      for ( var integer vl_j := 0; vl_j < sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fsmCtxIdx].varList) ; vl_j := vl_j+1 ){
        var EPTF_TopProviderType vl_providerType
        f_EPTF_Var_getTopProviderType(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fsmCtxIdx].varList[vl_j],vl_providerType)
        if(empty == vl_providerType){
          f_EPTF_Var_adjustContent(
            v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fsmCtxIdx].varList[vl_j],
            v_LGenBase_fsmTables[vl_fsmTableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_j].initValue)
        }
      }
      //Disable stats
      for(var integer vl_j := 0; vl_j < sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fsmCtxIdx].statMeasStatList) ; vl_j := vl_j+1 ){
        f_EPTF_StatMeasure_disableStat(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fsmCtxIdx].statMeasStatList[vl_j])
      }
      //Reset stats
      for ( var integer vl_j := 0; vl_j < sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fsmCtxIdx].statMeasStatList) ; vl_j := vl_j+1 ){
        f_EPTF_StatMeasure_initStatValue(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fsmCtxIdx].statMeasStatList[vl_j])
      }
      //Enable stats
      for ( var integer vl_j := 0; vl_j < sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fsmCtxIdx].statMeasStatList) ; vl_j := vl_j+1 ){
        f_EPTF_StatMeasure_enableStat(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fsmCtxIdx].statMeasStatList[vl_j])
      }
    }
    type record EPTF_LGenBase_FsmGroupForEntity {
      integer entityIdx
    }
    type record EPTF_LGenBase_FsmGroupForTC {
      integer tcIdx,
      integer siblingIdx
    }
    type union EPTF_LGenBase_FsmGroupActivationParams{
      EPTF_LGenBase_FsmGroupForEntity entityData,
      EPTF_LGenBase_FsmGroupForTC tcData
    }

    friend function f_EPTF_LGenBase_activateFsmGroup(
      in integer pl_tableIdx,
      in integer pl_stateIdx,
      in EPTF_LGenBase_FsmGroupActivationParams pl_params)
    runs on EPTF_LGenBase_Private_CT 
    return integer 
    {
      if(c_EPTF_Common_debugSwitch){
        if (ischosen(pl_params.tcData)){
          f_EPTF_Base_assert(%definitionId&" Invalid traffic case index "&log2str(pl_params.tcData.tcIdx), 
            pl_params.tcData.tcIdx > -1 and pl_params.tcData.tcIdx< sizeof(v_LGenBase_trafficCases));
          f_EPTF_Base_assert(%definitionId&" The FSM sibling index "&log2str(pl_params.tcData.siblingIdx)
            &" is invalid in traffic case "&v_LGenBase_trafficCases[pl_params.tcData.tcIdx].uniqueName, 
            pl_params.tcData.siblingIdx > -1 and pl_params.tcData.siblingIdx < sizeof(v_LGenBase_trafficCases[pl_params.tcData.tcIdx].fsmList));
        }else{
          f_EPTF_Base_assert(%definitionId&" Invalid entity index "&log2str(pl_params.entityData.entityIdx), 
            pl_params.entityData.entityIdx > -1 and pl_params.entityData.entityIdx < sizeof(v_LGenBase_entities));
        }
      }
      var integer vl_eFirst := 0;
      var integer vl_eCount := 1;
      var integer vl_tcIdx := -1;
      var integer vl_siblingIdx := -1;
      if(ischosen(pl_params.tcData)){
        vl_eFirst := v_LGenBase_entityGroups[v_LGenBase_trafficCases[pl_params.tcData.tcIdx].eGroupBackref].eOffset
        vl_eCount := v_LGenBase_entityGroups[v_LGenBase_trafficCases[pl_params.tcData.tcIdx].eGroupBackref].eCount
        vl_tcIdx := pl_params.tcData.tcIdx;
        vl_siblingIdx := pl_params.tcData.siblingIdx;
      }else{
        vl_eFirst := pl_params.entityData.entityIdx
      }
      var EPTF_LGenBase_EntityFsmCtx vl_newFsmCtx := c_EPTF_LGenBase_emptyEntityFsmCtx
      vl_newFsmCtx.tableIdx := pl_tableIdx
      vl_newFsmCtx.stateIdx := pl_stateIdx
      if (ischosen(pl_params.tcData)){
        vl_newFsmCtx.tcIdx := vl_tcIdx
        vl_newFsmCtx.siblingIdx := vl_siblingIdx
      }// else default -1
      //debug log variable
      vl_newFsmCtx.logBufferVariable := v_LGenBase_defaultLogBuffer
      //Timers
      for (var integer t:=0;t<sizeof(v_LGenBase_fsmTables[pl_tableIdx].timerList);t:=t+1) {
        vl_newFsmCtx.timerData[t] := -1;
        vl_newFsmCtx.timerParams[t] := v_LGenBase_fsmTables[pl_tableIdx].timerList[t].timerParams;
      }
      //The FSM ctx idx of the entity ctx must be set at the beginning of the process
      var EPTF_IntegerList vl_newIdxs := {}
      vl_newIdxs[vl_eCount-1] := -1 
      for ( var integer vl_eIdx := 0; vl_eIdx < vl_eCount ; vl_eIdx := vl_eIdx+1 ){
        var integer vl_entityAbsIdx := vl_eFirst + vl_eIdx
        var integer vl_newFsmCtxIdx:= f_EPTF_FBQ_getOrCreateFreeSlot(v_LGenBase_entities[vl_entityAbsIdx].fsmCtxQueue); 
        f_EPTF_Base_assert(%definitionId&" FSM context management error", vl_newFsmCtxIdx >= sizeof(v_LGenBase_entities[vl_entityAbsIdx].fsmCtxList) or v_LGenBase_entities[vl_entityAbsIdx].fsmCtxList[vl_newFsmCtxIdx].tableIdx==-1);
        f_EPTF_FBQ_moveFromFreeToBusyTail(vl_newFsmCtxIdx, v_LGenBase_entities[vl_entityAbsIdx].fsmCtxQueue);
        vl_newIdxs[vl_eIdx] := vl_newFsmCtxIdx         
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
          f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId,": activating FSM(",v_LGenBase_fsmTables[pl_tableIdx].name,") as the #",vl_newFsmCtxIdx," active FSM of entity ", vl_entityAbsIdx))
        }
        v_LGenBase_entities[vl_entityAbsIdx].fsmCtxList[vl_newFsmCtxIdx] := vl_newFsmCtx
        if(ischosen(pl_params.tcData)){
          v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_eIdx].siblingFsmCtxList[vl_siblingIdx] := vl_newFsmCtxIdx
        }
      }
      //FSM variables
      var integer vl_count := sizeof(v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeFSM]);
      for ( var integer vl_i := 0; vl_i < vl_count ; vl_i := vl_i+1 )
      {
        //Check if it's been declared with different scope
        if (ischosen(pl_params.tcData)){
          var integer vl_varIdxInTC;
          if(f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].TCVarNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name,
              vl_varIdxInTC)){
            //Ooops.
            var integer vl_prevSiblingIdx := v_LGenBase_trafficCases[vl_tcIdx].varList[vl_varIdxInTC].siblingFsmIdx;
            var integer vl_prevFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSiblingIdx].fsmTypeIdx;
            f_EPTF_LGenBase_loggingError(%definitionId&": "&
              " Cannot activate FSM: The variable "&
              v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name&
              "with FSM scope of the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
              " with TC scope."
            );
          }
          if(f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].SiblingFSMVarNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name,
              vl_varIdxInTC)){
            //Ooops.
            var integer vl_prevSiblingIdx := v_LGenBase_trafficCases[vl_tcIdx].siblingVarList[vl_varIdxInTC].siblingFsmIdx;
            var integer vl_prevFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSiblingIdx].fsmTypeIdx;
            f_EPTF_LGenBase_loggingError(%definitionId&": "&
              " Cannot activate FSM: The variable "&
              v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name&
              "with FSM scope of the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
              " with SiblingFSM scope."
            );
          }
          //It's OK. Let's store its table type into the list for later check
          f_EPTF_str2int_HashMap_Insert(
            v_LGenBase_trafficCases[vl_tcIdx].FSMVarNamesHash,
            v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name,
            pl_tableIdx)
        }
        for ( var integer vl_eIdx := 0; vl_eIdx < vl_eCount ; vl_eIdx := vl_eIdx+1 ){
          var integer vl_entityAbsIdx := vl_eFirst + vl_eIdx
          var charstring vl_varName := f_EPTF_LGenBase_varNameOfFSMVar(vl_entityAbsIdx, vl_newIdxs[vl_eIdx], 
            v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name);
          v_LGenBase_entities[vl_entityAbsIdx].fsmCtxList[vl_newIdxs[vl_eIdx]].varList[vl_i] := 
          f_EPTF_Var_newVar(
            vl_varName, 
            v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].initValue)
          if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
            f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": New FSM variable has been created: "&vl_varName);
            f_EPTF_Var_addPostProcFn(v_LGenBase_entities[vl_entityAbsIdx].fsmCtxList[vl_newIdxs[vl_eIdx]].varList[vl_i],
              {refers(f_EPTF_LGenBase_fsmVarDebugPostproc),{}})
          }
        }
      }
      
      if(ischosen(pl_params.tcData)){
        ///////////////////////////////////////////////////////////////////////
        //FSM sibling variables
        //Step through the variables having scope siblingFSM
        var integer vl_varCount := sizeof(v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM]);
        var integer vl_varIdxInEntityInfo := -1
        for ( var integer vl_var := 0; vl_var < vl_varCount ; vl_var := vl_var+1 ){
          var charstring vl_varName := v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_var].name
          //Check if it's already created in an other FSM
          //TC scope
          var integer vl_varIdxInTC;
          if(f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].TCVarNamesHash,
              vl_varName,
              vl_varIdxInTC)){
            //Ooops.
            var integer vl_prevSiblingIdx := v_LGenBase_trafficCases[vl_tcIdx].varList[vl_varIdxInTC].siblingFsmIdx;
            var integer vl_prevFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSiblingIdx].fsmTypeIdx;
            f_EPTF_LGenBase_loggingError(%definitionId&": "&
              " Cannot activate FSM: The variable "&
              vl_varName&
              "with FSM scope of the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
              " with TC scope."
            );
          }
          
          var integer vl_prevFSMTableTypeIdx;
          if (f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].FSMVarNamesHash,
              vl_varName,
              vl_prevFSMTableTypeIdx)) {
            f_EPTF_LGenBase_loggingError(%definitionId&": "&
              " Cannot activate FSM: The variable "&
              vl_varName&
              "with SiblingFSM scope in the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
              " with FSM scope."
            );
          }
          
          var boolean vl_varExists := f_EPTF_str2int_HashMap_Find(
            v_LGenBase_trafficCases[vl_tcIdx].SiblingFSMVarNamesHash,
            vl_varName,
            vl_varIdxInEntityInfo)
          if (vl_varExists) {
            //Check the initial values
            var integer vl_siblingIdxOfPrev := v_LGenBase_trafficCases[vl_tcIdx].siblingVarList[vl_varIdxInEntityInfo].siblingFsmIdx;
            var integer vl_prevTableIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_siblingIdxOfPrev].fsmTypeIdx;
            var integer vl_idxInFsm := v_LGenBase_trafficCases[vl_tcIdx].siblingVarList[vl_varIdxInEntityInfo].idxInFsm;
            if(v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_var].initValue
              != v_LGenBase_fsmTables[vl_prevTableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_idxInFsm].initValue){
              f_EPTF_LGenBase_loggingError(%definitionId&": FSM variable "
                &v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_var].name
                &" of FSM "&v_LGenBase_fsmTables[pl_tableIdx].name
                &" is already defined in "&v_LGenBase_fsmTables[vl_prevTableIdx].name
                &"with different initial value. "
                &"\nPrevious value: "&log2str(v_LGenBase_fsmTables[vl_prevTableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_idxInFsm].initValue)
                &"\nNew value: "&log2str(v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_var].initValue))
            }
          }else{
            
            vl_varIdxInEntityInfo := v_LGenBase_trafficCases[vl_tcIdx].siblingVarCount;
            f_EPTF_str2int_HashMap_Insert(
              v_LGenBase_trafficCases[vl_tcIdx].SiblingFSMVarNamesHash,
              vl_varName,
              vl_varIdxInEntityInfo)
            v_LGenBase_trafficCases[vl_tcIdx].siblingVarCount := v_LGenBase_trafficCases[vl_tcIdx].siblingVarCount + 1;
            v_LGenBase_trafficCases[vl_tcIdx].siblingVarList[vl_varIdxInEntityInfo] := c_EPTF_LGenBase_emptyTcSiblingVarDescriptor
            v_LGenBase_trafficCases[vl_tcIdx].siblingVarList[vl_varIdxInEntityInfo].siblingFsmIdx := vl_siblingIdx;
            v_LGenBase_trafficCases[vl_tcIdx].siblingVarList[vl_varIdxInEntityInfo].idxInFsm := vl_var;
            //Each siblingFSM variable is shared by the sibling FSMs of the same entity
            //Step through the variables per entities of the TC
            for ( var integer vl_eRelIdx := 0; vl_eRelIdx < vl_eCount ; vl_eRelIdx := vl_eRelIdx+1 ){
              var charstring vl_siblingVarName := f_EPTF_LGenBase_varNameOfSiblingFSMsVar(vl_tcIdx, vl_eRelIdx, vl_varName)
              v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_eRelIdx].siblingFsmVarList[vl_varIdxInEntityInfo] :=
              f_EPTF_Var_newVar(vl_siblingVarName, v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_var].initValue);
            }
          }
          //Position in the entity info
          v_LGenBase_trafficCases[vl_tcIdx].siblingFsmVarIdxInFsm[vl_siblingIdx][vl_var] := vl_varIdxInEntityInfo;
        }
        ///////////////////////////////////////////////////////////////////////
        //FSM TC variables
        vl_varCount := sizeof(v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeTC]);
        var integer vl_varCountInTC := sizeof(v_LGenBase_trafficCases[vl_tcIdx].varList)
        var integer vl_varIdxInTc := -1
        for ( var integer vl_i := 0; vl_i < vl_varCount ; vl_i := vl_i+1 )
        {
          //fsmList
          //Check in SiblingFSM scope
          var integer vl_varIdxInTC;
          var charstring vl_varName := v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name
          if(f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].SiblingFSMVarNamesHash,
              vl_varName,
              vl_varIdxInTC)){
            //Ooops.
            var integer vl_prevSiblingIdx := v_LGenBase_trafficCases[vl_tcIdx].siblingVarList[vl_varIdxInTC].siblingFsmIdx;
            var integer vl_prevFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSiblingIdx].fsmTypeIdx;
            f_EPTF_LGenBase_loggingError(%definitionId&": "&
              " Cannot activate FSM: The variable "&
              vl_varName&
              "with FSM scope of the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
              " with SiblingFSM scope."
            );
          }
          
          //Check in FSM scope
          var integer vl_prevFSMTableTypeIdx;
          if (f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].FSMVarNamesHash,
              vl_varName,
              vl_prevFSMTableTypeIdx)) {
            f_EPTF_LGenBase_loggingError(%definitionId&": "&
              " Cannot activate FSM: The variable "&
              vl_varName&
              "with SiblingFSM scope in the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
              " with FSM scope."
            );
          }
          //Check if it's already created in an other FSM
          var boolean vl_varExists := f_EPTF_str2int_HashMap_Find(
            v_LGenBase_trafficCases[vl_tcIdx].TCVarNamesHash,
            v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name,
            vl_varIdxInTc)
          var charstring vl_decoratedVarName := f_EPTF_LGenBase_varNameOfTCVar(vl_tcIdx,
            v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name);
          if( not vl_varExists ){
            v_LGenBase_trafficCases[vl_tcIdx].varList[vl_varCountInTC].siblingFsmIdx := vl_siblingIdx;
            v_LGenBase_trafficCases[vl_tcIdx].varList[vl_varCountInTC].idxInFsm := vl_i
            v_LGenBase_trafficCases[vl_tcIdx].varList[vl_varCountInTC].varId := 
            f_EPTF_Var_newVar(
              vl_decoratedVarName, 
              v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].initValue)
            vl_varIdxInTc := vl_varCountInTC
            vl_varCountInTC := vl_varCountInTC + 1
            f_EPTF_str2int_HashMap_Insert(
              v_LGenBase_trafficCases[vl_tcIdx].TCVarNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name,
              vl_varIdxInTc)
            if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
              f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": New FSM TC variable has been created: "&vl_decoratedVarName&
                " VarID: "&int2str(v_LGenBase_trafficCases[vl_tcIdx].varList[vl_i].varId));
              f_EPTF_Var_addPostProcFn(v_LGenBase_trafficCases[vl_tcIdx].varList[vl_i].varId, {refers(f_EPTF_LGenBase_fsmVarDebugPostproc),{}})
            }
          }else{
            //Check previous declaration
            var integer vl_prevTableIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[v_LGenBase_trafficCases[vl_tcIdx].varList[vl_varIdxInTc].siblingFsmIdx].fsmTypeIdx
            var integer vl_idxInFsm := v_LGenBase_trafficCases[vl_tcIdx].varList[vl_varIdxInTc].idxInFsm
            if(v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].initValue
              != v_LGenBase_fsmTables[vl_prevTableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_idxInFsm].initValue){
              f_EPTF_LGenBase_loggingError(%definitionId&": FSM variable "
                &v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name
                &" of FSM "&v_LGenBase_fsmTables[pl_tableIdx].name
                &" is already defined in "&v_LGenBase_fsmTables[vl_prevTableIdx].name
                &"with different initial value. "
                &"\nPrevious value: "&log2str(v_LGenBase_fsmTables[vl_prevTableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_idxInFsm].initValue)
                &"\nNew value: "&log2str(v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].initValue))
            }
          }
          v_LGenBase_trafficCases[vl_tcIdx].varIdxInFsm[vl_siblingIdx][vl_i]:= vl_varIdxInTc
        }
      }
      ///////////////////////////////////////////////////////////////////////
      //FSM measured statistics
      var integer vl_statCount := sizeof(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM]);
      
      for ( var integer vl_i := 0; vl_i < vl_statCount ; vl_i := vl_i+1 )
      {
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
          f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Processing measured statistic declaration: "&
            log2str(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i]))
        }
        if(ischosen(pl_params.tcData)){
          //Check if it's already created in an other FSM
          //Check TC scope
          var integer vl_statMeasIdxInEntityInfo := -1
          if( f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].TCStatMeasNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name,
              vl_statMeasIdxInEntityInfo)) {
            var integer vl_prevSibling := v_LGenBase_trafficCases[vl_tcIdx].statMeasStatList[vl_statMeasIdxInEntityInfo].siblingFsmIdx
            var integer vl_prefFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSibling].fsmTypeIdx;
            f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics with FSM scope "&
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name&
              " of the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
              " with TC scope."
            );
          }
          //Check siblingFSM scope
          vl_statMeasIdxInEntityInfo := -1
          if( f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].SiblingFSMStatMeasNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name,
              vl_statMeasIdxInEntityInfo)) {
            var integer vl_prevSibling := v_LGenBase_trafficCases[vl_tcIdx].siblingStatMeasStatList[vl_statMeasIdxInEntityInfo].siblingFsmIdx
            var integer vl_prefFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSibling].fsmTypeIdx;
            f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics with FSM scope "&
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name&
              " of the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
              " with SiblingFSM scope."
            );
          }
        }
        var integer vl_varXRef := v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].varXRef
        var integer vl_varIdxInScope := -1 
        var integer vl_varId := -1
        for ( var integer vl_eIdx := 0; vl_eIdx < vl_eCount ; vl_eIdx := vl_eIdx+1 ){
          var integer vl_entity := vl_eFirst + vl_eIdx
          var integer vl_newFsmCtxIdx:= vl_newIdxs[vl_eIdx] 
          if(-1 != vl_varXRef){
            
            if (c_EPTF_LGenBase_fsmObjectScopeFSM!= v_LGenBase_fsmTables[pl_tableIdx].varXRefs[vl_varXRef].scope) {
              f_EPTF_LGenBase_loggingError(%definitionId&": Invalid provider variable scope: "&
                log2str(v_LGenBase_fsmTables[pl_tableIdx].varXRefs[vl_varXRef].scope)&" for statMeasStat "&
                v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name&
                " in FSM table "&v_LGenBase_fsmTables[pl_tableIdx].name& ". It should be FSM scope")
            }
            vl_varIdxInScope := v_LGenBase_fsmTables[pl_tableIdx].varXRefs[vl_varXRef].idxInScope;
            vl_varId := v_LGenBase_entities[vl_entity].fsmCtxList[vl_newFsmCtxIdx].varList[vl_varIdxInScope];
          }
          if(ischosen(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].params.params)){
            v_LGenBase_entities[vl_entity].fsmCtxList[vl_newFsmCtxIdx].statMeasStatList[vl_i] := 
            f_EPTF_StatMeasure_newStatWithParams(
              vl_varId,
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].params.params)
          }else{
            v_LGenBase_entities[vl_entity].fsmCtxList[vl_newFsmCtxIdx].statMeasStatList[vl_i] := 
            f_EPTF_StatMeasure_newStat(
              vl_varId,
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].params.statType)
          }
          f_EPTF_StatMeasure_disableStat(v_LGenBase_entities[vl_entity].fsmCtxList[vl_newFsmCtxIdx].statMeasStatList[vl_i])
          f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": New FSM measured statistic has been created: "&
            v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name&
            "\n ID: "&log2str(v_LGenBase_entities[vl_entity].fsmCtxList[vl_newFsmCtxIdx].statMeasStatList[vl_i]));
          if("" != v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].targetVarName){
            var charstring vl_targetVarName := v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].targetVarName
            var EPTF_LGenBase_FsmObjectScope vl_varScope := c_EPTF_LGenBase_fsmObjectScopeFSM
            var integer vl_varXref := -1
            if(f_EPTF_str2int_HashMap_Find(v_LGenBase_fsmTables[pl_tableIdx].varNamesHash, vl_targetVarName, vl_varXref)){
              vl_varScope := v_LGenBase_fsmTables[pl_tableIdx].varXRefs[vl_varXref].scope
            }else{
              f_EPTF_Base_assert(%definitionId&": Invalid target variable: "&vl_targetVarName&" for FSM measured statistic "&
                v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name,false);
            }
            var charstring vl_decoratedTargetVarName := ""
            select( vl_varScope ){
              case ( c_EPTF_LGenBase_fsmObjectScopeFSM ){
                vl_decoratedTargetVarName := f_EPTF_LGenBase_varNameOfFSMVar(vl_eIdx, vl_newFsmCtxIdx, vl_targetVarName) 
              }
              case ( c_EPTF_LGenBase_fsmObjectScopeSiblingFSM ){
                if(ischosen(pl_params.tcData)){
                  vl_decoratedTargetVarName := f_EPTF_LGenBase_varNameOfSiblingFSMsVar(vl_tcIdx, vl_eIdx, vl_targetVarName);
                }else{
                  f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM table: FSM table "&v_LGenBase_fsmTables[pl_tableIdx].name
                    &" is activated outside of a TC, but the target value of the measured statistics "&
                    v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name&
                    " has a SiblingFSM scope");
                }
              }
              case ( c_EPTF_LGenBase_fsmObjectScopeTC ){
                if(ischosen(pl_params.tcData)){
                  vl_decoratedTargetVarName := f_EPTF_LGenBase_varNameOfTCVar(vl_tcIdx, vl_targetVarName)
                }else{
                  f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM table: FSM table "&v_LGenBase_fsmTables[pl_tableIdx].name
                    &" is activated outside of a TC, but the target value of the measured statistics "&
                    v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name&
                    " has a TC scope");
                }
              }
              case else{
                f_EPTF_Base_assert(%definitionId&": Invalid variable scope: "&log2str(vl_varScope)&" for FSM variable "&vl_targetVarName,false);
              }
            }
            //v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].targetVarName := vl_decoratedTargetVarName
            if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
              f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Create variable "&vl_decoratedTargetVarName&
                " for measured statistics: "&v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name)
            }
            v_LGenBase_dummyInt := f_EPTF_StatMeasure_createVarFromStat(
              v_LGenBase_entities[vl_entity].fsmCtxList[vl_newFsmCtxIdx].statMeasStatList[vl_i], 
              vl_decoratedTargetVarName)
          }
        }
        if(ischosen(pl_params.tcData)){
          f_EPTF_str2int_HashMap_Insert(
            v_LGenBase_trafficCases[vl_tcIdx].FSMStatMeasNamesHash,
            v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name,
            pl_tableIdx);
        }
      }
      if(ischosen(pl_params.tcData)){
        ///////////////////////////////////////////////////////////////////////
        // Sibling measured statistics
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
          f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": SiblingFSM measured statistics \n TC idx: "&int2str(vl_tcIdx)&
            "\n StatMeas declarator list: "&log2str(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM]))
        }
        vl_statCount := sizeof(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM]);
        for ( var integer vl_i := 0; vl_i < vl_statCount ; vl_i := vl_i+1 )
        {
          //fsmList
          //Check if it's already created in an other FSM
          //Check TC scope
          var integer vl_statMeasIdxInEntityInfo := -1
          if( f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].TCStatMeasNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name,
              vl_statMeasIdxInEntityInfo)) {
            var integer vl_prevSibling := v_LGenBase_trafficCases[vl_tcIdx].statMeasStatList[vl_statMeasIdxInEntityInfo].siblingFsmIdx
            var integer vl_prefFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSibling].fsmTypeIdx;
            f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics with SiblingFSM scope "&
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name&
              " of the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
              " with TC scope."
            );
          }
          
          //Check FSM scope
          var integer vl_prevFSMTableTypeIdx;
          if (f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].FSMStatMeasNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name,
              vl_prevFSMTableTypeIdx)) {
            f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics with SiblingFSM scope "&
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name&
              " of the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
              " with FSM scope."
            );
          }
          
          //Current declaration
          var integer vl_varXRef := v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].varXRef
          var EPTF_LGenBase_FsmObjectScope vl_varScope;
          var integer vl_idxInScopeInFSM;
          var charstring vl_currentVarName := "";
          var EPTF_Var_DirectContent vl_currentInitContent;
          var integer vl_varId := -1;
          var integer vl_providerVarIdxInTc := -1;
          if(-1 != vl_varXRef){
            vl_varScope := v_LGenBase_fsmTables[pl_tableIdx].varXRefs[vl_varXRef].scope;
            if ( c_EPTF_LGenBase_fsmObjectScopeSiblingFSM != vl_varScope ){
              f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics "&
                v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name&
                " of the FSM "&
                v_LGenBase_fsmTables[pl_tableIdx].name&
                " in TC "&
                v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                " has a provider variable "&vl_currentVarName&" with invalid scope. It should be SiblingFSM."
              );
            }
            vl_idxInScopeInFSM := v_LGenBase_fsmTables[pl_tableIdx].varXRefs[vl_varXRef].idxInScope;
            vl_currentVarName := v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_idxInScopeInFSM].name;
            vl_currentInitContent := v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_idxInScopeInFSM].initValue;
            vl_providerVarIdxInTc := v_LGenBase_trafficCases[vl_tcIdx].siblingFsmVarIdxInFsm[vl_siblingIdx][vl_idxInScopeInFSM];
          }
          
          //Check previous SiblingFSM declaration
          if(f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].SiblingFSMStatMeasNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name,
              vl_statMeasIdxInEntityInfo)) {
            //Data of previous declaration
            var integer vl_prevSibling := v_LGenBase_trafficCases[vl_tcIdx].siblingStatMeasStatList[vl_statMeasIdxInEntityInfo].siblingFsmIdx;
            vl_prevFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSibling].fsmTypeIdx;
            var integer vl_idxInFsm := v_LGenBase_trafficCases[vl_tcIdx].siblingStatMeasStatList[vl_statMeasIdxInEntityInfo].idxInFsm;
            var charstring vl_prevVarName := ""
            var integer vl_prevVarXRef := v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_idxInFsm].varXRef
            var integer vl_varIdxInScopeInPrevFsm
            var EPTF_LGenBase_FsmObjectScope vl_prevVarScope;
            var EPTF_Var_DirectContent vl_prevInitContent;
            if(-1 < vl_prevVarXRef){
              vl_prevVarScope := v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].varXRefs[vl_prevVarXRef].scope;
              vl_varIdxInScopeInPrevFsm := v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].varXRefs[vl_prevVarXRef].idxInScope
              vl_prevVarName := v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].varListArray[vl_prevVarScope][vl_varIdxInScopeInPrevFsm].name;
              vl_prevInitContent := v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].varListArray[vl_prevVarScope][vl_varIdxInScopeInPrevFsm].initValue;
            }
            if (vl_prevVarXRef == -1 and vl_varXRef != -1) {
              f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics "&
                v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name&
                " of the FSM "&
                v_LGenBase_fsmTables[pl_tableIdx].name&
                " in TC "&
                v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                " already defined in FSM "&
                v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
                ". The previous declaration has a provider variable, but the current does not have any."
              );
            }
            if (vl_prevVarXRef != -1 and vl_varXRef == -1) {
              f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics "&
                v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name&
                " of the FSM "&
                v_LGenBase_fsmTables[pl_tableIdx].name&
                " in TC "&
                v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                " already defined in FSM "&
                v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
                ". The current declaration has a provider variable, but the previous one does not have any."
              );
            }
            
            if (vl_varXRef != -1) {
              if (vl_prevVarName !=vl_currentVarName) {
                f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics "&
                  v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name&
                  " of the FSM "&
                  v_LGenBase_fsmTables[pl_tableIdx].name&
                  " in TC "&
                  v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                  " already defined in FSM "&
                  v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
                  ". The current declaration has a provider variable, and the previous one has one with different name."
                );
              }
              if (vl_currentInitContent != vl_prevInitContent) {
                f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics "&
                  v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name&
                  " of the FSM "&
                  v_LGenBase_fsmTables[pl_tableIdx].name&
                  " in TC "&
                  v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                  " already defined in FSM "&
                  v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
                  ". The current declaration has a provider variable, and the previous one has one with different init value."
                );
              }
            }
            
            
            if (v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].params != 
              v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_idxInFsm].params) {
              f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics "&
                v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name&
                " of the FSM "&
                v_LGenBase_fsmTables[pl_tableIdx].name&
                " in TC "&
                v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                " already defined in FSM "&
                v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
                ". The parameters of the current declaration is different from the parameters of the previous declaration."
              );                
            }
            if (
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].targetVarName != 
              v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_idxInFsm].targetVarName
            ) {
              f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics "&
                v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name&
                " of the FSM "&
                v_LGenBase_fsmTables[pl_tableIdx].name&
                " in TC "&
                v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                " already defined in FSM "&
                v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
                ". The target varName of the current declaration differs from the target varName of the previous declaration."
              );
            }
          }else{
            vl_statMeasIdxInEntityInfo := v_LGenBase_trafficCases[vl_tcIdx].siblingStatMeasCount;
            f_EPTF_str2int_HashMap_Insert(
              v_LGenBase_trafficCases[vl_tcIdx].SiblingFSMStatMeasNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name,
              vl_statMeasIdxInEntityInfo)
            v_LGenBase_trafficCases[vl_tcIdx].siblingStatMeasCount := v_LGenBase_trafficCases[vl_tcIdx].siblingStatMeasCount + 1;
            v_LGenBase_trafficCases[vl_tcIdx].siblingStatMeasStatList[vl_statMeasIdxInEntityInfo] := c_EPTF_LGenBase_emptyTcSiblingVarDescriptor
            v_LGenBase_trafficCases[vl_tcIdx].siblingStatMeasStatList[vl_statMeasIdxInEntityInfo].siblingFsmIdx := vl_siblingIdx;
            v_LGenBase_trafficCases[vl_tcIdx].siblingStatMeasStatList[vl_statMeasIdxInEntityInfo].idxInFsm := vl_i;
            //Step through the variables per entities of the TC
            for ( var integer vl_eRelIdx := 0; vl_eRelIdx < vl_eCount ; vl_eRelIdx := vl_eRelIdx+1 ){
              var integer vl_statMeasId := -1
              vl_varId := -1;
              if(-1 < vl_providerVarIdxInTc){
                vl_varId := v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_eRelIdx].siblingFsmVarList[vl_providerVarIdxInTc];
              }
              select( true ){
                case ( ischosen(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].params.params )){
                  vl_statMeasId :=
                  f_EPTF_StatMeasure_newStatWithParams(
                    vl_varId,
                    v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].params.params)
                  if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
                    f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": f_EPTF_StatMeasure_newStatWithParams("&
                      log2str(vl_varId)&
                      ","&log2str(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].params.params));
                  }
                }
                case ( ischosen(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].params.statType )){
                  vl_statMeasId :=
                  f_EPTF_StatMeasure_newStat(
                    vl_varId,
                    v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].params.statType)
                  if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
                    f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": f_EPTF_StatMeasure_newStat("&
                      log2str(vl_varId)&","&
                      log2str(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].params.statType));
                  }
                }
                case else
                {
                  //A bit paranoia
                  f_EPTF_Base_assert(%definitionId&": Unknown StatMeasure declaration type: "&log2str(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].params),false);
                }
              }
              //Store the new statMeas ID
              v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_eRelIdx].siblingFsmStatMeasList[vl_statMeasIdxInEntityInfo] := vl_statMeasId;
            }
          }
          //Store the position in the entity info
          v_LGenBase_trafficCases[vl_tcIdx].siblingFsmStatMeasIdxInFsm[vl_siblingIdx][vl_i] := vl_statMeasIdxInEntityInfo;
          
        }
        
        ///////////////////////////////////////////////////////////////////////
        //FSM TC measured statistics
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
          f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": TC measured statistics \n TC idx: "&int2str(vl_tcIdx)&
            "\n StatMeas declarator list: "&log2str(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC]))
        }
        vl_statCount := sizeof(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC]);
        for ( var integer vl_i := 0; vl_i < vl_statCount ; vl_i := vl_i+1 )
        {
          //fsmList
          //Check if it's already created in an other FSM
          //Check SiblingFSM scope
          var integer vl_statMeasIdxInEntityInfo := -1
          if( f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].SiblingFSMStatMeasNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name,
              vl_statMeasIdxInEntityInfo)) {
            var integer vl_prevSibling := v_LGenBase_trafficCases[vl_tcIdx].siblingStatMeasStatList[vl_statMeasIdxInEntityInfo].siblingFsmIdx
            var integer vl_prefFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSibling].fsmTypeIdx;
            f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics with SiblingFSM scope "&
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name&
              " of the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
              " with TC scope."
            );
          }
          
          //Check FSM scope
          var integer vl_prevFSMTableTypeIdx;
          if (f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].FSMStatMeasNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name,
              vl_prevFSMTableTypeIdx)) {
            f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics with SiblingFSM scope "&
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name&
              " of the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
              " with FSM scope."
            );
          }
          
          
          var integer vl_statMeasIdxInTc := -1
          //Current provider var data
          var integer vl_varId := -1
          var charstring vl_currentVarName := "";
          var EPTF_Var_DirectContent vl_currentInitContent;
          var integer vl_idxInScopeInFSM;
          var integer vl_providerVarIdxInTc;
          var integer vl_varXRef := v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].varXRef
          if(-1 != vl_varXRef){
            
            var EPTF_LGenBase_FsmObjectScope vl_varScope := v_LGenBase_fsmTables[pl_tableIdx].varXRefs[vl_varXRef].scope;
            
            
            if ( c_EPTF_LGenBase_fsmObjectScopeTC == vl_varScope ){
              vl_idxInScopeInFSM := v_LGenBase_fsmTables[pl_tableIdx].varXRefs[vl_varXRef].idxInScope;
              vl_providerVarIdxInTc := v_LGenBase_trafficCases[vl_tcIdx].varIdxInFsm[vl_siblingIdx][vl_idxInScopeInFSM];
              vl_varId := v_LGenBase_trafficCases[vl_tcIdx].varList[vl_providerVarIdxInTc].varId
              vl_currentVarName     := v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_idxInScopeInFSM].name;
              vl_currentInitContent := v_LGenBase_fsmTables[pl_tableIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_idxInScopeInFSM].initValue;
            }
            else
            {
              //TODO Prevent it in FSM preprocessing
              f_EPTF_LGenBase_loggingError(%definitionId&": Invalid provider variable scope: the scope of input variable of TC statMeas statistic "
                &v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name
                &" in FSM table "&v_LGenBase_fsmTables[pl_tableIdx].name&
                " must be TC scope.");
            }
          }
          
          if(f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].TCStatMeasNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name,
              vl_statMeasIdxInTc)){
            
            //Check previous declaration
            //Data of previous declaration
            var integer vl_prevSibling := v_LGenBase_trafficCases[vl_tcIdx].statMeasStatList[vl_statMeasIdxInTc].siblingFsmIdx;
            vl_prevFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSibling].fsmTypeIdx;
            var integer vl_idxInFsm := v_LGenBase_trafficCases[vl_tcIdx].statMeasStatList[vl_statMeasIdxInTc].idxInFsm;
            var charstring vl_prevVarName := ""
            var integer vl_prevVarXRef := v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_idxInFsm].varXRef
            var integer vl_varIdxInScopeInPrevFsm
            var EPTF_LGenBase_FsmObjectScope vl_prevVarScope;
            var EPTF_Var_DirectContent vl_prevInitContent;
            if(-1 < vl_prevVarXRef){
              vl_varIdxInScopeInPrevFsm := v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].varXRefs[vl_prevVarXRef].idxInScope
              vl_prevVarScope := v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].varXRefs[vl_prevVarXRef].scope;
              vl_prevVarName := v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].varListArray[vl_prevVarScope][vl_varIdxInScopeInPrevFsm].name;
              vl_prevInitContent := v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].varListArray[vl_prevVarScope][vl_varIdxInScopeInPrevFsm].initValue;
            }
            if (vl_prevVarXRef == -1 and vl_varXRef != -1) {
              f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics "&
                v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name&
                " of the FSM "&
                v_LGenBase_fsmTables[pl_tableIdx].name&
                " in TC "&
                v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                " already defined in FSM "&
                v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
                ". The previous declaration has a provider variable, but the current does not have any."
              );
            }
            if (vl_prevVarXRef != -1 and vl_varXRef == -1) {
              f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics "&
                v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name&
                " of the FSM "&
                v_LGenBase_fsmTables[pl_tableIdx].name&
                " in TC "&
                v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                " already defined in FSM "&
                v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
                ". The current declaration has a provider variable, but the previous one does not have any."
              );
            }
            
            if (vl_varXRef != -1) {
              if (vl_prevVarName !=vl_currentVarName) {
                f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics "&
                  v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name&
                  " of the FSM "&
                  v_LGenBase_fsmTables[pl_tableIdx].name&
                  " in TC "&
                  v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                  " already defined in FSM "&
                  v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
                  ". The current declaration has a provider variable, and the previous one has one with different name."
                );
              }
              if (vl_currentInitContent != vl_prevInitContent) {
                f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics "&
                  v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name&
                  " of the FSM "&
                  v_LGenBase_fsmTables[pl_tableIdx].name&
                  " in TC "&
                  v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                  " already defined in FSM "&
                  v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
                  ". The current declaration has a provider variable, and the previous one has one with different init value."
                );
              }
            }
            
            
            if (v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].params != 
              v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_idxInFsm].params) {
              f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics "&
                v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name&
                " of the FSM "&
                v_LGenBase_fsmTables[pl_tableIdx].name&
                " in TC "&
                v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                " already defined in FSM "&
                v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
                ". The parameters of the current declaration is different from the parameters of the previous declaration."
              );                
            }
            if (
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].targetVarName != 
              v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_idxInFsm].targetVarName
            ) {
              f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The measured statistics "&
                v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name&
                " of the FSM "&
                v_LGenBase_fsmTables[pl_tableIdx].name&
                " in TC "&
                v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                " already defined in FSM "&
                v_LGenBase_fsmTables[vl_prevFSMTableTypeIdx].name&
                ". The target varName of the current declaration differs from the target varName of the previous declaration."
              );
            }
          }else{
            var integer vl_statMeasId := -1
            select( true ){
              case ( ischosen(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].params.params )){
                vl_statMeasId :=
                f_EPTF_StatMeasure_newStatWithParams(
                  vl_varId,
                  v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].params.params)
                if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
                  f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": f_EPTF_StatMeasure_newStatWithParams("&
                    log2str(vl_varId)&
                    ","&log2str(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].params.params));
                }
              }
              case ( ischosen(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].params.statType )){
                vl_statMeasId :=
                f_EPTF_StatMeasure_newStat(
                  vl_varId,
                  v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].params.statType)
                if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
                  f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": f_EPTF_StatMeasure_newStat("&
                    log2str(vl_varId)&","&
                    log2str(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].params.statType));
                }
              }
              case else
              {
                //A bit paranoia
                f_EPTF_Base_assert(%definitionId&": Unknown StatMeasure declaration type: "&log2str(v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].params),false);
              }
            }
            vl_statMeasIdxInTc := sizeof(v_LGenBase_trafficCases[vl_tcIdx].statMeasStatList);
            v_LGenBase_trafficCases[vl_tcIdx].statMeasStatList[vl_statMeasIdxInTc] := c_EPTF_LGenBase_emptyTcStatMeasDescriptor;
            v_LGenBase_trafficCases[vl_tcIdx].statMeasStatList[vl_statMeasIdxInTc].statId := vl_statMeasId
            v_LGenBase_trafficCases[vl_tcIdx].statMeasStatList[vl_statMeasIdxInTc].siblingFsmIdx := vl_siblingIdx
            v_LGenBase_trafficCases[vl_tcIdx].statMeasStatList[vl_statMeasIdxInTc].idxInFsm := vl_i;
            f_EPTF_str2int_HashMap_Insert(
              v_LGenBase_trafficCases[vl_tcIdx].TCStatMeasNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name,
              vl_statMeasIdxInTc)
            f_EPTF_StatMeasure_disableStat(vl_statMeasId)
            //Check the target variable
            if("" != v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].targetVarName){
              var charstring vl_targetVarName := v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].targetVarName
              var integer vl_varXref := -1
              if(not f_EPTF_str2int_HashMap_Find(v_LGenBase_fsmTables[pl_tableIdx].varNamesHash, vl_targetVarName, vl_varXref)){
                //Error. The var must be declared
                f_EPTF_LGenBase_loggingError(%definitionId&": The target variable "&vl_targetVarName
                  &" of statMeas "&v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name
                  &" is not declared in FSM table "&v_LGenBase_fsmTables[pl_tableIdx].name)
              }
              var charstring vl_decoratedTargetVarName := ""
              if(c_EPTF_LGenBase_fsmObjectScopeTC != v_LGenBase_fsmTables[pl_tableIdx].varXRefs[vl_varXref].scope){
                f_EPTF_LGenBase_loggingError(%definitionId&": Invalid variable scope: "
                  &log2str(v_LGenBase_fsmTables[pl_tableIdx].varXRefs[vl_varXref].scope)
                  &". The scope of target variable of TC statMeas statistic "&
                  v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name
                  &" in FSM table "&v_LGenBase_fsmTables[pl_tableIdx].name&
                  " must be TC.")
              }
              vl_decoratedTargetVarName := f_EPTF_LGenBase_varNameOfTCVar(vl_tcIdx, vl_targetVarName)
              v_LGenBase_dummyInt := f_EPTF_StatMeasure_createVarFromStat(v_LGenBase_trafficCases[vl_tcIdx].statMeasStatList[vl_i].statId, vl_decoratedTargetVarName)
              if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
                f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Create variable "&vl_decoratedTargetVarName&
                  " for StatMeas TC measured statistics: "&v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name)
              }
            }
            if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
              f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": New FSM TC measured statistic has been created: "&
                v_LGenBase_fsmTables[pl_tableIdx].statMeasStatListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name&
                "\nID: "&int2str(v_LGenBase_trafficCases[vl_tcIdx].statMeasStatList[vl_i].statId));
            }
          }
          v_LGenBase_trafficCases[vl_tcIdx].statMeasIdxInFsm[vl_siblingIdx][vl_i]:= vl_statMeasIdxInTc
        }
      }
      
      //////////////////////////////////////////////////////////////////////
      // Declaring FSM stathander stats
      //////////////////////////////////////////////////////////////////////
      vl_statCount := sizeof(v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeFSM]);
      for ( var integer vl_i := 0; vl_i < vl_statCount ; vl_i := vl_i+1 )
      {
        // Check in TC scope
        var integer vl_statHIdxInEntityInfo := -1
        if( f_EPTF_str2int_HashMap_Find(
            v_LGenBase_trafficCases[vl_tcIdx].TCStatHandlerNamesHash,
            v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name,
            vl_statHIdxInEntityInfo)) {
          var integer vl_prevSibling := v_LGenBase_trafficCases[vl_tcIdx].statHandlerStatList[vl_statHIdxInEntityInfo].siblingFsmIdx
          var integer vl_prefFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSibling].fsmTypeIdx;
          f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The statistics with FSM scope "&
            v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name&
            " of the FSM "&
            v_LGenBase_fsmTables[pl_tableIdx].name&
            " in TC "&
            v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
            " already defined in FSM "&
            v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
            " with TC scope."
          );
        }
        // Check in Sibling scope:
        if( f_EPTF_str2int_HashMap_Find(
            v_LGenBase_trafficCases[vl_tcIdx].SiblingFSMStatHandlerNamesHash,
            v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name,
            vl_statHIdxInEntityInfo)) {
          var integer vl_prevSibling := v_LGenBase_trafficCases[vl_tcIdx].siblingStatHandlerStatList[vl_statHIdxInEntityInfo].siblingFsmIdx
          var integer vl_prefFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSibling].fsmTypeIdx;
          f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The statistics with FSM scope "&
            v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name&
            " of the FSM "&
            v_LGenBase_fsmTables[pl_tableIdx].name&
            " in TC "&
            v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
            " already defined in FSM "&
            v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
            " with SiblingFSM scope."
          );
        }
        
        for ( var integer vl_eIdx := 0; vl_eIdx < vl_eCount ; vl_eIdx := vl_eIdx+1 ){
          var integer vl_entity := vl_eFirst + vl_eIdx
          var integer vl_newFsmCtxIdx:= vl_newIdxs[vl_eIdx] 
          var charstring vl_statName := f_EPTF_LGenBase_varNameOfFSMVar(vl_entity, vl_newFsmCtxIdx, 
            v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name);
          if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
            f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Declaring statistic "&vl_statName&" with statMethod: "&
              log2str(v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].statMethod))
          }
          //The statistics declared in FSM-s are always collected in the LGenBase itself
          var boolean vl_ok := f_EPTF_StatHandlerClient_declareStat(
            vl_statName, 
            v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].statMethod, 
            v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].statResetValue, 
            self);
          f_EPTF_Base_assert(%definitionId&": The declaration of the statistics "&vl_statName&" failed.", vl_ok)
        }
        f_EPTF_str2int_HashMap_Insert(
          v_LGenBase_trafficCases[vl_tcIdx].FSMStatHandlerNamesHash,
          v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name,
          pl_tableIdx)
      }
      
      if(ischosen(pl_params.tcData)){
        
        //////////////////////////////////////////////////////////////////////
        //Declaring FSM (SH)statistics with Sibling scope
        //////////////////////////////////////////////////////////////////////
        
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
          f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Processing TC statistic declaration: "&
            log2str(v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM]))
        }
        vl_statCount := sizeof(v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM]);
        for ( var integer vl_i := 0; vl_i < vl_statCount ; vl_i := vl_i+1 )
        {
          // Check FSM scope
          var integer vl_prefFSMTableTypeIdx;
          if( f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].FSMStatHandlerNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name,
              vl_prefFSMTableTypeIdx)) {
            f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The statistics with SiblingFSM scope "&
              v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name&
              " of the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
              " with FSM scope."
            );
          }
          
          // Check in TC scope
          var integer vl_statHIdxInEntityInfo := -1
          if( f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].TCStatHandlerNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name,
              vl_statHIdxInEntityInfo)) {
            var integer vl_prevSibling := v_LGenBase_trafficCases[vl_tcIdx].statHandlerStatList[vl_statHIdxInEntityInfo].siblingFsmIdx
            vl_prefFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSibling].fsmTypeIdx;
            f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The statistics with SiblingFSM scope "&
              v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name&
              " of the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
              " with TC scope."
            );
          }
          
          var integer vl_statHandlerIdxInTc := -1
          
          if( f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].SiblingFSMStatHandlerNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name,
              vl_statHandlerIdxInTc) ){
            //Check previous declaration
            var integer vl_prevSibling := v_LGenBase_trafficCases[vl_tcIdx].siblingStatHandlerStatList[vl_statHandlerIdxInTc].siblingFsmIdx
            var integer vl_idxInFsm := v_LGenBase_trafficCases[vl_tcIdx].siblingStatHandlerStatList[vl_statHandlerIdxInTc].idxInFsm;
            //Check method
            vl_prefFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSibling].fsmTypeIdx;
            if(v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].statMethod !=
              v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_idxInFsm].statMethod){
              f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The statistics with SiblingFSM scope "&
                v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name&
                " of the FSM "&
                v_LGenBase_fsmTables[pl_tableIdx].name&
                " in TC "&
                v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                " already defined in FSM "&
                v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
                " with different method."
              );
            }
            //Check reset value
            if(v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].statResetValue !=
              v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_idxInFsm].statResetValue){
              f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The statistics with SiblingFSM scope "&
                v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name&
                " of the FSM "&
                v_LGenBase_fsmTables[pl_tableIdx].name&
                " in TC "&
                v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                " already defined in FSM "&
                v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
                " with different reset value."
              );
            }
            //Check provider list
            if(not match(v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].providerDeclarators,
                v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_idxInFsm].providerDeclarators)){
              f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The statistics with SiblingFSM scope "&
                v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name&
                " of the FSM "&
                v_LGenBase_fsmTables[pl_tableIdx].name&
                " in TC "&
                v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                " already defined in FSM "&
                v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
                " with different provider list."
              );
            }
          } else {
            
            for ( var integer vl_eRelIdx := 0; vl_eRelIdx < sizeof(v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList) ; vl_eRelIdx := vl_eRelIdx+1 ){
              var charstring vl_statName := f_EPTF_LGenBase_varNameOfSiblingFSMsVar(vl_tcIdx,vl_eRelIdx,
                v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name);
              //var boolean vl_mustBeRegistered := false 
              vl_statHandlerIdxInTc := sizeof(v_LGenBase_trafficCases[vl_tcIdx].siblingStatHandlerStatList); 
              f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Declaring statistic "&vl_statName&" with statMethod: "&
                log2str(v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].statMethod))
              //The statistics declared in FSM-s are always collected in the LGenBase itself
              var boolean vl_ok := f_EPTF_StatHandlerClient_declareStat(
                vl_statName, 
                v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].statMethod, 
                v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].statResetValue, 
                self);
              f_EPTF_Base_assert(%definitionId&": The declaration of the statistics "&vl_statName&" failed.", vl_ok)
            }
            
            f_EPTF_str2int_HashMap_Insert(
              v_LGenBase_trafficCases[vl_tcIdx].SiblingFSMStatHandlerNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name,
              vl_statHandlerIdxInTc)
            
            v_LGenBase_trafficCases[vl_tcIdx].siblingStatHandlerStatList[vl_statHandlerIdxInTc].statName := 
            v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].name;
            v_LGenBase_trafficCases[vl_tcIdx].siblingStatHandlerStatList[vl_statHandlerIdxInTc].siblingFsmIdx := vl_siblingIdx;
            v_LGenBase_trafficCases[vl_tcIdx].siblingStatHandlerStatList[vl_statHandlerIdxInTc].idxInFsm := vl_i;
          }
          v_LGenBase_trafficCases[vl_tcIdx].siblingFsmStatHandlerIdxInFsm[vl_siblingIdx][vl_i] := vl_statHandlerIdxInTc;
        }
        
        ///////////////////////////////////////////////////////
        //Declaring FSM (SH)statistics with TC scope
        ///////////////////////////////////////////////////////
        
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
          f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Processing TC statistic declaration: "&
            log2str(v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC])&
            " for TC "&v_LGenBase_trafficCases[vl_tcIdx].uniqueName)
        }
        vl_statCount := sizeof(v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC]);
        for ( var integer vl_i := 0; vl_i < vl_statCount ; vl_i := vl_i+1 )
        {
          // Check FSM scope
          var integer vl_prefFSMTableTypeIdx;
          if( f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].FSMStatHandlerNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name,
              vl_prefFSMTableTypeIdx)) {
            f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The statistics with TC scope "&
              v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name&
              " of the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
              " with FSM scope."
            );
          }
          
          // Check in Sibling scope
          var integer vl_statHIdxInEntityInfo := -1
          if( f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].SiblingFSMStatHandlerNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name,
              vl_statHIdxInEntityInfo)) {
            var integer vl_prevSibling := v_LGenBase_trafficCases[vl_tcIdx].siblingStatHandlerStatList[vl_statHIdxInEntityInfo].siblingFsmIdx
            vl_prefFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSibling].fsmTypeIdx;
            f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The statistics with TC scope "&
              v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name&
              " of the FSM "&
              v_LGenBase_fsmTables[pl_tableIdx].name&
              " in TC "&
              v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              " already defined in FSM "&
              v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
              " with SiblingFSM scope."
            );
          }
          
          var integer vl_statHandlerIdxInTc := -1
          
          if( f_EPTF_str2int_HashMap_Find(
              v_LGenBase_trafficCases[vl_tcIdx].TCStatHandlerNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name,
              vl_statHandlerIdxInTc) ){
            // Check previous declaration
            var integer vl_prevSibling := v_LGenBase_trafficCases[vl_tcIdx].statHandlerStatList[vl_statHandlerIdxInTc].siblingFsmIdx
            var integer vl_idxInFsm := v_LGenBase_trafficCases[vl_tcIdx].statHandlerStatList[vl_statHandlerIdxInTc].idxInFsm;
            //Check method
            vl_prefFSMTableTypeIdx := v_LGenBase_trafficCases[vl_tcIdx].fsmList[vl_prevSibling].fsmTypeIdx;
            if(v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].statMethod !=
              v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_idxInFsm].statMethod){
              f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The statistics with TC scope "&
                v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name&
                " of the FSM "&
                v_LGenBase_fsmTables[pl_tableIdx].name&
                " in TC "&
                v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                " already defined in FSM "&
                v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
                " with different method."
              );
            }
            //Check reset value
            if(v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].statResetValue !=
              v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_idxInFsm].statResetValue){
              f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The statistics with SiblingFSM scope "&
                v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name&
                " of the FSM "&
                v_LGenBase_fsmTables[pl_tableIdx].name&
                " in TC "&
                v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                " already defined in FSM "&
                v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
                " with different reset value."
              );
            }
            //Check provider list
            if(not match(v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].providerDeclarators,
                v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_idxInFsm].providerDeclarators)){
              f_EPTF_LGenBase_loggingError(%definitionId&": Cannot activate FSM: The statistics with SiblingFSM scope "&
                v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name&
                " of the FSM "&
                v_LGenBase_fsmTables[pl_tableIdx].name&
                " in TC "&
                v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
                " already defined in FSM "&
                v_LGenBase_fsmTables[vl_prefFSMTableTypeIdx].name&
                " with different provider list."
              );
            }
          } else {
            
            var charstring vl_statName := f_EPTF_LGenBase_varNameOfTCVar(vl_tcIdx,
              v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name);
            //var boolean vl_mustBeRegistered := false 
            vl_statHandlerIdxInTc := sizeof(v_LGenBase_trafficCases[vl_tcIdx].statHandlerStatList); 
            f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Declaring statistic "&vl_statName&" with statMethod: "&
              log2str(v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].statMethod))
            //The statistics declared in FSM-s are always collected in the LGenBase itself
            var boolean vl_ok := f_EPTF_StatHandlerClient_declareStat(
              vl_statName, 
              v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].statMethod, 
              v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].statResetValue, 
              self);
            f_EPTF_Base_assert(%definitionId&": The declaration of the statistics "&vl_statName&" failed.", vl_ok)
            
            f_EPTF_str2int_HashMap_Insert(
              v_LGenBase_trafficCases[vl_tcIdx].TCStatHandlerNamesHash,
              v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name,
              vl_statHandlerIdxInTc)
            
            v_LGenBase_trafficCases[vl_tcIdx].statHandlerStatList[vl_statHandlerIdxInTc].statName := v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].name;
            v_LGenBase_trafficCases[vl_tcIdx].statHandlerStatList[vl_statHandlerIdxInTc].siblingFsmIdx := vl_siblingIdx;
            v_LGenBase_trafficCases[vl_tcIdx].statHandlerStatList[vl_statHandlerIdxInTc].idxInFsm := vl_i;
          }
          v_LGenBase_trafficCases[vl_tcIdx].statHandlerIdxInFsm[vl_siblingIdx][vl_i] := vl_statHandlerIdxInTc;
        }
      }
      //Register FSM stathandler providers
      for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeFSM]) ; vl_i := vl_i+1 )
      {
        for ( var integer vl_eIdx := 0; vl_eIdx < vl_eCount ; vl_eIdx := vl_eIdx+1 ){
          var integer vl_entity := vl_eFirst + vl_eIdx
          var integer vl_newFsmCtxIdx:= vl_newIdxs[vl_eIdx]
          var charstring vl_statName := f_EPTF_LGenBase_varNameOfFSMVar(vl_entity, vl_newFsmCtxIdx, 
            v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name);
          if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
            f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Registering statistic providers for statHandler "&vl_statName)
          }
          f_EPTF_LGenBase_registerStatHandlerProviders(
            v_LGenBase_fsmTables[pl_tableIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].providers, 
            v_LGenBase_fsmTables[pl_tableIdx], 
            pl_tableIdx, 
            vl_tcIdx, 
            vl_statName,
            c_EPTF_LGenBase_fsmObjectScopeFSM,
            vl_newFsmCtxIdx,
            vl_eIdx ) // TODO ide a siblingIdx kene de itt 
        }
      }
      //Process table
      if(ischosen(pl_params.entityData)){
        //Activates for a single entity
        if (0<sizeof(v_LGenBase_fsmTables[pl_tableIdx].siblingListenerRowList)) {
          f_EPTF_LGenBase_loggingError(%definitionId&": The FSM "&v_LGenBase_fsmTables[pl_tableIdx].name&
            " refers to a sibling, but it is activated inside of a traffic case");
        }
        for (var integer vl_event:=0;vl_event<sizeof(v_LGenBase_fsmTables[pl_tableIdx].eventXref); vl_event:=vl_event+1) {
          var integer vl_row := v_LGenBase_fsmTables[pl_tableIdx].eventXref[vl_event].rowIdx
          var integer bIdx:=v_LGenBase_fsmTables[pl_tableIdx].eventXref[vl_event].event2Listen.bIdx;
          var integer iIdx:=v_LGenBase_fsmTables[pl_tableIdx].eventXref[vl_event].event2Listen.iIdx;
          //Activates for a single entity
          for ( var integer vl_eIdx := 0; vl_eIdx < vl_eCount ; vl_eIdx := vl_eIdx+1 ){
            var integer vl_entity := vl_eFirst + vl_eIdx
            var integer vl_newFsmCtxIdx:= vl_newIdxs[vl_eIdx]
            select (v_LGenBase_fsmTables[pl_tableIdx].eventXref[vl_event].event2Listen.eventType) {
              case (general) {
                v_LGenBase_entities[vl_entity].fsmCtxList[vl_newFsmCtxIdx].rowListeners[vl_event]:={
                  f_EPTF_LGenBase_addGeneralEventListener(
                    bIdx,iIdx, 
                    refers(f_EPTF_LGenBase_tableListenerWrapper),
                    {vl_entity,vl_newFsmCtxIdx,vl_row})}}
              case (entity){
                v_LGenBase_entities[vl_entity].fsmCtxList[vl_newFsmCtxIdx].rowListeners[vl_event]:={
                  f_EPTF_LGenBase_addEntityEventListener2(
                    bIdx,iIdx,vl_entity, 
                    refers(f_EPTF_LGenBase_tableListenerWrapper),
                    {vl_entity,vl_newFsmCtxIdx,vl_row})}}
              case (fsm) {
                v_LGenBase_entities[vl_entity].fsmCtxList[vl_newFsmCtxIdx].rowListeners[vl_event]:= {omit};
              }
            }
          }
        }
      }else{
        var EPTF_LGenBase_InternalFSMEvent2RowXrefList vl_siblingEventXref := {};
        f_EPTF_LGenBase_processSiblingListeners(vl_tcIdx,pl_tableIdx,v_LGenBase_fsmTables[pl_tableIdx],vl_siblingIdx,vl_siblingEventXref);
        f_EPTF_LGenBase_activateListenersInFsm(
          vl_tcIdx,
          pl_tableIdx,
          v_LGenBase_fsmTables[pl_tableIdx].eventXref,
          vl_eFirst,
          vl_eCount,
          vl_siblingIdx,
          vl_newIdxs)
        f_EPTF_LGenBase_activateListenersInFsm(
          vl_tcIdx,
          pl_tableIdx,
          vl_siblingEventXref,
          vl_eFirst,
          vl_eCount,
          vl_siblingIdx,
          vl_newIdxs)
      }
      if(ischosen(pl_params.tcData)){
        return 0
      }else{
        return vl_newIdxs[0];
      }
    }
    
    private function f_EPTF_LGenBase_getFsmTypeOfSiblingFsm(
      in integer pl_tcIdx,
      in charstring pl_name)
    runs on EPTF_LGenBase_Private_CT return charstring
    {
      for ( var integer i := 0; i < sizeof(v_LGenBase_trafficCases[pl_tcIdx].fsmList) ; i := i+1 )
      {
        if (v_LGenBase_trafficCases[pl_tcIdx].fsmList[i].siblingName == pl_name) {
          return v_LGenBase_fsmTables[v_LGenBase_trafficCases[pl_tcIdx].fsmList[i].fsmTypeIdx].name;
        }
      }
      return ""; // not found
    }
    
    private function f_EPTF_LGenBase_activateListenersInFsm(
      in integer pl_tcIdx,
      in integer pl_tableIdx,
      in EPTF_LGenBase_InternalFSMEvent2RowXrefList pl_eventXref,
      in integer pl_eFirst,
      in integer pl_eCount,
      in integer pl_siblingIdx,
      in EPTF_IntegerList pl_newIdxs)
    runs on EPTF_LGenBase_Private_CT
    {
      for (var integer vl_event:=0;vl_event<sizeof(pl_eventXref); vl_event:=vl_event+1) {
        var integer vl_row := pl_eventXref[vl_event].rowIdx
        var integer bIdx:=pl_eventXref[vl_event].event2Listen.bIdx;
        var integer iIdx:=pl_eventXref[vl_event].event2Listen.iIdx;
        var integer vl_siblingRef := pl_eventXref[vl_event].siblingRef;
        select (pl_eventXref[vl_event].event2Listen.eventType) {
          case (general) {
            f_EPTF_LGenBase_loggingDebugConfig("Activating general listener for tc "&log2str(pl_tcIdx)&
              "\nEvent: "&f_EPTF_LGenBase_iIdx2Str(bIdx, iIdx)&
              "\nFSM Table: "&v_LGenBase_fsmTables[pl_tableIdx].name&
              "\nRow: "&log2str(vl_row)&
              "\nSibling ref: "&log2str(vl_siblingRef))
            var integer vl_idx := f_EPTF_FBQ_getOrCreateFreeSlot(v_LGenBase_genericTcListeners[bIdx][iIdx])
            f_EPTF_FBQ_setQueueDidx(vl_idx, {pl_tcIdx,pl_siblingIdx,vl_row,vl_siblingRef}, v_LGenBase_genericTcListeners[bIdx][iIdx])
            f_EPTF_FBQ_moveFromFreeToBusyTail(vl_idx, v_LGenBase_genericTcListeners[bIdx][iIdx])
          }
          case (entity){
            f_EPTF_LGenBase_loggingDebugConfig("Activating entity listener for tc "&log2str(pl_tcIdx)&
              "\nEvent: "&f_EPTF_LGenBase_iIdx2Str(bIdx, iIdx)&
              "\nFSM Table: "&v_LGenBase_fsmTables[pl_tableIdx].name&
              "\nRow: "&log2str(vl_row)&
              "\nSibling ref: "&log2str(vl_siblingRef))
            var integer vl_idx := f_EPTF_FBQ_getOrCreateFreeSlot(v_LGenBase_entityTcListeners[bIdx][iIdx])
            f_EPTF_FBQ_setQueueDidx(vl_idx, {pl_tcIdx,pl_siblingIdx,vl_row,vl_siblingRef}, v_LGenBase_entityTcListeners[bIdx][iIdx])
            f_EPTF_FBQ_moveFromFreeToBusyTail(vl_idx, v_LGenBase_entityTcListeners[bIdx][iIdx])
          }
          case (fsm) {
            f_EPTF_LGenBase_loggingDebugConfig("FSM listener for tc "&log2str(pl_tcIdx)&
              "\nEvent: "&f_EPTF_LGenBase_iIdx2Str(bIdx, iIdx)&
              "\nFSM Table: "&v_LGenBase_fsmTables[pl_tableIdx].name&
              "\nRow: "&log2str(vl_row))
            for ( var integer vl_eIdx := 0; vl_eIdx < pl_eCount ; vl_eIdx := vl_eIdx+1 ){
              var integer vl_entity := pl_eFirst + vl_eIdx
              var integer vl_newFsmCtxIdx:= pl_newIdxs[vl_eIdx]
              v_LGenBase_entities[vl_entity].fsmCtxList[vl_newFsmCtxIdx].rowListeners[vl_event]:= {omit};
            }
          }
        }
      }
    }
    //vl_eventXref
    private function f_EPTF_LGenBase_processSiblingListeners(
      in integer pl_tcIdx,
      in integer pl_tableIdx,
      inout EPTF_LGenBase_InternalFsmTable pl_fsm,
      in integer pl_siblingIdx,
      inout EPTF_LGenBase_InternalFSMEvent2RowXrefList pl_siblingEventXref)
    runs on EPTF_LGenBase_Private_CT
    {
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
        f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId,": ",
            "FSM: ",pl_fsm.name," Sibling listener rows: ",
            pl_fsm.siblingListenerRowList
          ))
      }
      for (var integer vl_row:=0; vl_row < sizeof(pl_fsm.siblingListenerRowList); vl_row := vl_row+1) {
        select( true ){
          case ( ischosen(pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.singleEventFromSibling) ){
            var charstring vl_fsmType := f_EPTF_LGenBase_getFsmTypeOfSiblingFsm(pl_tcIdx,pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.singleEventFromSibling.siblingName);
            if("" == vl_fsmType){
              f_EPTF_LGenBase_loggingError(%definitionId&": Sibling FSM "&pl_fsm.name&
                " of traffic case "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName&
                " refers to a sibling "&
                pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.singleEventFromSibling.siblingName&
                " in row#"&log2str(pl_fsm.siblingListenerRowList[vl_row].row)&
                " but it is not present in the TC."
              );
            }
            var integer vl_siblingRef :=
            f_EPTF_LGenBase_addSiblingRef(pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.singleEventFromSibling.siblingName,pl_fsm);
            if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
              f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId,": ",
                  "\nTC: ",v_LGenBase_trafficCases[pl_tcIdx].uniqueName,
                  "\nFSM: ",pl_fsm.name,
                  "\nSibling reference list of FSM: ",pl_fsm.referredFsmList,
                  "\nListener row: ",pl_fsm.siblingListenerRowList[vl_row],
                  "\nSibling reference: ",vl_siblingRef,
                  "\nFSM type of referred sibling: ",vl_fsmType
                ))
            }
            f_EPTF_LGenBase_appendEventToList(
              f_EPTF_LGenBase_convertEvent(
                vl_fsmType,
                pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.singleEventFromSibling.iName,
                pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.singleEventFromSibling.eventType,
                pl_fsm, pl_fsm.siblingListenerRowList[vl_row].row),
              pl_fsm.siblingListenerRowList[vl_row].row,
              sizeof(pl_siblingEventXref),
              pl_siblingEventXref,
              vl_siblingRef)
          }
          case ( ischosen(pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventListFromSibling) ){
            var charstring vl_fsmType := f_EPTF_LGenBase_getFsmTypeOfSiblingFsm(pl_tcIdx,pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventListFromSibling.siblingName);
            if("" == vl_fsmType){
              f_EPTF_LGenBase_loggingError(%definitionId&": Sibling FSM "&pl_fsm.name&
                " of traffic case "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName&
                " refers to a sibling "&
                pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventListFromSibling.siblingName&
                " in row#"&log2str(pl_fsm.siblingListenerRowList[vl_row].row)&
                " but it is not present in the TC."
              );
            }
            var integer vl_siblingRef :=
            f_EPTF_LGenBase_addSiblingRef(pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventListFromSibling.siblingName,pl_fsm);
            var integer vl_xrefSize := sizeof(pl_siblingEventXref)
            if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
              f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId,": ",
                  "\nTC: ",v_LGenBase_trafficCases[pl_tcIdx].uniqueName,
                  "\nFSM: ",pl_fsm.name,
                  "\nSibling reference list of FSM: ",pl_fsm.referredFsmList,
                  "\nListener row: ",pl_fsm.siblingListenerRowList[vl_row],
                  "\nSibling reference: ",vl_siblingRef,
                  "\nFSM type of referred sibling: ",vl_fsmType
                ))
            }
            for ( var integer vl_i := 0; vl_i < sizeof(pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventListFromSibling.iNameList) ; vl_i := vl_i+1 ){
              f_EPTF_LGenBase_appendEventToList(
                f_EPTF_LGenBase_convertEvent(
                  vl_fsmType,
                  pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventListFromSibling.iNameList[vl_i],
                  pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventListFromSibling.eventType,
                  pl_fsm, pl_fsm.siblingListenerRowList[vl_row].row),
                pl_fsm.siblingListenerRowList[vl_row].row,
                vl_xrefSize,
                pl_siblingEventXref,
                vl_siblingRef)
            }
          }
          case ( ischosen(pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventRangeFromSibling) ){
            var charstring vl_fsmType := f_EPTF_LGenBase_getFsmTypeOfSiblingFsm(pl_tcIdx,pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventRangeFromSibling.siblingName);
            if("" == vl_fsmType){
              f_EPTF_LGenBase_loggingError(%definitionId&": Sibling FSM "&pl_fsm.name&
                " of traffic case "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName&
                " refers to a sibling "&
                pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventRangeFromSibling.siblingName&
                " in row#"&log2str(pl_fsm.siblingListenerRowList[vl_row].row)&
                " but it is not present in the TC."
              );
            }
            var integer vl_siblingRef :=
            f_EPTF_LGenBase_addSiblingRef(pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventRangeFromSibling.siblingName,pl_fsm);
            var integer vl_xrefSize := sizeof(pl_siblingEventXref)
            // check limits of event interval
            var EPTF_LGenBase_EventDescriptor vl_low := f_EPTF_LGenBase_convertEvent(
              vl_fsmType,
              pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventRangeFromSibling.iNameMin,
              pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventRangeFromSibling.eventType, 
              pl_fsm,
              pl_fsm.siblingListenerRowList[vl_row].row
            ); 
            var EPTF_LGenBase_EventDescriptor vl_hi := f_EPTF_LGenBase_convertEvent(
              pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventRangeFromSibling.siblingName,
              pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventRangeFromSibling.iNameMax,
              pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventRangeFromSibling.eventType, 
              pl_fsm,
              pl_fsm.siblingListenerRowList[vl_row].row
            ); 
            // check if range is valid
            if(vl_low.iIdx > vl_hi.iIdx){
              f_EPTF_LGenBase_loggingError(%definitionId&
                ": The declared event input names <" &
                pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventRangeFromSibling.iNameMin &", " &
                pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling.eventRangeFromSibling.iNameMax &
                "> don't specify a valid range!")
            }
            // iterate through the event range, create internal events and put them to output list
            if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
              f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId,": ",
                  "\nTC: ",v_LGenBase_trafficCases[pl_tcIdx].uniqueName,
                  "\nFSM: ",pl_fsm.name,
                  "\nSibling reference list of FSM: ",pl_fsm.referredFsmList,
                  "\nListener row: ",pl_fsm.siblingListenerRowList[vl_row],
                  "\nSibling reference: ",vl_siblingRef,
                  "\nFSM type of referred sibling: ",vl_fsmType
                ))
            }
            for (var integer j:= vl_low.iIdx; j<=vl_hi.iIdx; j:=j+1) {
              f_EPTF_LGenBase_appendEventToList(
                {vl_low.bIdx, j, vl_low.eventType},
                pl_fsm.siblingListenerRowList[vl_row].row,
                vl_xrefSize,
                pl_siblingEventXref, 
                vl_siblingRef);
            }
          }
          case else{
            f_EPTF_LGenBase_loggingError(%definitionId&
              ": Invalid EPTF_LGenBase_EventsFromSibling type: "&
              log2str( pl_fsm.siblingListenerRowList[vl_row].eventsFromSibling )&
              " in FSM "&pl_fsm.name);
          }
        }
      }
      f_EPTF_LGenBase_fillEventsHasmaps(pl_tableIdx,pl_siblingEventXref,pl_tcIdx,pl_siblingIdx);
    }
    
    
    private function f_EPTF_LGenBase_fsmVarDebugPostproc(
      in integer pl_idx, 
      in EPTF_IntegerList pl_argList) 
    runs on EPTF_LGenBase_Private_CT{
      var charstring vl_varName := f_EPTF_Var_getName(pl_idx)
      var EPTF_Var_DirectContent vl_content
      f_EPTF_Var_getContent(pl_idx, vl_content)
      f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": The content of the FSM variable "&
        vl_varName&" has been changed to "&log2str(vl_content))
    }
    
    type record of EPTF_CharstringList EPTF_CharstringListArray
    friend function f_EPTF_LGenBase_registerStatHandlerProviders(
      in EPTF_LGenBase_FsmStatProviderDescriptorList pl_providers,
      in EPTF_LGenBase_InternalFsmTable plTable,
      in integer pl_tIdx,
      in integer pl_tcIdx,
      in charstring pl_statName,
      in integer pl_statScope,
      in integer pl_statFSMIdx,  // statHandler's newFsmCtxIdx, it is used widely, it should be given each and every call.
      in integer pl_statRelEIdx := -1 // statHandler's entityIdx, only used at FSM and siblingFSM scope StatHandler, not in tc scope
    )
    runs on EPTF_LGenBase_Private_CT{ 
      var integer vl_providerCount := sizeof(pl_providers);
      var integer vl_eCount := v_LGenBase_entityGroups[v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref].eCount
      var integer vl_eOffset := v_LGenBase_entityGroups[v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref].eOffset
      var EPTF_CharstringListArray vl_varNames := {}
      var EPTF_CharstringList vl_statHandlerIdList := {}
      var EPTF_IntegerList vl_statMeasIdList := {}
      select(true) {
        //FSM scope statHandler
        case(c_EPTF_LGenBase_fsmObjectScopeFSM == pl_statScope) {
          for ( var integer vl_provider := 0; vl_provider < vl_providerCount ; vl_provider := vl_provider+1 ){
            select( true ){
              //FSM scope statHandler with variable provider 
              case ( ischosen(pl_providers[vl_provider].varXrefList) ){
                //Variable providers for FSM scope statHandler
                for ( var integer vl_var := 0; vl_var < sizeof(pl_providers[vl_provider].varXrefList) ; vl_var := vl_var+1 ){
                  var integer vl_varXRef := pl_providers[vl_provider].varXrefList[vl_var];
                  var EPTF_LGenBase_FsmObjectScope vl_varScope := plTable.varXRefs[vl_varXRef].scope;
                  
                  var integer vl_idxInScope := plTable.varXRefs[vl_varXRef].idxInScope;
                  var charstring vl_varName := v_LGenBase_fsmTables[pl_tIdx].varListArray[vl_varScope][vl_idxInScope].name
                  select( vl_varScope ){
                    // statHandler : FSM scope, provider : FSM scope variable
                    case ( c_EPTF_LGenBase_fsmObjectScopeFSM ){
                      vl_varNames[0][vl_var] := f_EPTF_LGenBase_varNameOfFSMVar( vl_eOffset+pl_statRelEIdx, pl_statFSMIdx, vl_varName);
                    }
                    // statHandler : FSM scope, provider : siblingFSM scope variable
                    case ( c_EPTF_LGenBase_fsmObjectScopeSiblingFSM ){
                      vl_varNames[0][vl_var] := f_EPTF_LGenBase_varNameOfSiblingFSMsVar( pl_tcIdx, pl_statRelEIdx, vl_varName);
                    }
                    // statHandler : FSM scope, provider : TC scope variable 
                    case ( c_EPTF_LGenBase_fsmObjectScopeTC ){
                      vl_varNames[0][vl_var] := f_EPTF_LGenBase_varNameOfTCVar( pl_tcIdx, vl_varName);
                    }
                    // statHandler : FSM scope, provider : not known scope variable
                    case else
                    {
                      f_EPTF_LGenBase_loggingError(%definitionId&": Invalid scope of provider: "&log2str(vl_varScope)&", in case of FSM scope stathandler");
                    }
                  }
                }
              }
              //FSM scope statHandler with StatMeas providers
              case ( ischosen(pl_providers[vl_provider].statMeasXref) ){
                var integer vl_statMeasXRef := pl_providers[vl_provider].statMeasXref;
                var EPTF_LGenBase_FsmObjectScope vl_varScope := v_LGenBase_fsmTables[pl_tIdx].statMeasXRefs[vl_statMeasXRef].scope
                var integer vl_idxInScope := v_LGenBase_fsmTables[pl_tIdx].statMeasXRefs[vl_statMeasXRef].idxInScope
                var charstring vl_varName := v_LGenBase_fsmTables[pl_tIdx].statMeasStatListArray[vl_varScope][vl_idxInScope].name
                
                select( vl_varScope ){
                  //FSM scope statHandler with FSM scope StatMeas provider
                  case ( c_EPTF_LGenBase_fsmObjectScopeFSM ){
                    vl_statMeasIdList[sizeof(vl_statMeasIdList)] := v_LGenBase_entities[vl_eOffset+pl_statRelEIdx].fsmCtxList[pl_statFSMIdx].statMeasStatList[vl_idxInScope]
                  }
                  //FSM scope statHandler with siblingFSM scope StatMeas provider
                  case ( c_EPTF_LGenBase_fsmObjectScopeSiblingFSM ){
                    vl_statMeasIdList[sizeof(vl_statMeasIdList)] := f_EPTF_LGenBase_fsmStatMeasIdOfSibling(pl_tcIdx, vl_eOffset+pl_statRelEIdx, vl_varName)
                  }
                  //FSM scope statHandler with TC scope StatMeas provider
                  case ( c_EPTF_LGenBase_fsmObjectScopeTC ){
                    vl_statMeasIdList[sizeof(vl_statMeasIdList)] := v_LGenBase_trafficCases[pl_tcIdx].statMeasStatList[vl_idxInScope].statId
                  }
                  //FSM scope statHandler with StatMeas provider with a scope different from known scopes
                  case else{
                    f_EPTF_LGenBase_loggingError(%definitionId&": Invalid scope of provider: "&log2str(vl_varScope)&", in case of FSM scope stathandler");
                  }
                }
              }
              //FSM scope StatHandler with StatHandler providers
              case ( ischosen(pl_providers[vl_provider].statHandlerXref) ){
                var integer vl_statHandlerXref := pl_providers[vl_provider].statHandlerXref;
                var EPTF_LGenBase_FsmObjectScope vl_varScope := v_LGenBase_fsmTables[pl_tIdx].statisticXRefs[vl_statHandlerXref].scope
                var integer vl_idxInScope := v_LGenBase_fsmTables[pl_tIdx].statisticXRefs[vl_statHandlerXref].idxInScope
                
                var charstring vl_statHandlerName := v_LGenBase_fsmTables[pl_tIdx].statisticListArray[vl_varScope][vl_idxInScope].name;
                select( vl_varScope ){
                  //FSM scope StatHandler with fsm scope StatHandler providers
                  case ( c_EPTF_LGenBase_fsmObjectScopeFSM ){
                    vl_statHandlerIdList[sizeof(vl_statHandlerIdList)] := f_EPTF_LGenBase_varNameOfFSMVar(
                      vl_eOffset+pl_statRelEIdx, 
                      pl_statFSMIdx,
                      vl_statHandlerName)
                  }
                  //FSM scope StatHandler with StatHandler provider with siblingFsm scope  
                  case ( c_EPTF_LGenBase_fsmObjectScopeSiblingFSM ){                    
                    vl_statHandlerIdList[sizeof(vl_statHandlerIdList)] := f_EPTF_LGenBase_varNameOfSiblingFSMsVar(
                      pl_tcIdx, pl_statRelEIdx, 
                      vl_statHandlerName)
                  }
                  //FSM scope StatHandler with StatHandler provider with TC scope
                  case ( c_EPTF_LGenBase_fsmObjectScopeTC ){
                    vl_statHandlerIdList[sizeof(vl_statHandlerIdList)] := f_EPTF_LGenBase_varNameOfTCVar(
                      pl_tcIdx, 
                      vl_statHandlerName)
                  }
                  case else{
                    f_EPTF_LGenBase_loggingError(%definitionId&": Invalid scope of provider: "&log2str(vl_varScope)&", in case of FSM scope stathandler");
                  }
                }
              }
              case else{
                //A bit paranoia
                f_EPTF_LGenBase_loggingError(%definitionId&": Invalid provider type: "&log2str(pl_providers[vl_provider]));
              }
            }
          }
        }
        
        // siblingFsm scope statHandler
        case(c_EPTF_LGenBase_fsmObjectScopeSiblingFSM == pl_statScope) {
          for ( var integer vl_provider := 0; vl_provider < vl_providerCount ; vl_provider := vl_provider+1 ){
            select( true ){
              case ( ischosen(pl_providers[vl_provider].varXrefList) ){
                //siblingFsm scope statHandler - Variable providers
                for ( var integer vl_var := 0; vl_var < sizeof(pl_providers[vl_provider].varXrefList) ; vl_var := vl_var+1 ){
                  var integer vl_varXRef := pl_providers[vl_provider].varXrefList[vl_var];
                  var EPTF_LGenBase_FsmObjectScope vl_varScope := plTable.varXRefs[vl_varXRef].scope;
                  var integer vl_idxInScope := plTable.varXRefs[vl_varXRef].idxInScope;
                  var charstring vl_varName := v_LGenBase_fsmTables[pl_tIdx].varListArray[vl_varScope][vl_idxInScope].name
                  select( vl_varScope ){
                    // statHandler : siblingFsmscope, provider : Fsm scope variable
                    case ( c_EPTF_LGenBase_fsmObjectScopeFSM ){
                      for(var integer vl_FSMs := 0; vl_FSMs < sizeof(v_LGenBase_trafficCases[pl_tcIdx].fsmList); vl_FSMs := vl_FSMs + 1 )
                      {
                        var integer v_ConcFSM := v_LGenBase_trafficCases[pl_tcIdx].fsmList[vl_FSMs].fsmTypeIdx;
                        for(var integer vl_iScope := 0; vl_iScope < sizeof(v_LGenBase_fsmTables[v_ConcFSM].varListArray[vl_varScope]); vl_iScope := vl_iScope + 1 )
                        {
                          if (vl_varName == v_LGenBase_fsmTables[v_ConcFSM].varListArray[vl_varScope][vl_iScope].name)
                          {
                            vl_varNames[vl_FSMs][vl_var] := f_EPTF_LGenBase_varNameOfFSMVar( vl_eOffset+pl_statRelEIdx, vl_FSMs, vl_varName);
                          }
                        }
                      }
                    }
                    // statHandler : siblingFsmscope, provider : siblingFsm scope variable
                    case ( c_EPTF_LGenBase_fsmObjectScopeSiblingFSM ){
                      vl_varNames[0][vl_var] := f_EPTF_LGenBase_varNameOfSiblingFSMsVar( pl_tcIdx, pl_statRelEIdx, vl_varName);
                    }
                    // statHandler : siblingFsmscope, provider : TC scope variable or unknown
                    case ( c_EPTF_LGenBase_fsmObjectScopeTC ){
                      vl_varNames[0][vl_var] := f_EPTF_LGenBase_varNameOfTCVar( pl_tcIdx, vl_varName);
                    }
                    case else
                    {
                      f_EPTF_LGenBase_loggingError(%definitionId&": Invalid scope of provider: "&log2str(vl_varScope)&", in case of sbilingFsm scope stathandler");
                    }
                  }
                }
              }
              //StatHandler with siblingFSM scope - StatMeas providers
              case ( ischosen(pl_providers[vl_provider].statMeasXref) ){
                var integer vl_statMeasXRef := pl_providers[vl_provider].statMeasXref;
                var EPTF_LGenBase_FsmObjectScope vl_varScope := v_LGenBase_fsmTables[pl_tIdx].statMeasXRefs[vl_statMeasXRef].scope
                var integer vl_idxInScope := v_LGenBase_fsmTables[pl_tIdx].statMeasXRefs[vl_statMeasXRef].idxInScope
                var charstring vl_varName := v_LGenBase_fsmTables[pl_tIdx].statMeasStatListArray[vl_varScope][vl_idxInScope].name
                select( vl_varScope ){
                  //siblingFSM scope statHandler with FSM scope StatMeas provider
                  case ( c_EPTF_LGenBase_fsmObjectScopeFSM ){
                    for(var integer vl_FSMs := 0; vl_FSMs < sizeof(v_LGenBase_trafficCases[pl_tcIdx].fsmList); vl_FSMs := vl_FSMs + 1 )
                    {
                      var integer v_ConcFSM := v_LGenBase_trafficCases[pl_tcIdx].fsmList[vl_FSMs].fsmTypeIdx;
                      for(var integer vl_iScope := 0; vl_iScope < sizeof(v_LGenBase_fsmTables[v_ConcFSM].statMeasStatListArray[vl_varScope]); vl_iScope := vl_iScope + 1 )
                      {
                        if (vl_varName == v_LGenBase_fsmTables[v_ConcFSM].statMeasStatListArray[vl_varScope][vl_iScope].name)
                        {
                          vl_statMeasIdList[sizeof(vl_statMeasIdList)] := v_LGenBase_entities[vl_eOffset+pl_statRelEIdx].fsmCtxList[vl_FSMs].statMeasStatList[vl_iScope]
                        }
                      }
                    }
                  }
                  //siblingFSM scope statHandler with siblingFSM scope StatMeas provider
                  case ( c_EPTF_LGenBase_fsmObjectScopeSiblingFSM ){
                    vl_statMeasIdList[sizeof(vl_statMeasIdList)] := f_EPTF_LGenBase_fsmStatMeasIdOfSibling(pl_tcIdx, vl_eOffset+pl_statRelEIdx, vl_varName)
                  }
                  //siblingFSM scope statHandler with TC scope StatMeas provider
                  case ( c_EPTF_LGenBase_fsmObjectScopeTC ){
                    vl_statMeasIdList[sizeof(vl_statMeasIdList)] := v_LGenBase_trafficCases[pl_tcIdx].statMeasStatList[vl_idxInScope].statId;
                  }
                  case else
                  {
                    //A bit paranoia
                    f_EPTF_LGenBase_loggingError(%definitionId&": Invalid FSM object scope: "&log2str(vl_varScope));
                  }
                }
              }
              //StatHandler with siblingFSM scope - StatHandler providers 
              case ( ischosen(pl_providers[vl_provider].statHandlerXref) ){
                var integer vl_statHandlerXref := pl_providers[vl_provider].statHandlerXref;
                var EPTF_LGenBase_FsmObjectScope vl_varScope := v_LGenBase_fsmTables[pl_tIdx].statisticXRefs[vl_statHandlerXref].scope
                var integer vl_idxInScope := v_LGenBase_fsmTables[pl_tIdx].statisticXRefs[vl_statHandlerXref].idxInScope
                var charstring vl_statHandlerName := v_LGenBase_fsmTables[pl_tIdx].statisticListArray[vl_varScope][vl_idxInScope].name;
                select( vl_varScope ){
                  //siblingFSM scope statHandler with FSM scope StatHandler provider
                  case ( c_EPTF_LGenBase_fsmObjectScopeFSM ){
                    for(var integer vl_FSMs := 0; vl_FSMs < sizeof(v_LGenBase_trafficCases[pl_tcIdx].fsmList); vl_FSMs := vl_FSMs + 1 )
                    {
                      var integer v_ConcFSM := v_LGenBase_trafficCases[pl_tcIdx].fsmList[vl_FSMs].fsmTypeIdx;
                      for(var integer vl_iScope := 0; vl_iScope < sizeof(v_LGenBase_fsmTables[v_ConcFSM].statisticListArray[vl_varScope]); vl_iScope := vl_iScope + 1 )
                      {
                        if (vl_statHandlerName == v_LGenBase_fsmTables[v_ConcFSM].statisticListArray[vl_varScope][vl_iScope].name)
                        {
                          vl_statHandlerIdList[sizeof(vl_statHandlerIdList)] := f_EPTF_LGenBase_varNameOfFSMVar(
                            vl_eOffset+pl_statRelEIdx, 
                            vl_FSMs,
                            vl_statHandlerName)
                        }
                      }
                    }
                  }
                  //siblingFSM scope statHandler with siblingFSM scope StatHandler provider
                  case ( c_EPTF_LGenBase_fsmObjectScopeSiblingFSM ){
                    vl_statHandlerIdList[sizeof(vl_statHandlerIdList)] := f_EPTF_LGenBase_varNameOfSiblingFSMsVar(
                      pl_tcIdx,
                      vl_eOffset+pl_statRelEIdx,
                      vl_statHandlerName)
                  }
                  //siblingFSM scope statHandler with TC scope StatHandler provider
                  case ( c_EPTF_LGenBase_fsmObjectScopeTC ){
                    vl_statHandlerIdList[sizeof(vl_statHandlerIdList)] := f_EPTF_LGenBase_varNameOfTCVar(
                      pl_tcIdx,
                      vl_statHandlerName)
                  }
                  case else
                  {
                    //A bit paranoia
                    f_EPTF_LGenBase_loggingError(%definitionId&": Invalid FSM object scope: "&log2str(vl_varScope));
                  }
                }
              }
              case else{
                //A bit paranoia
                f_EPTF_LGenBase_loggingError(%definitionId&": Invalid provider type: "&log2str(pl_providers[vl_provider]));                
              }
            }
          }
        }
        
        // TC scope statHandler        
        case(c_EPTF_LGenBase_fsmObjectScopeTC == pl_statScope) {
          for ( var integer vl_provider := 0; vl_provider < vl_providerCount ; vl_provider := vl_provider+1 ){
            select( true ){
              case ( ischosen(pl_providers[vl_provider].varXrefList) ){
                // TC scope statHandler with Variable providers
                
                for ( var integer vl_var := 0; vl_var < sizeof(pl_providers[vl_provider].varXrefList) ; vl_var := vl_var+1 ){
                  var integer vl_varXRef := pl_providers[vl_provider].varXrefList[vl_var];
                  var EPTF_LGenBase_FsmObjectScope vl_varScope := plTable.varXRefs[vl_varXRef].scope;
                  var integer vl_idxInScope := plTable.varXRefs[vl_varXRef].idxInScope;
                  
                  var charstring vl_varName := v_LGenBase_fsmTables[pl_tIdx].varListArray[vl_varScope][vl_idxInScope].name
                  select( vl_varScope ){
                    // TC scope statHandler with FSM scoped Variable providers
                    case ( c_EPTF_LGenBase_fsmObjectScopeFSM ){
                      for(var integer vl_FSMs := 0; vl_FSMs < sizeof(v_LGenBase_trafficCases[pl_tcIdx].fsmList); vl_FSMs := vl_FSMs + 1 )
                      {
                        var integer v_ConcFSM := v_LGenBase_trafficCases[pl_tcIdx].fsmList[vl_FSMs].fsmTypeIdx;
                        for(var integer vl_iScope := 0; vl_iScope < sizeof(v_LGenBase_fsmTables[v_ConcFSM].varListArray[vl_varScope]); vl_iScope := vl_iScope + 1 )
                        {
                          if (vl_varName == v_LGenBase_fsmTables[v_ConcFSM].varListArray[vl_varScope][vl_iScope].name)
                          {
                            for ( var integer vl_eIdx := 0; vl_eIdx < vl_eCount ; vl_eIdx := vl_eIdx+1 )
                            {
                              vl_varNames[sizeof(vl_varNames)][vl_var] := f_EPTF_LGenBase_varNameOfFSMVar(
                                vl_eOffset+vl_eIdx, 
                                f_EPTF_LGenBase_getFSMCtxIdx(vl_eOffset+vl_eIdx,pl_tcIdx,vl_FSMs),
                                plTable.varListArray[vl_varScope][vl_idxInScope].name);
                            }
                          }
                        }
                        
                      }
                    }
                    // TC scope statHandler with siblingFSM scoped Variable providers
                    case ( c_EPTF_LGenBase_fsmObjectScopeSiblingFSM ){
                      if(pl_tcIdx<0){
                        f_EPTF_LGenBase_loggingError(%definitionId&": The FSM activated outside of traffic case has a variable provider "&                        
                          plTable.varListArray[vl_varScope][vl_idxInScope].name&
                          " with object scope siblingFSM for the statistic "&pl_statName);
                      }
                      for ( var integer vl_eIdx := 0; vl_eIdx < vl_eCount ; vl_eIdx := vl_eIdx+1 )
                      {
                        vl_varNames[vl_eIdx][vl_var] := f_EPTF_LGenBase_varNameOfSiblingFSMsVar(
                          pl_tcIdx,
                          vl_eIdx,
                          plTable.varListArray[vl_varScope][vl_idxInScope].name);
                      }
                    }
                    // TC scope statHandler with TC scoped Variable providers
                    case ( c_EPTF_LGenBase_fsmObjectScopeTC ){
                      if(pl_tcIdx<0){
                        f_EPTF_LGenBase_loggingError(%definitionId&": The FSM activated outside of traffic case has a variable provider "&                        
                          plTable.varListArray[vl_varScope][vl_idxInScope].name&
                          " with object scope TC for the statistic "&pl_statName);
                      }                      
                      vl_varNames[0][vl_var] := f_EPTF_LGenBase_varNameOfTCVar(                        
                        pl_tcIdx,                        
                        plTable.varListArray[vl_varScope][vl_idxInScope].name);
                    }
                    case else
                    {
                      //A bit paranoia
                      f_EPTF_LGenBase_loggingError(%definitionId&": Invalid FSM object scope: "&log2str(vl_varScope));
                    }
                  }
                }
              }
              // TC scope statHandler with StatMeas providers
              case ( ischosen(pl_providers[vl_provider].statMeasXref) ){
                var integer vl_statMeasXRef := pl_providers[vl_provider].statMeasXref;
                var EPTF_LGenBase_FsmObjectScope vl_varScope := v_LGenBase_fsmTables[pl_tIdx].statMeasXRefs[vl_statMeasXRef].scope
                var integer vl_idxInScope := v_LGenBase_fsmTables[pl_tIdx].statMeasXRefs[vl_statMeasXRef].idxInScope
                var charstring vl_varName := v_LGenBase_fsmTables[pl_tIdx].statMeasStatListArray[vl_varScope][vl_idxInScope].name
                
                select( vl_varScope ){
                  // TC scope statHandler with FSM scoped StatMeas providers
                  case ( c_EPTF_LGenBase_fsmObjectScopeFSM ){
                    for(var integer vl_FSMs := 0; vl_FSMs < sizeof(v_LGenBase_trafficCases[pl_tcIdx].fsmList); vl_FSMs := vl_FSMs + 1 )
                    {
                      var integer v_ConcFSM := v_LGenBase_trafficCases[pl_tcIdx].fsmList[vl_FSMs].fsmTypeIdx;
                      for(var integer vl_iScope := 0; vl_iScope < sizeof(v_LGenBase_fsmTables[v_ConcFSM].statMeasStatListArray[vl_varScope]); vl_iScope := vl_iScope + 1 )
                      {
                        if (vl_varName == v_LGenBase_fsmTables[v_ConcFSM].statMeasStatListArray[vl_varScope][vl_iScope].name)
                        {
                          for ( var integer vl_eIdx := 0; vl_eIdx < vl_eCount ; vl_eIdx := vl_eIdx+1 )
                          {
                            vl_statMeasIdList[sizeof(vl_statMeasIdList)] := v_LGenBase_entities[vl_eOffset+vl_eIdx].fsmCtxList[vl_FSMs].statMeasStatList[vl_idxInScope]
                          }
                        }
                      }
                    }
                  }
                  // TC scope statHandler with siblingFSM scoped StatMeas providers
                  case ( c_EPTF_LGenBase_fsmObjectScopeSiblingFSM ){
                    for ( var integer vl_eIdx := 0; vl_eIdx < vl_eCount ; vl_eIdx := vl_eIdx+1 )
                    {
                      vl_statMeasIdList[sizeof(vl_statMeasIdList)] := f_EPTF_LGenBase_fsmStatMeasIdOfSibling(pl_tcIdx, vl_eOffset+vl_eIdx, vl_varName)
                    }
                  }
                  // TC scope statHandler with TC scoped StatMeas providers
                  case ( c_EPTF_LGenBase_fsmObjectScopeTC ){
                    vl_statMeasIdList[sizeof(vl_statMeasIdList)] := v_LGenBase_trafficCases[pl_tcIdx].statMeasStatList[vl_idxInScope].statId
                  }
                  case else
                  {                    
                    //A bit paranoia
                    f_EPTF_LGenBase_loggingError(%definitionId&": Invalid FSM object scope: "&log2str(vl_varScope));
                  }
                }
                
              }
              // TC scope statHandler with StatHandler providers
              case ( ischosen(pl_providers[vl_provider].statHandlerXref) ){
                var integer vl_statHandlerXref := pl_providers[vl_provider].statHandlerXref;
                var EPTF_LGenBase_FsmObjectScope vl_varScope := v_LGenBase_fsmTables[pl_tIdx].statisticXRefs[vl_statHandlerXref].scope
                var integer vl_idxInScope := v_LGenBase_fsmTables[pl_tIdx].statisticXRefs[vl_statHandlerXref].idxInScope
                
                var charstring vl_statHandlerName := v_LGenBase_fsmTables[pl_tIdx].statisticListArray[vl_varScope][vl_idxInScope].name;
                
                select( vl_varScope ){
                  // TC scope statHandler with FSM scoped StatHandler providers
                  case ( c_EPTF_LGenBase_fsmObjectScopeFSM ){
                    for(var integer vl_FSMs := 0; vl_FSMs < sizeof(v_LGenBase_trafficCases[pl_tcIdx].fsmList); vl_FSMs := vl_FSMs + 1 )
                    {
                      var integer v_ConcFSM := v_LGenBase_trafficCases[pl_tcIdx].fsmList[vl_FSMs].fsmTypeIdx;
                      for(var integer vl_iScope := 0; vl_iScope < sizeof(v_LGenBase_fsmTables[v_ConcFSM].statisticListArray[vl_varScope]); vl_iScope := vl_iScope + 1 )
                      {
                        if (vl_statHandlerName == v_LGenBase_fsmTables[v_ConcFSM].statisticListArray[vl_varScope][vl_iScope].name)
                        {
                          for ( var integer vl_eIdx := 0; vl_eIdx < vl_eCount ; vl_eIdx := vl_eIdx+1 )
                          {
                            vl_statHandlerIdList[sizeof(vl_statHandlerIdList)] := f_EPTF_LGenBase_varNameOfFSMVar(
                              vl_eOffset+vl_eIdx, 
                              vl_FSMs,
                              vl_statHandlerName)
                          }
                        }
                      }
                    }
                  }
                  // TC scope statHandler with siblingFSM scoped StatHandler providers
                  case ( c_EPTF_LGenBase_fsmObjectScopeSiblingFSM ){
                    for ( var integer vl_eIdx := 0; vl_eIdx < vl_eCount ; vl_eIdx := vl_eIdx+1 )
                    {
                      vl_statHandlerIdList[sizeof(vl_statHandlerIdList)] := f_EPTF_LGenBase_varNameOfSiblingFSMsVar(
                        pl_tcIdx, vl_eIdx,
                        vl_statHandlerName)
                    }
                  }
                  // TC scope statHandler with TC scoped StatHandler providers
                  case ( c_EPTF_LGenBase_fsmObjectScopeTC ){
                    //ez esetleg tobb helyre is kellhet.
                    if (pl_tcIdx<0){
                      f_EPTF_LGenBase_loggingError(%definitionId&": The FSM activated outside of traffic case has a statHandler statistic provider "&                      
                        v_LGenBase_fsmTables[pl_tIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_idxInScope].name&
                        " with object scope TC for the statistic "&pl_statName);
                    }
                    vl_statHandlerIdList[sizeof(vl_statHandlerIdList)] := f_EPTF_LGenBase_varNameOfTCVar(
                      pl_tcIdx,
                      vl_statHandlerName)
                  }
                  case else
                  {
                    //A bit paranoia
                    f_EPTF_LGenBase_loggingError(%definitionId&": Invalid FSM object scope: "&log2str(vl_varScope));
                  }
                }
              }
              case else{
                //A bit paranoia
                f_EPTF_LGenBase_loggingError(%definitionId&": Invalid provider type: "&log2str(pl_providers[vl_provider]));
                
              }
            }
          }
        }
        case else {
          f_EPTF_LGenBase_loggingError(%definitionId&": Invalid scope of statHandler: "&pl_statName);          
        }
      }
      
      
      for ( var integer vl_sm := 0; vl_sm < sizeof(vl_varNames) ; vl_sm := vl_sm+1 )
      {
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){                    
          f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Registering statistic "&pl_statName&" with provider: "&log2str(vl_varNames[vl_sm]))
        }
        
        var boolean vl_ok := f_EPTF_StatHandlerClient_registerStat(
          pl_providerVarList := vl_varNames[vl_sm],
          pl_statName := pl_statName, 
          pl_subscriptionMode := v_LGenBase_fSMStatsSubscribeMode,                    
          pl_sourceCompRef := self,
          pl_statHandler := self)
        if (vl_ok == false){
          f_EPTF_LGenBase_loggingError(%definitionId&": The registration of the statistics "&pl_statName&" failed.")
        }
        
      }
      
      for ( var integer vl_sm := 0; vl_sm < sizeof(vl_statMeasIdList) ; vl_sm := vl_sm+1 )
      {
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){                    
          f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Registering statistic "&pl_statName&" with StatMeasure statistic provider: "&log2str(vl_statMeasIdList[vl_sm]))
        }
        var boolean vl_ok := f_EPTF_StatHandlerClient_registerStatOfStatMeasure(
          pl_measuredStatIdx := vl_statMeasIdList[vl_sm],                     
          pl_statName:= pl_statName,
          pl_subscriptionMode := v_LGenBase_fSMStatsSubscribeMode,
          pl_statHandler := self)
        
        if (vl_ok == false){
          f_EPTF_LGenBase_loggingError(%definitionId&": The registration of the statistics "&pl_statName&" failed.")
        }
      }
      
      for ( var integer vl_sm := 0; vl_sm < sizeof(vl_statHandlerIdList) ; vl_sm := vl_sm+1 )
      {
        var boolean vl_ok := f_EPTF_StatHandlerClient_registerAggregatedStat(
          pl_sourceStatHandler := self,
          pl_sourceStatName := vl_statHandlerIdList[vl_sm],  
          pl_targetStatName := pl_statName, 
          pl_statHandler := self)
        if (vl_ok == false){
          f_EPTF_LGenBase_loggingError(%definitionId&": The registration of the statistics "&pl_statName&" failed.")
        }
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: deactivateFsm
    // 
    //  Purpose:
    //    Deactivate an activated FSM of an entity
    //
    //  Parameters:
    //    - pl_eIdx - *in* - *integer* - index of the entity whose FSM is to be
    //      deactivated 
    //    - pl_fCtxIdxIdx - *in* - *integer* - index of the table context to be deleted 
    //
    //  Return Value:
    //    -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //    Will try to find the related table in the fsmCtxList of the entity. 
    //
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_deactivateFsm(in integer pl_eIdx, in integer pl_fCtxIdx) 
    runs on EPTF_LGenBase_Private_CT{
      if(not f_EPTF_FBQ_itemIsBusy(pl_fCtxIdx, v_LGenBase_entities[pl_eIdx].fsmCtxQueue)){
        //TODO Warning
        return;
      }
      f_EPTF_FBQ_moveFromBusyToFreeTail(pl_fCtxIdx, v_LGenBase_entities[pl_eIdx].fsmCtxQueue);
      var integer vl_count := sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].rowListeners);
      var integer vl_tIdx := v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx;
      
      for ( var integer vl_i := 0; vl_i < vl_count ; vl_i := vl_i+1 )
      {
        // FIXME: unbound value should not be there
        if(isbound(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].rowListeners[vl_i].lIdx) and 
           ispresent(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].rowListeners[vl_i].lIdx)){
          var integer vl_listenerIdx := v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].rowListeners[vl_i].lIdx;
          var EPTF_LGenBase_ReportableEventType vl_eventType := v_LGenBase_fsmTables[vl_tIdx].eventXref[vl_i].event2Listen.eventType;
          var integer vl_bIdx := v_LGenBase_fsmTables[vl_tIdx].eventXref[vl_i].event2Listen.bIdx;
          var integer vl_iIdx := v_LGenBase_fsmTables[vl_tIdx].eventXref[vl_i].event2Listen.iIdx;
          select( vl_eventType )
          {
            case ( general )
            {
              f_EPTF_LGenBase_removeGeneralEventListener(vl_bIdx, vl_iIdx, vl_listenerIdx);
            }
            case ( entity )
            {
              f_EPTF_LGenBase_removeEntityEventListener2(vl_bIdx, vl_iIdx, pl_eIdx, vl_listenerIdx);
              //f_EPTF_LGenBase_removeEntityEventListener(vl_bIdx, vl_iIdx, pl_eIdx);
            }
            case else
            {
              f_EPTF_Base_assert(%definitionId&"Unhandled listener type.",false);
            }
          }
        }
      }
      //v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx:=-1;
      //FSM variables
      vl_count := sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].varList);
      for ( var integer vl_i := 0; vl_i < vl_count ; vl_i := vl_i+1 )
      {
        f_EPTF_Var_removeVar(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].varList[vl_i]) 
      }
      var integer vl_tcIdx := v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tcIdx;
      //FSM TC variables are deleted in TC destruction
      //FSM statistics
      /*
      vl_count := sizeof(v_LGenBase_fsmTables[vl_tIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeFSM]);
      for ( var integer vl_i := 0; vl_i < vl_count ; vl_i := vl_i+1 )
      {
        var charstring vl_statName := "";
        vl_statName := f_EPTF_LGenBase_varNameOfFSMVar(pl_eIdx, pl_fCtxIdx, 
          v_LGenBase_fsmTables[vl_tIdx].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_i].name);
        f_EPTF_StatHandlerClient_deregisterStat(
          pl_statName := vl_statName, 
          pl_sourceCompRef := self,
          pl_statHandler := self)
      }
      */
      //FSM timers
      f_EPTF_LGenBase_cancelAllTimersOfFsm(pl_eIdx, pl_fCtxIdx);
      v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx:=-1;
    }//f_EPTF_LGenBase_deactivateFsm
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_cancelAllTimersOfFsm
    // 
    //  Purpose:
    //    Cancel all timers of an FSM
    //
    //  Parameters:
    //    - pl_eIdx - *in* - *integer* - index of the entity
    //    - pl_fCtxIdx - *in* - *integer* - index of the fsm
    //
    //  Return Value:
    //    -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //    -
    //
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_cancelAllTimersOfFsm(in integer pl_eIdx, in integer pl_fCtxIdx)
    runs on EPTF_LGenBase_Private_CT
    {
      for ( var integer vl_t := 0; vl_t < sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerData) ; vl_t := vl_t+1 )
      {
        if(-1 != v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerData[vl_t]){
          if(not f_EPTF_SchedulerComp_CancelEvent(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerData[vl_t])) {
            f_EPTF_LGenBase_loggingWarning(%definitionId&": Cancelling timer failed.");
          }
          v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerData[vl_t] := -1;
        }
      }
    }//f_EPTF_LGenBase_cancelAllTimersOfFsm
    
  } // group eventTypeFSM
  
  group eventTypeEntityIndex      {
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_activateEntityIdxListener
    // 
    //  Purpose:
    //    Activates a listener listening to an event with the specified target entity index 
    //
    //  Parameters:
    //    pl_eIdx - *in* *integer* - the index of the target entity 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_activateEntityIdxListener(
      in integer pl_eIdx, 
      in integer pl_listenerIdx)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      f_EPTF_Base_assert(%definitionId&" Invalid entity index", 
        (pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities))
      );
      v_LGenBase_hasEntityIdxListener := true
      //Even the entityListenerListsQueue is present?
      return f_EPTF_Common_IndexArray_setNewElement(v_LGenBase_entities[pl_eIdx].entityIdxListenerList,pl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_deactivateEntityIdxListener
    // 
    //  Purpose:
    //    Dectivates a listener listening to an event with the specified behavior and input index
    //
    //  Parameters:
    //    pl_eIdx - *in* *integer* - the absolute index of the entity 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_deactivateEntityIdxListener(
      in integer pl_eIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      f_EPTF_Base_assert(%definitionId&" Invalid entity index", 
        (pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities))
      );
      var integer vl_ret := f_EPTF_Common_IndexArray_freeElement(v_LGenBase_entities[pl_eIdx].entityIdxListenerList,pl_idx2Remove)
      v_LGenBase_hasEntityIdxListener := 0 > f_EPTF_Common_IndexArray_getFirstBusyIdx(v_LGenBase_entities[pl_eIdx].entityIdxListenerList)
      return vl_ret
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_addEntityIdxListener
    // 
    //  Purpose:
    //    Adds the listener to the database by the <f_EPTF_LGenBase_addListener>
    //    and activates it by the <f_EPTF_LGenBase_activateEntityIdxListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_addEntityIdxListener(
      in integer pl_eIdx,
      in EPTF_LGenBase_EventListener_FT pl_fn,
      in EPTF_IntegerList pl_args
    ) 
    runs on EPTF_LGenBase_Private_CT return integer{
      var integer vl_listenerIdx := f_EPTF_LGenBase_addListener(pl_fn, pl_args);
      return f_EPTF_LGenBase_activateEntityIdxListener(pl_eIdx, vl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeEntityIdxListener
    // 
    //  Purpose:
    //    Deactivates the listener by the <f_EPTF_LGenBase_deactivateEntityIdxListener>
    //    and removes it from the listener database by the <f_EPTF_LGenBase_removeListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeEntityIdxListener(
      in integer pl_eIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT{
      f_EPTF_Base_assert(%definitionId&" Invalid entity index", 
        (pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities))
      );
      var integer vl_listenerIdx := f_EPTF_LGenBase_deactivateEntityIdxListener(pl_eIdx, pl_idx2Remove);
      f_EPTF_LGenBase_removeListener(vl_listenerIdx);
    }
    
  }
  
  group eventTypeFSMOfEntity      {
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_activateFSMOfEntityListener
    // 
    //  Purpose:
    //    Activates a listener listening to an event with the specified FSM index and target entity index
    //
    //  Parameters:
    //    pl_eIdx - *in* *integer* - the index of the target entity 
    //    pl_fIdx - *in* *integer* - the index of the activated FSM returned by the <f_EPTF_LGenBase_activateFSM> function 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_activateFSMOfEntityListener(
      in integer pl_eIdx, 
      in integer pl_fIdx, 
      in integer pl_listenerIdx)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      f_EPTF_Base_assert(%definitionId&" Invalid entity index", 
        (pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities))
      );
      f_EPTF_Base_assert(%definitionId&" Invalid FSM context index", 
        (pl_fIdx>=0 and pl_fIdx<sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList) and
          f_EPTF_FBQ_itemIsBusy(pl_fIdx, v_LGenBase_entities[pl_eIdx].fsmCtxQueue))
      );
      if(not ispresent(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfTargetEntityListeners)){
        v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfTargetEntityListeners := c_EPTF_LGenBase_emptyListenerList;
        f_EPTF_FBQ_initFreeBusyQueue(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfTargetEntityListeners);
      }
      var integer vl_idx := f_EPTF_FBQ_getOrCreateFreeSlot(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfTargetEntityListeners);
      f_EPTF_FBQ_setQueueDidx(vl_idx, {pl_listenerIdx}, v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfTargetEntityListeners);
      f_EPTF_FBQ_moveFromFreeToBusyTail(vl_idx, v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfTargetEntityListeners);
      v_LGenBase_hasFSMOfEntityListener := true
      return vl_idx;
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_deactivateGeneralListener
    // 
    //  Purpose:
    //    Dectivates a listener listening to an event with the specified parameters
    //
    //  Parameters:
    //    pl_eIdx - *in* *integer* - the absolute index of the entity 
    //    pl_fIdx - *in* *integer* - the index of the FSM context returned by the <f_EPTF_LGenBase_activateFsm> function 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_deactivateFSMOfEntityListener(
      in integer pl_eIdx, 
      in integer pl_fIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      f_EPTF_Base_assert(%definitionId&" Invalid entity index", 
        (pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities))
      );
      f_EPTF_Base_assert(%definitionId&" Invalid FSM context index", 
        (pl_fIdx>=0 and pl_fIdx<sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList) and
          f_EPTF_FBQ_itemIsBusy(pl_fIdx, v_LGenBase_entities[pl_eIdx].fsmCtxQueue))
      );
      f_EPTF_Base_assert(%definitionId&" Invalid listener index - no listener queue",
        ispresent(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfTargetEntityListeners)
      );
      f_EPTF_Base_assert(%definitionId&" Invalid listener index", 
        f_EPTF_FBQ_itemIsBusy(pl_idx2Remove, v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfTargetEntityListeners)
      );
      f_EPTF_FBQ_moveFromBusyToFreeTail(pl_idx2Remove, v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfTargetEntityListeners);
      v_LGenBase_hasFSMOfEntityListener := 0 != f_EPTF_FBQ_getLengthOfBusyChain(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfTargetEntityListeners)
      return f_EPTF_FBQ_getQueueData(pl_idx2Remove, v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfTargetEntityListeners, 0);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_addFSMOfEntityListener
    // 
    //  Purpose:
    //    Adds the listener to the database by the <f_EPTF_LGenBase_addListener>
    //    and activates it by the <f_EPTF_LGenBase_activateFSMOfEntityListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_addFSMOfEntityListener(
      in integer pl_eIdx, 
      in integer pl_fIdx, 
      in EPTF_LGenBase_EventListener_FT pl_fn,
      in EPTF_IntegerList pl_args
    ) 
    runs on EPTF_LGenBase_Private_CT return integer{
      var integer vl_listenerIdx := f_EPTF_LGenBase_addListener(pl_fn, pl_args);
      return f_EPTF_LGenBase_activateFSMOfEntityListener(pl_eIdx, pl_fIdx, vl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeFSMOfEntityListener
    // 
    //  Purpose:
    //    Deactivates the listener by the <f_EPTF_LGenBase_deactivateFSMOfEntityListener>
    //    and removes it from the listener database by the <f_EPTF_LGenBase_removeListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeFSMOfEntityListener(
      in integer pl_eIdx, 
      in integer pl_fIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_listenerIdx := f_EPTF_LGenBase_deactivateFSMOfEntityListener(pl_eIdx, pl_fIdx, pl_idx2Remove);
      f_EPTF_LGenBase_removeListener(vl_listenerIdx);
    }
  }; 
  
  group eventTypeBehaviorOfEntity {
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_activateBehaviorOfEntityListener
    // 
    //  Purpose:
    //    Activates a listener listening to a behavior of an entity event 
    //
    //  Parameters:
    //    pl_bIdx - *in* *integer* - the index of the registered behavior returned by the <f_EPTF_LGenBase_declareBehaviorType> function 
    //    pl_eIdx - *in* *integer* - the index of the target entity 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_activateBehaviorOfEntityListener(
      in integer pl_bIdx,
      in integer pl_eIdx, 
      in integer pl_listenerIdx)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      //Is there registered listener?
      var integer vl_listenerListIdx; 
      if(not f_EPTF_int2int_HashMap_Find(
          v_LGenBase_behaviorTypes[pl_bIdx].behaviorOfEntityHashMap, 
          pl_eIdx, 
          vl_listenerListIdx)){
        //No, there isn't. Let's create one.
        vl_listenerListIdx := f_EPTF_Common_IndexArray_setNewElement(v_LGenBase_entities[pl_eIdx].entityListenerListsQueue);
        v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx] := c_EPTF_LGenBase_emptyArrayListenerList;
        f_EPTF_int2int_HashMap_Insert(
          v_LGenBase_behaviorTypes[pl_bIdx].behaviorOfEntityHashMap,
          pl_eIdx, 
          vl_listenerListIdx); 
      }
      v_LGenBase_hasBehaviorOfEntityListener := true
      return f_EPTF_Common_IndexArray_setNewElement(v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx],pl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_deactivateBehaviorOfEntityListener
    // 
    //  Purpose:
    //    Dectivates a listener listening to an event with the specified parameters
    //
    //  Parameters:
    //    pl_bIdx - *in* *integer* - the index of the registered behavior returned by the <f_EPTF_LGenBase_declareBehaviorType> function 
    //    pl_eIdx - *in* *integer* - the absolute index of the entity 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_deactivateBehaviorOfEntityListener(
      in integer pl_bIdx,
      in integer pl_eIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      var integer vl_listenerListIdx;
      if(not f_EPTF_int2int_HashMap_Find(
          v_LGenBase_behaviorTypes[pl_bIdx].behaviorOfEntityHashMap, 
          pl_eIdx, 
          vl_listenerListIdx)){
        f_EPTF_LGenBase_loggingWarning(%definitionId&": Invalid index.")
        return -1;
      }
      var integer vl_ret := f_EPTF_Common_IndexArray_freeElement(v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx],pl_idx2Remove);
      if(f_EPTF_Common_IndexArray_arrayIsEmpty(
          v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx])){
        //There are no more listeners. Remove the list and the reference
        v_LGenBase_dummyInt := f_EPTF_Common_IndexArray_freeElement(v_LGenBase_entities[pl_eIdx].entityListenerListsQueue,vl_listenerListIdx);
        f_EPTF_int2int_HashMap_Erase(
          v_LGenBase_behaviorTypes[pl_bIdx].behaviorOfEntityHashMap,
          pl_eIdx)
      }
      v_LGenBase_hasBehaviorOfEntityListener := not f_EPTF_Common_IndexArray_arrayIsEmpty(v_LGenBase_entities[pl_eIdx].entityListenerListsQueue)
      return vl_ret;
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_addBehaviorOfEntityEventListener
    // 
    //  Purpose:
    //    Adds the listener to the database by the <f_EPTF_LGenBase_addListener>
    //    and activates it by the <f_EPTF_LGenBase_activateBehaviorOfEntityListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_addBehaviorOfEntityEventListener(      
      in integer pl_bIdx,
      in integer pl_eIdx, 
      in EPTF_LGenBase_EventListener_FT pl_fn,
      in EPTF_IntegerList pl_args)
    runs on EPTF_LGenBase_Private_CT return integer{
      f_EPTF_Base_assert(%definitionId&" behavior type index", 
        (pl_bIdx>=0 and pl_bIdx<sizeof(v_LGenBase_behaviorTypes))
      );
      f_EPTF_Base_assert(%definitionId&" Entity index", 
        pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities));
      var integer vl_listenerIdx := f_EPTF_LGenBase_addListener(pl_fn, pl_args);
      return f_EPTF_LGenBase_activateBehaviorOfEntityListener(pl_bIdx, pl_eIdx, vl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeBehaviorOfEntityEventListener
    // 
    //  Purpose:
    //    Deactivates the listener by the <f_EPTF_LGenBase_deactivateBehaviorOfEntityListener>
    //    and removes it from the listener database by the <f_EPTF_LGenBase_removeListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeBehaviorOfEntityEventListener(
      in integer pl_bIdx,
      in integer pl_eIdx,
      in integer pl_idx2Remove
    ) 
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_listenerIdx := f_EPTF_LGenBase_deactivateBehaviorOfEntityListener(pl_bIdx, pl_eIdx, pl_idx2Remove);
      f_EPTF_LGenBase_removeListener(vl_listenerIdx);
    }
  }; 
  
  group eventTypeSourceEntity    {
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_activateSourceEntityListener
    // 
    //  Purpose:
    //    Activates a listener listening to a general event sent by the specified source entity
    //
    //  Parameters:
    //    pl_bIdx - *in* *integer* - the index of the registered behavior returned by the <f_EPTF_LGenBase_declareBehaviorType> function 
    //    pl_iIdx - *in* *integer* - the index of the registered FSM input returned by the <f_EPTF_LGenBase_declareFsmEvent> function 
    //    pl_eIdx - *in* *integer* - the index of the source entity 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_activateSourceEntityListener(
      in integer pl_bIdx,
      in integer pl_iIdx, 
      in integer pl_eIdx, 
      in integer pl_listenerIdx)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      //Is there registered listener?
      var integer vl_listenerListIdx; 
      if(not f_EPTF_int2int_HashMap_Find(
          v_LGenBase_behaviorTypes[pl_bIdx].generalSourceListenerHashmapRefs[pl_iIdx], 
          pl_eIdx, 
          vl_listenerListIdx)){
        //No, there isn't. Let's create one.
        vl_listenerListIdx := f_EPTF_Common_IndexArray_setNewElement(v_LGenBase_entities[pl_eIdx].entityListenerListsQueue);
        v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx] := c_EPTF_LGenBase_emptyArrayListenerList
        f_EPTF_int2int_HashMap_Insert(
          v_LGenBase_behaviorTypes[pl_bIdx].generalSourceListenerHashmapRefs[pl_iIdx],
          pl_eIdx, 
          vl_listenerListIdx); 
      }
      v_LGenBase_hasSourceEntityListener := true
      return f_EPTF_Common_IndexArray_setNewElement(v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx],pl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_deactivateBehaviorOfEntityListener
    // 
    //  Purpose:
    //    Dectivates a listener listening to an event with the specified parameters
    //
    //  Parameters:
    //    pl_bIdx - *in* *integer* - the index of the registered behavior returned by the <f_EPTF_LGenBase_declareBehaviorType> function 
    //    pl_iIdx - *in* *integer* - the index of the registered FSM input returned by the <f_EPTF_LGenBase_declareFsmEvent> function 
    //    pl_eIdx - *in* *integer* - the absolute index of the entity which sent the event 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_deactivateSourceEntityListener(
      in integer pl_bIdx,
      in integer pl_iIdx, 
      in integer pl_eIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      var integer vl_listenerListIdx;
      if(not f_EPTF_int2int_HashMap_Find(
          v_LGenBase_behaviorTypes[pl_bIdx].generalSourceListenerHashmapRefs[pl_iIdx], 
          pl_eIdx, 
          vl_listenerListIdx)){
        f_EPTF_LGenBase_loggingWarning(%definitionId&": Invalid index.")
        return -1;
      }
      var integer vl_ret := f_EPTF_Common_IndexArray_freeElement(v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx],pl_idx2Remove);
      if(f_EPTF_Common_IndexArray_arrayIsEmpty(
          v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx])){
        //There are no more listeners. Remove the list and the reference from the hashmap
        v_LGenBase_dummyInt := f_EPTF_Common_IndexArray_freeElement(v_LGenBase_entities[pl_eIdx].entityListenerListsQueue,vl_listenerListIdx);
        f_EPTF_int2int_HashMap_Erase(
          v_LGenBase_behaviorTypes[pl_bIdx].generalSourceListenerHashmapRefs[pl_iIdx],
          pl_eIdx)
      }
      v_LGenBase_hasSourceEntityListener := not f_EPTF_Common_IndexArray_arrayIsEmpty(v_LGenBase_entities[pl_eIdx].entityListenerListsQueue)
      return vl_ret;
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_addSourceEntityListener
    // 
    //  Purpose:
    //    Adds the listener to the database by the <f_EPTF_LGenBase_addListener>
    //    and activates it by the <f_EPTF_LGenBase_activateSourceEntityListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_addSourceEntityListener(      
      in integer pl_bIdx,
      in integer pl_iIdx, 
      in integer pl_eIdx, 
      in EPTF_LGenBase_EventListener_FT pl_fn,
      in EPTF_IntegerList pl_args)
    runs on EPTF_LGenBase_Private_CT return integer{
      f_EPTF_Base_assert(%definitionId&" behavior type index", 
        (pl_bIdx>=0 and pl_bIdx<sizeof(v_LGenBase_behaviorTypes))
      );
      f_EPTF_Base_assert(%definitionId&" Event/input index", 
        pl_iIdx>=0 
        and pl_iIdx<sizeof(v_LGenBase_fsmEvents[pl_bIdx]));
      f_EPTF_Base_assert(%definitionId&" Entity index", 
        pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities));
      var integer vl_listenerIdx := f_EPTF_LGenBase_addListener(pl_fn, pl_args);
      return f_EPTF_LGenBase_activateSourceEntityListener(pl_bIdx, pl_iIdx, pl_eIdx, vl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeSourceEntityListener
    // 
    //  Purpose:
    //    Deactivates the listener by the <f_EPTF_LGenBase_deactivateSourceEntityListener>
    //    and removes it from the listener database by the <f_EPTF_LGenBase_removeListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeSourceEntityListener(
      in integer pl_bIdx,
      in integer pl_iIdx,
      in integer pl_eIdx,
      in integer pl_idx2Remove
    ) 
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_listenerIdx := f_EPTF_LGenBase_deactivateSourceEntityListener(pl_bIdx, pl_iIdx, pl_eIdx, pl_idx2Remove);
      f_EPTF_LGenBase_removeListener(vl_listenerIdx);
    }
    
  }; 
  
  group eventTypeSourceFsm {
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_activateSourceFsmListener
    // 
    //  Purpose:
    //    Activates a listener listening to a general event sent by the specified FSM of the given source entity
    //
    //  Parameters:
    //    pl_bIdx - *in* *integer* - the index of the registered behavior returned by the <f_EPTF_LGenBase_declareBehaviorType> function 
    //    pl_iIdx - *in* *integer* - the index of the registered FSM input returned by the <f_EPTF_LGenBase_declareFsmEvent> function 
    //    pl_eIdx - *in* *integer* - the index of the source entity 
    //    pl_fIdx - *in* *integer* - the index of the activated FSM of the source entity returned by the <f_EPTF_LGenBase_activateFSM> function 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_activateSourceFsmListener(
      in integer pl_bIdx, 
      in integer pl_iIdx, 
      in integer pl_eIdx, 
      in integer pl_fIdx, 
      in integer pl_listenerIdx)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      f_EPTF_Base_assert(%definitionId&" Invalid behavior index", 
        (pl_bIdx>=0 and pl_bIdx<sizeof(v_LGenBase_behaviorTypes))
      );
      f_EPTF_Base_assert(%definitionId&" Invalid input index", 
        pl_iIdx>=0 
        and pl_iIdx<sizeof(v_LGenBase_fsmEvents[pl_bIdx])
      );
      f_EPTF_Base_assert(%definitionId&" Invalid entity index", 
        (pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities))
      );
      f_EPTF_Base_assert(%definitionId&" Invalid FSM context index", 
        (pl_fIdx>=0 and pl_fIdx<sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList) and
          f_EPTF_FBQ_itemIsBusy(pl_fIdx, v_LGenBase_entities[pl_eIdx].fsmCtxQueue))
      );
      if(not ispresent(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceFsmListeners)){
        v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceFsmListeners := c_EPTF_LGenBase_emptyListenerList;
        f_EPTF_FBQ_initFreeBusyQueue(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceFsmListeners);
      }
      var integer vl_idx := f_EPTF_FBQ_getOrCreateFreeSlot(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceFsmListeners);
      f_EPTF_FBQ_setQueueDidx(vl_idx, {pl_listenerIdx, pl_bIdx, pl_iIdx}, v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceFsmListeners);
      f_EPTF_FBQ_moveFromFreeToBusyTail(vl_idx, v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceFsmListeners);
      v_LGenBase_hasSourceFsmListener := true
      return vl_idx;
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_deactivateSourceFsmListener
    // 
    //  Purpose:
    //    Dectivates a listener listening to an event with the specified parameters
    //
    //  Parameters:
    //    pl_eIdx - *in* *integer* - the absolute index of the entity 
    //    pl_fIdx - *in* *integer* - the index of the FSM context which sent the message. It's returned by the <f_EPTF_LGenBase_activateFsm> function 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_deactivateSourceFsmListener(
      in integer pl_eIdx, 
      in integer pl_fIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      //TODO Check data validity
      f_EPTF_Base_assert(%definitionId&" Invalid entity index", 
        (pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities))
      );
      f_EPTF_Base_assert(%definitionId&" Invalid FSM context index", 
        (pl_fIdx>=0 and pl_fIdx<sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList) and
          f_EPTF_FBQ_itemIsBusy(pl_fIdx, v_LGenBase_entities[pl_eIdx].fsmCtxQueue))
      );
      f_EPTF_Base_assert(%definitionId&" Invalid listener index - no queue", 
        ispresent(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceFsmListeners)
      );
      f_EPTF_Base_assert(%definitionId&" Invalid listener index", 
        f_EPTF_FBQ_itemIsBusy(pl_idx2Remove, v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceFsmListeners)
      );
      
      f_EPTF_FBQ_moveFromBusyToFreeTail(
        pl_idx2Remove,
        v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceFsmListeners);
      v_LGenBase_hasSourceFsmListener := 0 != f_EPTF_FBQ_getLengthOfBusyChain(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceFsmListeners)
      return f_EPTF_FBQ_getQueueData(
        pl_idx2Remove,
        v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceFsmListeners, 
      0);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_addSourceFsmListener
    // 
    //  Purpose:
    //    Adds the listener to the database by the <f_EPTF_LGenBase_addListener>
    //    and activates it by the <f_EPTF_LGenBase_activateSourceFsmListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_addSourceFsmListener(
      in integer pl_bIdx, 
      in integer pl_iIdx, 
      in integer pl_eIdx, 
      in integer pl_fIdx, 
      in EPTF_LGenBase_EventListener_FT pl_fn,
      in EPTF_IntegerList pl_args
    ) 
    runs on EPTF_LGenBase_Private_CT return integer{
      var integer vl_listenerIdx := f_EPTF_LGenBase_addListener(pl_fn, pl_args);
      return f_EPTF_LGenBase_activateSourceFsmListener(pl_bIdx,pl_iIdx,pl_eIdx,pl_fIdx, vl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeSourceFsmListener
    // 
    //  Purpose:
    //    Deactivates the listener by the <f_EPTF_LGenBase_deactivateSourceFsmListener>
    //    and removes it from the listener database by the <f_EPTF_LGenBase_removeListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeSourceFsmListener(
      in integer pl_eIdx, 
      in integer pl_fIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_listenerIdx := f_EPTF_LGenBase_deactivateSourceFsmListener(pl_eIdx,pl_fIdx, pl_idx2Remove);
      f_EPTF_LGenBase_removeListener(vl_listenerIdx);
    }
  };
  
  group eventTypeSourceEntityIndex     {
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_activateSourceEntityIndexListener
    // 
    //  Purpose:
    //    Activates a listener listening to any event sent by the specified source entity
    //
    //  Parameters:
    //    pl_eIdx - *in* *integer* - the index of the source entity 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_activateSourceEntityIndexListener(
      in integer pl_eIdx, 
      in integer pl_listenerIdx)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      f_EPTF_Base_assert(%definitionId&" Invalid entity index", 
        (pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities))
      );
      v_LGenBase_hasSourceEntityIndexListener := true
      return f_EPTF_Common_IndexArray_setNewElement(v_LGenBase_entities[pl_eIdx].sourceEntityListenerList,pl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_deactivateSourceEntityIndexListener
    // 
    //  Purpose:
    //    Dectivates a listener listening to an event with the specified parameters
    //
    //  Parameters:
    //    pl_eIdx - *in* *integer* - the absolute index of the entity which sent the event 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_deactivateSourceEntityIndexListener(
      in integer pl_eIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      f_EPTF_Base_assert(%definitionId&" Invalid entity index", 
        (pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities))
      );
      var integer vl_ret := f_EPTF_Common_IndexArray_freeElement(v_LGenBase_entities[pl_eIdx].sourceEntityListenerList,pl_idx2Remove)
      v_LGenBase_hasSourceEntityIndexListener := not f_EPTF_Common_IndexArray_arrayIsEmpty(v_LGenBase_entities[pl_eIdx].sourceEntityListenerList)
      return vl_ret
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_addSourceEntityIndexListener
    // 
    //  Purpose:
    //    Adds the listener to the database by the <f_EPTF_LGenBase_addListener>
    //    and activates it by the <f_EPTF_LGenBase_activateSourceEntityIndexListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_addSourceEntityIndexListener(
      in integer pl_eIdx,
      in EPTF_LGenBase_EventListener_FT pl_fn,
      in EPTF_IntegerList pl_args
    ) 
    runs on EPTF_LGenBase_Private_CT return integer{
      var integer vl_listenerIdx := f_EPTF_LGenBase_addListener(pl_fn, pl_args);
      return f_EPTF_LGenBase_activateSourceEntityIndexListener(pl_eIdx, vl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeSourceEntityIndexListener
    // 
    //  Purpose:
    //    Deactivates the listener by the <f_EPTF_LGenBase_deactivateSourceEntityIndexListener>
    //    and removes it from the listener database by the <f_EPTF_LGenBase_removeListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeSourceEntityIndexListener(
      in integer pl_eIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT{
      f_EPTF_Base_assert(%definitionId&" Invalid entity index", 
        (pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities))
      );
      var integer vl_listenerIdx := f_EPTF_LGenBase_deactivateSourceEntityIndexListener(pl_eIdx, pl_idx2Remove);
      f_EPTF_LGenBase_removeListener(vl_listenerIdx);
    }
  }; 
  
  group eventTypeFsmOfSourceEntity        {
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_activateFsmOfSourceEntityListener
    // 
    //  Purpose:
    //    Activates a listener listening to any event sent by the specified FSM of the given source entity
    //
    //  Parameters:
    //    pl_eIdx - *in* *integer* - the index of the source entity 
    //    pl_fIdx - *in* *integer* - the index of the activated FSM of the source entity returned by the <f_EPTF_LGenBase_activateFSM> function 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_activateFsmOfSourceEntityListener(
      in integer pl_eIdx, 
      in integer pl_fIdx, 
      in integer pl_listenerIdx)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      f_EPTF_Base_assert(%definitionId&" Invalid behavior index", 
        (pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities))
      );
      f_EPTF_Base_assert(%definitionId&" Invalid FSM context index", 
        (pl_fIdx>=0 and pl_fIdx<sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList) and
          f_EPTF_FBQ_itemIsBusy(pl_fIdx, v_LGenBase_entities[pl_eIdx].fsmCtxQueue))
      );
      if(not ispresent(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceEntityListeners)){
        v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceEntityListeners := c_EPTF_LGenBase_emptyListenerList;
        f_EPTF_FBQ_initFreeBusyQueue(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceEntityListeners);
      }
      var integer vl_idx := f_EPTF_FBQ_getOrCreateFreeSlot(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceEntityListeners);
      f_EPTF_FBQ_setQueueDidx(vl_idx, {pl_listenerIdx}, v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceEntityListeners);
      f_EPTF_FBQ_moveFromFreeToBusyTail(vl_idx, v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceEntityListeners);
      v_LGenBase_hasFsmOfSourceEntityListener := true
      return vl_idx;
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_deactivateFsmOfSourceEntityListener
    // 
    //  Purpose:
    //    Dectivates a listener listening to an event with the specified parameters
    //
    //  Parameters:
    //    pl_eIdx - *in* *integer* - the absolute index of the entity 
    //    pl_fIdx - *in* *integer* - the index of the FSM context returned by the <f_EPTF_LGenBase_activateFsm> function 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_deactivateFsmOfSourceEntityListener(
      in integer pl_eIdx, 
      in integer pl_fIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      f_EPTF_Base_assert(%definitionId&" Invalid behavior index", 
        (pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities))
      );
      f_EPTF_Base_assert(%definitionId&" Invalid FSM context index", 
        (pl_fIdx>=0 and pl_fIdx<sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList) and
          f_EPTF_FBQ_itemIsBusy(pl_fIdx, v_LGenBase_entities[pl_eIdx].fsmCtxQueue))
      );
      f_EPTF_Base_assert(%definitionId&" Invalid listener index - no queue", 
        ispresent(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceEntityListeners)
      );
      f_EPTF_Base_assert(%definitionId&" Invalid listener index", 
        f_EPTF_FBQ_itemIsBusy(pl_idx2Remove, v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceEntityListeners)
      );
      f_EPTF_FBQ_moveFromBusyToFreeTail(pl_idx2Remove, v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceEntityListeners);
      v_LGenBase_hasFsmOfSourceEntityListener := 0 != f_EPTF_FBQ_getLengthOfBusyChain(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceEntityListeners)
      return f_EPTF_FBQ_getQueueData(pl_idx2Remove, v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].fsmOfSourceEntityListeners, 0);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_addFsmOfSourceEntityListener
    // 
    //  Purpose:
    //    Adds the listener to the database by the <f_EPTF_LGenBase_addListener>
    //    and activates it by the <f_EPTF_LGenBase_activateFsmOfSourceEntityListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_addFsmOfSourceEntityListener(
      in integer pl_eIdx, 
      in integer pl_fIdx, 
      in EPTF_LGenBase_EventListener_FT pl_fn,
      in EPTF_IntegerList pl_args
    ) 
    runs on EPTF_LGenBase_Private_CT return integer{
      var integer vl_listenerIdx := f_EPTF_LGenBase_addListener(pl_fn, pl_args);
      return f_EPTF_LGenBase_activateFsmOfSourceEntityListener(pl_eIdx, pl_fIdx, vl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeFsmOfSourceEntityListener
    // 
    //  Purpose:
    //    Deactivates the listener by the <f_EPTF_LGenBase_deactivateFsmOfSourceEntityListener>
    //    and removes it from the listener database by the <f_EPTF_LGenBase_removeListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeFsmOfSourceEntityListener(
      in integer pl_eIdx, 
      in integer pl_fIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_listenerIdx := f_EPTF_LGenBase_deactivateFsmOfSourceEntityListener(pl_eIdx, pl_fIdx, pl_idx2Remove);
      f_EPTF_LGenBase_removeListener(vl_listenerIdx);
    }
  }; 
  
  group eventTypebehaviorOfSource {
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_activateBehaviorOfSourceEntityListener
    // 
    //  Purpose:
    //    Activates a listener listening to any event sent by the specified source entity with the give behavior
    //
    //  Parameters:
    //    pl_bIdx - *in* *integer* - the index of the registered behavior returned by the <f_EPTF_LGenBase_declareBehaviorType> function 
    //    pl_eIdx - *in* *integer* - the index of the source entity 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_activateBehaviorOfSourceEntityListener(
      in integer pl_bIdx,
      in integer pl_eIdx, 
      in integer pl_listenerIdx)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      //Is there registered listener?
      var integer vl_listenerListIdx; 
      if(not f_EPTF_int2int_HashMap_Find(
          v_LGenBase_behaviorTypes[pl_bIdx].behaviorOfSourceHashMap, 
          pl_eIdx, 
          vl_listenerListIdx)){
        //No, there isn't. Let's create one.
        vl_listenerListIdx := f_EPTF_Common_IndexArray_setNewElement(v_LGenBase_entities[pl_eIdx].entityListenerListsQueue);
        v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx] := c_EPTF_LGenBase_emptyArrayListenerList
        f_EPTF_int2int_HashMap_Insert(
          v_LGenBase_behaviorTypes[pl_bIdx].behaviorOfSourceHashMap,
          pl_eIdx, 
          vl_listenerListIdx); 
      }
      v_LGenBase_hasBehaviorOfSourceEntityListener := true
      return f_EPTF_Common_IndexArray_setNewElement(v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx],pl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_deactivateBehaviorOfSourceEntityListener
    // 
    //  Purpose:
    //    Dectivates a listener listening to an event with the specified parameters
    //
    //  Parameters:
    //    pl_bIdx - *in* *integer* - the index of the registered behavior returned by the <f_EPTF_LGenBase_declareBehaviorType> function 
    //    pl_eIdx - *in* *integer* - the absolute index of the entity which sent the event 
    //    pl_listenerIdx - *in* *integer* - the index of the added listener, returned by the <f_EPTF_LGenBase_addListener> 
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_deactivateBehaviorOfSourceEntityListener(
      in integer pl_bIdx,
      in integer pl_eIdx, 
      in integer pl_idx2Remove)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      var integer vl_listenerListIdx;
      if(not f_EPTF_int2int_HashMap_Find(
          v_LGenBase_behaviorTypes[pl_bIdx].behaviorOfSourceHashMap, 
          pl_eIdx, 
          vl_listenerListIdx)){
        f_EPTF_LGenBase_loggingWarning(%definitionId&": Invalid index.")
        return -1;
      }
      var integer vl_ret := f_EPTF_Common_IndexArray_freeElement(v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx],pl_idx2Remove);
      if(f_EPTF_Common_IndexArray_arrayIsEmpty(
          v_LGenBase_entities[pl_eIdx].entityListenerLists[vl_listenerListIdx])){
        //There are no more listeners. Remove the list and the reference from the hashmap
        v_LGenBase_dummyInt := f_EPTF_Common_IndexArray_freeElement(v_LGenBase_entities[pl_eIdx].entityListenerListsQueue,vl_listenerListIdx);
        f_EPTF_int2int_HashMap_Erase(
          v_LGenBase_behaviorTypes[pl_bIdx].behaviorOfSourceHashMap,
          pl_eIdx)
      }
      v_LGenBase_hasBehaviorOfSourceEntityListener := not f_EPTF_Common_IndexArray_arrayIsEmpty(v_LGenBase_entities[pl_eIdx].entityListenerListsQueue)
      return vl_ret;
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_addBehaviorOfSourceEntityEventListener
    // 
    //  Purpose:
    //    Adds the listener to the database by the <f_EPTF_LGenBase_addListener>
    //    and activates it by the <f_EPTF_LGenBase_activateBehaviorOfSourceEntityListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_addBehaviorOfSourceEntityEventListener(      
      in integer pl_bIdx,
      in integer pl_eIdx, 
      in EPTF_LGenBase_EventListener_FT pl_fn,
      in EPTF_IntegerList pl_args)
    runs on EPTF_LGenBase_Private_CT return integer{
      f_EPTF_Base_assert(%definitionId&" behavior type index", 
        (pl_bIdx>=0 and pl_bIdx<sizeof(v_LGenBase_behaviorTypes))
      );
      f_EPTF_Base_assert(%definitionId&" Entity index", 
        pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities));
      var integer vl_listenerIdx := f_EPTF_LGenBase_addListener(pl_fn, pl_args);
      return f_EPTF_LGenBase_activateBehaviorOfSourceEntityListener(pl_bIdx, pl_eIdx, vl_listenerIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_removeBehaviorOfSourceEntityEventListener
    // 
    //  Purpose:
    //    Deactivates the listener by the <f_EPTF_LGenBase_deactivateBehaviorOfSourceEntityListener>
    //    and removes it from the listener database by the <f_EPTF_LGenBase_removeListener> function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_removeBehaviorOfSourceEntityEventListener(
      in integer pl_bIdx,
      in integer pl_eIdx,
      in integer pl_idx2Remove
    ) 
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_listenerIdx := f_EPTF_LGenBase_deactivateBehaviorOfSourceEntityListener(pl_bIdx, pl_eIdx, pl_idx2Remove);
      f_EPTF_LGenBase_removeListener(vl_listenerIdx);
    }
  }; 
  
}

group fsmDebug{
  
  //TODO comment
  public function f_EPTF_LGenBase_setFSMDebug(
    in integer pl_eAbsIdx,
    in integer pl_fCtxIdx,
    out integer pl_varId)
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    f_EPTF_Base_assert(%definitionId&": Invalid entity index "&int2str(pl_eAbsIdx),pl_eAbsIdx > -1 and pl_eAbsIdx < sizeof(v_LGenBase_entities));
    f_EPTF_Base_assert(%definitionId&": Invalid FSM context index: "&int2str(pl_fCtxIdx), -1 < pl_fCtxIdx and pl_fCtxIdx < sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList))
    v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].debugLog := true
    var charstring vl_varName := f_EPTF_LGenBase_fsmDebugVarName(pl_eAbsIdx, pl_fCtxIdx)
    pl_varId := f_EPTF_Var_getId(vl_varName)
    if(-1 == pl_varId){
      //The f_EPTF_Var_newCharstring sends assert if the operation failed
      f_EPTF_Var_newCharstring(vl_varName, "", pl_varId)
      v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].logBufferVariable := pl_varId
      //Attach postproc functions
      for ( var integer vl_fn := 0; vl_fn < sizeof(v_LGenBase_fsmDebugPostprocList) ; vl_fn := vl_fn+1 ){
        f_EPTF_Var_addPostProcFn(pl_varId, v_LGenBase_fsmDebugPostprocList[vl_fn])
      }
      return true
    }else{
      f_EPTF_LGenBase_loggingWarning(%definitionId&": Can't create FSM debug log variable. The name "&vl_varName&" is in use.")
      return false;
    }
  }
  
  //TODO comment
  public function f_EPTF_LGenBase_fsmDebugVarName(
    in integer pl_eAbsIdx,
    in integer pl_fCtxIdx)
  runs on EPTF_LGenBase_Private_CT
  return charstring {
    return c_EPTF_LGenBase_fsmDebugVarPrefix&f_EPTF_LGenBase_getEntityName(pl_eAbsIdx)&tsp_LGenBase_nameSeparator&" FSM#"&int2str(pl_fCtxIdx)
  }
  
  //TODO comment
  public function f_EPTF_LGenBase_closeFSMDebug(
    in integer pl_eAbsIdx,
    in integer pl_fCtxIdx)
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Invalid entity index "&int2str(pl_eAbsIdx),pl_eAbsIdx > -1 and pl_eAbsIdx < sizeof(v_LGenBase_entities));
    f_EPTF_Base_assert(%definitionId&": Invalid FSM context index: "&int2str(pl_fCtxIdx), -1 < pl_fCtxIdx and pl_fCtxIdx < sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList))
    v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].debugLog := true
    var integer vl_varIdx := v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].logBufferVariable
    v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].logBufferVariable := v_LGenBase_defaultLogBuffer
    if(-1 != vl_varIdx and vl_varIdx != v_LGenBase_defaultLogBuffer){
      f_EPTF_Var_removeVar(vl_varIdx)
    }
  }
  
  //TODO comment
  public function f_EPTF_LGenBase_debugInput(
    in integer pl_eAbsIdx,
    in integer pl_fCtxIdx,
    in integer pl_iIdx)
  runs on EPTF_LGenBase_Private_CT
  return charstring {
    return log2str(
      "Behavior: ",c_EPTF_LGenBase_behavior,
      "\nInput: ", f_EPTF_LGenBase_iIdx2Str(c_EPTF_LGenBase_bIdx,pl_iIdx))
  }
}

group fsmState{
  public function f_EPTF_LGenBase_getEntityStateAtFsm(
    in integer pl_eAbsIdx, 
    in integer pl_fCtxIdx) 
  runs on EPTF_LGenBase_Private_CT return integer {
    f_EPTF_Base_assert(%definitionId&": Invalid entity index "&int2str(pl_eAbsIdx),pl_eAbsIdx > -1 and pl_eAbsIdx < sizeof(v_LGenBase_entities));
    f_EPTF_Base_assert(%definitionId&": Invalid FSM context index: "&int2str(pl_fCtxIdx), -1 < pl_fCtxIdx and pl_fCtxIdx < sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList))
    return v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].stateIdx 
  }
  
  public function f_EPTF_LGenBase_getEntityStateNameAtFsm(
    in integer pl_eAbsIdx, 
    in integer pl_fCtxIdx) 
  runs on EPTF_LGenBase_Private_CT return charstring{
    f_EPTF_Base_assert(%definitionId&": Invalid entity index "&int2str(pl_eAbsIdx),pl_eAbsIdx > -1 and pl_eAbsIdx < sizeof(v_LGenBase_entities));
    f_EPTF_Base_assert(%definitionId&": Invalid FSM context index: "&int2str(pl_fCtxIdx), -1 < pl_fCtxIdx and pl_fCtxIdx < sizeof(v_LGenBase_entities[pl_eAbsIdx].fsmCtxList))
    return f_EPTF_LGenBase_getFsmStateName(
      v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].tableIdx,
      v_LGenBase_entities[pl_eAbsIdx].fsmCtxList[pl_fCtxIdx].stateIdx) 
  }
  
  public function f_EPTF_LGenBase_getFsmStateName(
    in integer pl_fsmTableIdx, 
    in integer pl_stateIdx) 
  runs on EPTF_LGenBase_Private_CT return charstring{
    f_EPTF_Base_assert(%definitionId&": Invalid FSM table type index "&int2str(pl_fsmTableIdx),pl_fsmTableIdx > -1 and pl_fsmTableIdx < sizeof(v_LGenBase_fsmTables));
    f_EPTF_Base_assert(%definitionId&": Invalid state "&int2str(pl_stateIdx)&" in FSM "&v_LGenBase_fsmTables[pl_fsmTableIdx].name,
      -1 < pl_stateIdx and pl_stateIdx < sizeof(v_LGenBase_fsmTables[pl_fsmTableIdx].stateList));
    return v_LGenBase_fsmTables[pl_fsmTableIdx].stateList[pl_stateIdx] 
  }
  
}
///////////////////////////////////////////////////////////
//  Group: ListenerHandlingR3
// 
//  Purpose:
//    Functions to add, remove, activate and deactivate listeners 
///////////////////////////////////////////////////////////
group ListenerHandlingR3{
  ////////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_addListener
  // 
  //  Purpose:
  //    It is used to add an event listener to the list of listeners.
  //
  //  Parameters:
  //  - pl_event - *in* <EPTF_LGenBase_ReportableEventDescriptor> - the event to
  //    be listened to, must be a regular event with target field omit-ed, asserted
  //  - pl_descr - *in* <EPTF_LGenBase_EventListenerDescriptor> - the listener
  //    to be added
  //
  //  Return Value:
  //    - 
  //    index of the slot of the listener in the database 
  //
  //  Errors:
  //
  //  Detailed Comments:
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_addListener(
    in EPTF_LGenBase_EventListener_FT pl_fn,
    in EPTF_IntegerList pl_args
  )
  runs on EPTF_LGenBase_Private_CT
  return integer
  {
    if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
      f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId&" Adding listener ",pl_fn," with arguments ",pl_args))
    }
    //Find
    var integer vl_slot := -1;
    //Not added yet, must be added
    vl_slot := f_EPTF_FBQ_getOrCreateFreeSlot(v_LGenBase_listenersQueue)
    v_LGenBase_listeners[vl_slot] := {
      listener := {pl_fn, pl_args}/*,
      refCount := 1*/
    }
    f_EPTF_FBQ_moveFromFreeToBusyTail(vl_slot, v_LGenBase_listenersQueue);
    return vl_slot;
  }
  
  
  ////////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_removeListener
  // 
  //  Purpose:
  //    It is used to add an event listener to the list of listeners.
  //
  //  Parameters:
  //    - pl_idx - *in* *integer* - index of the slot of the listener in the database to be removed
  //    - pl_allRef - *in* *boolean* - The whole registration must be removed independently from the reference count
  ////////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_removeListener(in integer pl_idx)
  runs on EPTF_LGenBase_Private_CT
  {
    if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
      f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId,"DEBUG:","Removing listener ",pl_idx))
    }
    f_EPTF_FBQ_moveFromBusyToFreeHead(pl_idx, v_LGenBase_listenersQueue);
  }
  
}//ListenerHandlingR3

///////////////////////////////////////////////////////////
//  Group: Private
// 
//  Purpose:
//    Private functions 
///////////////////////////////////////////////////////////
group Private{
  
  group GetSet{
    ///////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_setDuration4TimerAtFsmCtx
    // 
    //  Purpose:
    //    Function to adjust timer values per FSM context
    //
    //  Parameters:
    //    - pl_eIdx - *in integer*  - the entity index, must be valid, asserted
    //    - pl_cCtxIdx - *in integer*  - the index of the fsm context of the 
    //      entity index, must be valid, asserted
    //    - pl_timerIdx - *in integer*  - the index of the timer within the FSM,
    //      must be valid, asserted
    //    - pl_duration - *in float *  - the new timeout value, 
    //      must be valid, asserted
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //  If the referred timer is already "running" (i.e., a respective
    //  <f_EPTF_LGenBase_TimerActionHandler> action is  scheduled in the event queue,
    //  then the timer is silently restarted, that is, cancelled then started.
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_setDuration4TimerAtFsmCtx(
      in integer pl_eIdx, //the entity
      in integer pl_fCtxIdx, //the FSM context
      in integer pl_timerIdx, //the respective timer
      in float pl_duration //the new value
    ) 
    runs on EPTF_LGenBase_Private_CT { 
      f_EPTF_Base_assert(%definitionId&" Entity index", 
        pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&" Referred FSM context index", 
        pl_fCtxIdx>=0 and pl_fCtxIdx<sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList));

      var integer   
      t:=v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx;
      f_EPTF_Base_assert(%definitionId&": referred FSM table index", t>=0 
        and t<sizeof(v_LGenBase_fsmTables)); 
      f_EPTF_Base_assert(%definitionId&": FSM timer index", pl_timerIdx>=0 
        and pl_timerIdx<sizeof(v_LGenBase_fsmTables[t].timerList));
      f_EPTF_Base_assert(%definitionId&": FSM timer duration < 0.0", 
        pl_duration>=0.0);
      v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerParams[pl_timerIdx].static.startValue := pl_duration;
      if (f_EPTF_LGenBase_isFSMDebugEnabled(pl_eIdx, pl_fCtxIdx, true)){
        f_EPTF_LGenBase_loggingDebugFSM(pl_eIdx, pl_fCtxIdx,
          log2str(%definitionId,": Timeout value has been set for timer ",v_LGenBase_fsmTables[t].timerList[pl_timerIdx].name,
            "\nof entity ",f_EPTF_LGenBase_getEntityName(pl_eIdx),
            "\n@ FsmCtx[", pl_fCtxIdx,"] to ",v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerParams[pl_timerIdx].static.startValue));
      }
    }

    ///////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_setDurations4TimerAtFsmCtx
    // 
    //  Purpose:
    //    Function to adjust timer values per FSM context
    //
    //  Parameters:
    //    - pl_eIdx - *in integer*  - the entity index, must be valid, asserted
    //    - pl_cCtxIdx - *in integer*  - the index of the fsm context of the 
    //      entity index, must be valid, asserted
    //    - pl_timerIdx - *in integer*  - the index of the timer within the FSM,
    //      must be valid, asserted
    //    - pl_minDuration - *in float *  - the new minimum timeout value, 
    //      must be valid, asserted
    //    - pl_maxDuration - *in float *  - the new maximum timeout value, 
    //      must be valid, asserted
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //  If the referred timer is already "running" (i.e., a respective
    //  <f_EPTF_LGenBase_TimerActionHandler> action is  scheduled in the event queue,
    //  then the timer is silently restarted, that is, cancelled then started.
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_setDurations4TimerAtFsmCtx(
      in integer pl_eIdx, //the entity
      in integer pl_fCtxIdx, //the FSM context
      in integer pl_timerIdx, //the respective timer
      in float pl_minDuration,
      in float pl_maxDuration //the new value
    ) 
    runs on EPTF_LGenBase_Private_CT { 
      f_EPTF_Base_assert(%definitionId&" Entity index", 
        pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&" Referred FSM context index", 
        pl_fCtxIdx>=0 and pl_fCtxIdx<sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList));

      var integer   
      t:=v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx;
      f_EPTF_Base_assert(%definitionId&": referred FSM table index", t>=0 
        and t<sizeof(v_LGenBase_fsmTables)); 
      f_EPTF_Base_assert(%definitionId&": FSM timer index", pl_timerIdx>=0 
        and pl_timerIdx<sizeof(v_LGenBase_fsmTables[t].timerList));
      f_EPTF_Base_assert(%definitionId&": FSM timer minDuration < 0.0", 
        pl_minDuration>=0.0);
      f_EPTF_Base_assert(%definitionId&": FSM timer maxDuration < 0.0", 
        pl_maxDuration>=0.0);
      f_EPTF_Base_assert(%definitionId&": FSM timer minDuration( "&float2str(pl_minDuration)&") > maxDuration("&float2str(pl_maxDuration)&") ",
        pl_minDuration<=pl_maxDuration);
      v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerParams[pl_timerIdx].random.timeoutMin := pl_minDuration;
      v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerParams[pl_timerIdx].random.timeoutMax := pl_maxDuration;
      if (f_EPTF_LGenBase_isFSMDebugEnabled(pl_eIdx, pl_fCtxIdx, true)){
        f_EPTF_LGenBase_loggingDebugFSM(pl_eIdx, pl_fCtxIdx,
          log2str(%definitionId,": Timeout min/max values has been set for timer ",v_LGenBase_fsmTables[t].timerList[pl_timerIdx].name,
            "\nof entity ",f_EPTF_LGenBase_getEntityName(pl_eIdx),
            "\n@ FsmCtx[", pl_fCtxIdx,"] to (",v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerParams[pl_timerIdx].random.timeoutMin,
            "..", v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerParams[pl_timerIdx].random.timeoutMax, ")."));
      }
    }

/*
    ///////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_setDuration4GaussTimerAtFsmCtx
    // 
    //  Purpose:
    //    Function to adjust Gauss timer values per FSM context
    //
    //  Parameters:
    //    - pl_eIdx - *in integer*  - the entity index, must be valid, asserted
    //    - pl_cCtxIdx - *in integer*  - the index of the fsm context of the 
    //      entity index, must be valid, asserted
    //    - pl_timerIdx - *in integer*  - the index of the timer within the FSM,
    //      must be valid, asserted
    //    - pl_mean - *in float *  - the new mean value, 
    //      must be valid, asserted
    //    - pl_deviation - *in float *  - the new deviation value, 
    //      must be valid, asserted
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //  If the referred timer is already "running" (i.e., a respective
    //  <f_EPTF_LGenBase_TimerActionHandler> action is  scheduled in the event queue,
    //  then the timer is silently restarted, that is, cancelled then started.
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_setDuration4GaussTimerAtFsmCtx(
      in integer pl_eIdx, //the entity
      in integer pl_fCtxIdx, //the FSM context
      in integer pl_timerIdx, //the respective timer
      in float pl_mean,
      in float pl_deviation
    ) 
    runs on EPTF_LGenBase_Private_CT { 
      f_EPTF_Base_assert(%definitionId&" Entity index", 
        pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&" Referred FSM context index", 
        pl_fCtxIdx>=0 and pl_fCtxIdx<sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList));

      var integer   
      t:=v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx;
      f_EPTF_Base_assert(%definitionId&": referred FSM table index", t>=0 
        and t<sizeof(v_LGenBase_fsmTables)); 
      f_EPTF_Base_assert(%definitionId&": FSM timer index", pl_timerIdx>=0 
        and pl_timerIdx<sizeof(v_LGenBase_fsmTables[t].timerList));
      f_EPTF_Base_assert(%definitionId&": FSM timer mean < 0.0", 
        pl_mean>=0.0);
      f_EPTF_Base_assert(%definitionId&": FSM timer deviation < 0.0", 
        pl_deviation>=0.0);

      v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerParams[pl_timerIdx].randomGauss.mean := pl_mean;
      v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerParams[pl_timerIdx].randomGauss.deviation := pl_deviation;
      if (f_EPTF_LGenBase_isFSMDebugEnabled(pl_eIdx, pl_fCtxIdx, true)){
        f_EPTF_LGenBase_loggingDebugFSM(pl_eIdx, pl_fCtxIdx,
          log2str(%definitionId,": Timeout mean and deviation values has been set for timer ",v_LGenBase_fsmTables[t].timerList[pl_timerIdx].name,
            "\nof entity ",f_EPTF_LGenBase_getEntityName(pl_eIdx),
            "\n@ FsmCtx[", pl_fCtxIdx,"] to ",v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerParams[pl_timerIdx].randomGauss.mean ,
            " and ", v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerParams[pl_timerIdx].randomGauss.deviation, " respectively."));
      }
    }
*/

    ///////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_setDuration4TimerAtFsmCtxByName
    // 
    //  Purpose:
    //    Function to adjust timer values per FSM context
    //
    //  Parameters:
    //    - pl_eIdx - *in integer*  - the entity index, must be valid, asserted
    //    - pl_cCtxIdx - *in integer*  - the index of the fsm context of the 
    //      entity index, must be valid, asserted
    //    - pl_timerName - *in charstring*  - the index of the timer within the FSM,
    //      must be valid, asserted
    //    - pl_duration - *in float *  - the new timeout value, 
    //      must be valid, asserted
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //  See also: <f_EPTF_LGenBase_setDuration4TimerAtFsmCtx>
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_setDuration4TimerAtFsmCtxByName(
      in integer pl_eIdx, //the entity
      in integer pl_fCtxIdx, //the FSM context
      in charstring pl_timerName, //the respective timer
      in float pl_duration //the new value
    ) 
    runs on EPTF_LGenBase_Private_CT { 
      f_EPTF_Base_assert(%definitionId&" Entity index", 
        pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&" Referred FSM context index", 
        pl_fCtxIdx>=0 and pl_fCtxIdx<sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList));

      var integer   
      t:=v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx;
      f_EPTF_Base_assert(%definitionId&": referred FSM table index", t>=0 
        and t<sizeof(v_LGenBase_fsmTables)); 

      var integer vl_timerIdx := f_EPTF_LGenBase_fsmTimerIdx(
        v_LGenBase_fsmTables[v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx].timerList, 
        pl_timerName) 
      f_EPTF_Base_assert(%definitionId&": Invalid timer name: "&pl_timerName, vl_timerIdx > -1);
      f_EPTF_LGenBase_setDuration4TimerAtFsmCtx(pl_eIdx, pl_fCtxIdx, vl_timerIdx, pl_duration) 
    }    

    ///////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_setDurations4TimerAtFsmCtxByName
    // 
    //  Purpose:
    //    Function to adjust timer values per FSM context
    //
    //  Parameters:
    //    - pl_eIdx - *in integer*  - the entity index, must be valid, asserted
    //    - pl_cCtxIdx - *in integer*  - the index of the fsm context of the 
    //      entity index, must be valid, asserted
    //    - pl_timerName - *in charstring*  - the index of the timer within the FSM,
    //      must be valid, asserted
    //    - pl_minDuration - *in float *  - the new minimal timeout value 
    //    - pl_maxDuration - *in float *  - the new maximal timeout value 
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //  See also: <f_EPTF_LGenBase_setDuration4TimerAtFsmCtx>
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_setDurations4TimerAtFsmCtxByName(
      in integer pl_eIdx, //the entity
      in integer pl_fCtxIdx, //the FSM context
      in charstring pl_timerName, //the respective timer
      in float pl_minDuration,
      in float pl_maxDuration
    ) 
    runs on EPTF_LGenBase_Private_CT { 
      f_EPTF_Base_assert(%definitionId&" Entity index", 
        pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&" Referred FSM context index", 
        pl_fCtxIdx>=0 and pl_fCtxIdx<sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList));

      var integer   
      t:=v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx;
      f_EPTF_Base_assert(%definitionId&": referred FSM table index", t>=0 
        and t<sizeof(v_LGenBase_fsmTables)); 

      var integer vl_timerIdx := f_EPTF_LGenBase_fsmTimerIdx(
        v_LGenBase_fsmTables[v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx].timerList, 
        pl_timerName) 
      f_EPTF_Base_assert(%definitionId&": Invalid timer name: "&pl_timerName, vl_timerIdx > -1);
      f_EPTF_LGenBase_setDurations4TimerAtFsmCtx(pl_eIdx, pl_fCtxIdx, vl_timerIdx, pl_minDuration, pl_maxDuration) 
    }

/*
    ///////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_setDuration4GaussTimerAtFsmCtxByName
    // 
    //  Purpose:
    //    Function to adjust timer values per FSM context
    //
    //  Parameters:
    //    - pl_eIdx - *in integer*  - the entity index, must be valid, asserted
    //    - pl_cCtxIdx - *in integer*  - the index of the fsm context of the 
    //      entity index, must be valid, asserted
    //    - pl_timerName - *in charstring*  - the index of the timer within the FSM,
    //      must be valid, asserted
    //    - pl_mean - *in float *  - the new mean value, 
    //      must be valid, asserted
    //    - pl_deviation - *in float *  - the new deviation value, 
    //      must be valid, asserted
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //  See also: <f_EPTF_LGenBase_setDuration4TimerAtFsmCtx>
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_setDuration4GaussTimerAtFsmCtxByName(
      in integer pl_eIdx, //the entity
      in integer pl_fCtxIdx, //the FSM context
      in charstring pl_timerName, //the respective timer
      in float pl_mean,
      in float pl_deviation
    ) 
    runs on EPTF_LGenBase_Private_CT { 
      f_EPTF_Base_assert(%definitionId&" Entity index", 
        pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&" Referred FSM context index", 
        pl_fCtxIdx>=0 and pl_fCtxIdx<sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList));

      var integer   
      t:=v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx;
      f_EPTF_Base_assert(%definitionId&": referred FSM table index", t>=0 
        and t<sizeof(v_LGenBase_fsmTables)); 

      var integer vl_timerIdx := f_EPTF_LGenBase_fsmTimerIdx(
        v_LGenBase_fsmTables[v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx].timerList, 
        pl_timerName) 
      f_EPTF_Base_assert(%definitionId&": Invalid timer name: "&pl_timerName, vl_timerIdx > -1);
      f_EPTF_LGenBase_setDuration4GaussTimerAtFsmCtx(pl_eIdx, pl_fCtxIdx, vl_timerIdx, pl_mean, pl_deviation) 
    }
*/

    ///////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_getDuration4TimerAtFsmCtx
    // 
    //  Purpose:
    //    Function to adjust timer values per FSM context
    //
    //  Parameters:
    //    - pl_eIdx - *in integer*  - the entity index, must be valid, asserted
    //    - pl_cCtxIdx - *in integer*  - the index of the fsm context of the 
    //      entity index, must be valid, asserted
    //    - pl_timerIdx - *in integer*  - the index of the timer within the FSM,
    //      must be valid, asserted
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //  If the referred timer is already "running" (i.e., a respective
    //  <f_EPTF_LGenBase_TimerActionHandler> action is  scheduled in the event queue,
    //  then the timer is silently restarted, that is, cancelled then started.
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_getDuration4TimerAtFsmCtx(
      in integer pl_eIdx, //the entity
      in integer pl_fCtxIdx, //the FSM context
      in integer pl_timerIdx //the respective timer
    ) 
    runs on EPTF_LGenBase_Private_CT
    return float{ 
      f_EPTF_Base_assert(%definitionId&" Entity index", 
        pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&" Referred FSM context index", 
        pl_fCtxIdx>=0 and pl_fCtxIdx<sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList));

      var integer   
      t:=v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx;
      f_EPTF_Base_assert(%definitionId&": referred FSM table index", t>=0 
        and t<sizeof(v_LGenBase_fsmTables)); 
      f_EPTF_Base_assert(%definitionId&": FSM timer index", pl_timerIdx>=0 
        and pl_timerIdx<sizeof(v_LGenBase_fsmTables[t].timerList));
      if(ischosen(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerParams[pl_timerIdx].static)){
        return v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerParams[pl_timerIdx].static.startValue;
      }else {
        f_EPTF_LGenBase_loggingWarning(%definitionId&": Unsupported timer parameter: "&
          log2str(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].timerParams[pl_timerIdx]));
        return 0.0;
      }
    }
    
    ///////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_getDuration4TimerAtFsmCtxByName
    // 
    //  Purpose:
    //    Function to adjust timer values per FSM context
    //
    //  Parameters:
    //    - pl_eIdx - *in integer*  - the entity index, must be valid, asserted
    //    - pl_cCtxIdx - *in integer*  - the index of the fsm context of the 
    //      entity index, must be valid, asserted
    //    - pl_timerIdx - *in integer*  - the index of the timer within the FSM,
    //      must be valid, asserted
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //  If the referred timer is already "running" (i.e., a respective
    //  <f_EPTF_LGenBase_TimerActionHandler> action is  scheduled in the event queue,
    //  then the timer is silently restarted, that is, cancelled then started.
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_getDuration4TimerAtFsmCtxByName(
      in integer pl_eIdx, //the entity
      in integer pl_fCtxIdx, //the FSM context
      in charstring pl_timerName //the respective timer
    ) 
    runs on EPTF_LGenBase_Private_CT
    return float{ 
      f_EPTF_Base_assert(%definitionId&" Entity index", 
        pl_eIdx>=0 and pl_eIdx<sizeof(v_LGenBase_entities));
      f_EPTF_Base_assert(%definitionId&" Referred FSM context index", 
        pl_fCtxIdx>=0 and pl_fCtxIdx<sizeof(v_LGenBase_entities[pl_eIdx].fsmCtxList));
      
      var integer   
      t:=v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx;
      f_EPTF_Base_assert(%definitionId&": referred FSM table index", t>=0 
        and t<sizeof(v_LGenBase_fsmTables)); 
      
      var integer vl_timerIdx := f_EPTF_LGenBase_fsmTimerIdx(
        v_LGenBase_fsmTables[v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx].timerList, 
        pl_timerName) 
      f_EPTF_Base_assert(%definitionId&": Invalid timer name: "&pl_timerName, vl_timerIdx > -1); 
      return f_EPTF_LGenBase_getDuration4TimerAtFsmCtx(pl_eIdx, pl_fCtxIdx, vl_timerIdx)  
    }
  }
  
  ////////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_checkEvents2Post
  // 
  //  Purpose:
  //    Gets the first event to be posted from the queue if there is,
  //    and posts it.
  //
  ////////////////////////////////////////////////////////////
  private function f_EPTF_LGenBase_checkEvents2Post() 
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_slot := -1;
    while ( f_EPTF_FBQ_getBusyHeadIdx(vl_slot, v_LGenBase_postedEventsQueue) )
    {
      f_EPTF_FBQ_moveFromBusyToInvalid(vl_slot, v_LGenBase_postedEventsQueue);
      f_EPTF_LGenBase_postEvent(v_LGenBase_postedEvents[vl_slot]);
      f_EPTF_FBQ_moveFromInvalidToFreeHead(vl_slot, v_LGenBase_postedEventsQueue);
    }
  }
  
  
  
  ///////////////////////////////////////////////////////////
  //  Group: PrivateListeners
  //  
  //  Purpose:
  //    Private functions which are used in built-in event dispatching functions 
  ///////////////////////////////////////////////////////////
  group PrivateListeners{
    
    private function f_EPTF_LGenBase_tableListenerWrapper (
      EPTF_LGenBase_ReportedEventDescriptor pl_event,
      EPTF_IntegerList pl_listenerArgs
    ) runs on EPTF_LGenBase_Private_CT {
      f_EPTF_Base_assert(%definitionId&" Length of pl_listenerArgs must be 3", 
        3==sizeof(pl_listenerArgs))
      f_EPTF_LGenBase_tableListener (pl_event,pl_listenerArgs[0],pl_listenerArgs[1],pl_listenerArgs[2])
    }
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_tableListener
    // 
    //  Purpose:
    //    Listener for FSM table-rows in case of General or Entity events
    //
    //  Parameters:
    //    - pl_event - *in* - <EPTF_LGenBase_EventDescriptor> - event descriptor,
    //      must be valid and regular,asserted
    //    - pl_args - *in* - EPTF_IntegerList - arguments, asserted 
    //       - args[0]==the entity Idx,
    //       - args[1]==the FSM ctx
    //       - args[2]==the row idx of the relevant event w.r.t the table
    //
    //  Return Value:
    //    -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //   Note, that no tableListener will be registered for FSM-level events,
    //   since FSM cells for such events will be fired by
    //   <f_EPTF_LGenBase_reportEvent4Fsm> directly
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_tableListener (
      in EPTF_LGenBase_ReportedEventDescriptor pl_event,
      in integer pl_eIdx,
      in integer pl_fCtxIdx,
      in integer pl_rowIdx,
      in integer pl_siblingRef := -1) 
    runs on EPTF_LGenBase_Private_CT {
      var integer b:= pl_event.event.bIdx, i:=pl_event.event.iIdx;
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId, ": Received_args:={ pl_event:=", pl_event,", entity:=", pl_eIdx,
            ",FSM ctx == ",pl_fCtxIdx,",Row == ",pl_rowIdx,",SiblingRef == ",pl_siblingRef,"}"))
      }
      var integer t:= v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].tableIdx 
      //,s:= v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].stateIdx;
      if (c_EPTF_Common_debugSwitch){
        f_EPTF_Base_assert(%definitionId&" Table index referred the by FSM context is"&int2str(t),
          t>=0 and t<sizeof(v_LGenBase_fsmTables)); 
        f_EPTF_Base_assert(%definitionId&" Referred FSM table row index", 
          pl_rowIdx>=0 and pl_rowIdx<sizeof(v_LGenBase_fsmTables[t].rows)); 
        //f_EPTF_Base_assert(%definitionId&" state index referred the by FSM context",
        //  s>=0 and s<sizeof(v_LGenBase_fsmTables[t].stateList));
      } 
      if (f_EPTF_LGenBase_isFSMDebugEnabled(pl_eIdx, pl_fCtxIdx)){
        f_EPTF_LGenBase_loggingDebugFSM(pl_eIdx, pl_fCtxIdx,
          log2str(%definitionId, ": Input fired for entity context ", v_LGenBase_entities[pl_eIdx],
            "\n==> event's behaviorIdx=",b,", that is, ", f_EPTF_LGenBase_bIdx2Str(b),
            "\n==> event's inputIdx:",i,", that is, ", f_EPTF_LGenBase_iIdx2Str(b,i),
            "\n==> FSM ctx to handle is the ",pl_fCtxIdx,"., that is, ", v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx],
            "\n==> event's FSM table:",t,", that is, ", v_LGenBase_fsmTables[t].name,
            //"\n==> entity's state w.pl_rowIdx.t the FSM table:",s,", that is, ",v_LGenBase_fsmTables[t].stateList[s],
            "\n==> row idx:",pl_rowIdx,
            "\n==> siblingRef:",pl_siblingRef))
      }
      
      if (pl_siblingRef>-1) {
        if (pl_eIdx != pl_event.event.source.eIdx) {
          return;
        }
        // get fsm ctxIdx from sibling index:
        var integer  vl_tcIdx := f_EPTF_LGenBase_tcIdxOfFSM(
          pl_eIdx,
          pl_fCtxIdx
        );
        if (vl_tcIdx<0) {
          f_EPTF_LGenBase_loggingError(%definitionId&": The row#"&
            log2str(pl_rowIdx)&
            " refers to sibling, but the FSM "&
            v_LGenBase_fsmTables[t].name& " is not joined to a traffic case.");
        }
        
        // Check if fsm ctxIdx matches the fsm ctxIdx of the sibling:
        var integer vl_siblingIdxOfFSM := f_EPTF_LGenBase_siblingIdxOfFSM(pl_eIdx,pl_fCtxIdx);
        var integer vl_siblingIdxToListen :=
        f_EPTF_LGenBase_siblingIdxOfRefInTC(
          vl_tcIdx,
          vl_siblingIdxOfFSM,
          pl_siblingRef)
        var integer vl_fsmCtxIdxOfSibling := f_EPTF_LGenBase_fsmCtxIdxOfSibling(
          pl_eIdx,
          vl_tcIdx,
          vl_siblingIdxToListen
        )
        if (f_EPTF_LGenBase_isFSMDebugEnabled(pl_eIdx, pl_fCtxIdx)){
          f_EPTF_LGenBase_loggingDebugFSM(pl_eIdx, pl_fCtxIdx,
            log2str(%definitionId, ": Checking the source of the event.",
              "\nSibling Idx of the FSM:",vl_siblingIdxOfFSM,
              "\nTraffic case:",v_LGenBase_trafficCases[vl_tcIdx].uniqueName,
              "\nsiblingRef:",pl_siblingRef,
              "\nExpected sibling idx:",vl_siblingIdxToListen,
              "\nExpected fsm ctx idx:",vl_fsmCtxIdxOfSibling,
              "\nFsm ctx idx of source:",pl_event.event.source.fsmCtxIdx,
              "\n"))
        }
        if ( vl_fsmCtxIdxOfSibling != pl_event.event.source.fsmCtxIdx) {
          return;
        }
      }
      
      f_EPTF_LGenBase_executeFsmCell(
        t,pl_rowIdx,
        pl_eIdx,pl_fCtxIdx,
        pl_event.reportedArgs,
        v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].stateIdx, //cannot use 's' here, since it is an inout
        pl_event
      ); 
      
    }
    
    
    
    ///////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_TimerActionHandler
    // 
    //  Purpose:
    //    Schedule-able action handler for managing timers of the FSM-s, as per
    //    <EPTF_Scheduler_ActionHandler> 
    //
    //  Parameters:
    //    - pl_action - <EPTF_ScheduledAction> - parameters as follows, asserted
    //      - pl_action.actionId[ <c_EPTF_LGenBase_actionArgIdx_timeoutEIdx> ] - entity index
    //      - pl_action.actionId[ <c_EPTF_LGenBase_actionArgIdx_timeoutFIdx> ] - the FSM context index
    //      - pl_action.actionId[ <c_EPTF_LGenBase_actionArgIdx_timeoutTIdx> ] - the timer local-index
    //    - pl_eventIndex - *integer* - Unused, see detailed comments
    //  Return Value:
    //    boolean==true - see Detailed comments
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //   The signature of this function is mandated by
    //   <EPTF_Scheduler_ActionHandler>. We consider the action as always successful.
    //
    ///////////////////////////////////////////////////////////
    friend function f_EPTF_LGenBase_TimerActionHandler(
      in EPTF_ScheduledAction pl_action, in integer pl_eventIndex) runs on EPTF_LGenBase_Private_CT
    return boolean{
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId,": action:=", pl_action,", eventIndex:", pl_eventIndex))
      }
      f_EPTF_Base_assert(%definitionId&" assumes 3 integers in actionId[]",
        sizeof(pl_action)==3)
      var integer vl_eIdx := pl_action.actionId[c_EPTF_LGenBase_actionArgIdx_timeoutEIdx],
      vl_fCtxIdx := pl_action.actionId[c_EPTF_LGenBase_actionArgIdx_timeoutFIdx],
      vl_tCtxIdx := pl_action.actionId[c_EPTF_LGenBase_actionArgIdx_timeoutTIdx]; 
      if (f_EPTF_LGenBase_isFSMDebugEnabled(vl_eIdx, vl_fCtxIdx, true)){
        f_EPTF_LGenBase_loggingDebugFSM(vl_eIdx, vl_fCtxIdx,
          %definitionId&": Timer "&
          v_LGenBase_fsmTables[v_LGenBase_entities[vl_eIdx].fsmCtxList[vl_fCtxIdx].tableIdx].timerList[vl_tCtxIdx].name&
          " in FSM#"&int2str(vl_fCtxIdx)&"("&v_LGenBase_fsmTables[v_LGenBase_entities[vl_eIdx].fsmCtxList[vl_fCtxIdx].tableIdx].name&
          ") of entity "&f_EPTF_LGenBase_getEntityName(vl_eIdx)&
          " timed out.")
      } 
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(%definitionId&": Timer "&
          v_LGenBase_fsmTables[v_LGenBase_entities[vl_eIdx].fsmCtxList[vl_fCtxIdx].tableIdx].timerList[vl_tCtxIdx].name&
          " in FSM#"&int2str(vl_fCtxIdx)&"("&v_LGenBase_fsmTables[v_LGenBase_entities[vl_eIdx].fsmCtxList[vl_fCtxIdx].tableIdx].name&
          ") of entity "&f_EPTF_LGenBase_getEntityName(vl_eIdx)&
          " timed out.")
      }
      v_LGenBase_entities[vl_eIdx].fsmCtxList[vl_fCtxIdx].timerData[vl_tCtxIdx] := -1;
      f_EPTF_LGenBase_privateDispatchEvent({
          {c_EPTF_LGenBase_specialBIdx_timerTimeout, vl_tCtxIdx,
            {vl_eIdx,vl_fCtxIdx},omit
          },{vl_tCtxIdx}},
        true, 
        c_EPTF_LGenBase_bIdx,
        c_EPTF_LGenBase_inputIdx_timerTimeout); 
      return true;
    }
    
    
    private function f_EPTF_LGenBase_privateDispatchEvent(
      in EPTF_LGenBase_ReportedEventDescriptor pl_event,
      in boolean pl_specialEvent,
      in integer pl_convertedBehavior,
      in integer pl_convertedInput) 
    runs on EPTF_LGenBase_Private_CT{
      if (c_EPTF_Common_debugSwitch){
        f_EPTF_Base_assert(%definitionId&": Behavior type index", 
          (pl_event.event.bIdx>=0 and pl_event.event.bIdx<sizeof(v_LGenBase_behaviorTypes))
          or (pl_event.event.bIdx == c_EPTF_LGenBase_specialBIdx_timerTimeout)
        );
        //FIXME The condition is errorous
        f_EPTF_Base_assert(%definitionId&": Event/input index: behavior: "&int2str(pl_event.event.bIdx)&", input: "&int2str(pl_event.event.iIdx), 
          pl_event.event.iIdx>=0 and 
          ( (//regular event
              pl_event.event.bIdx>=0 and pl_event.event.iIdx<sizeof(v_LGenBase_fsmEvents[pl_event.event.bIdx]))
            or (//special timeout event for FSMs
              pl_event.event.bIdx == c_EPTF_LGenBase_specialBIdx_timerTimeout 
              and ispresent(pl_event.event.target) and ispresent (pl_event.event.target.fsmCtxIdx)
              and pl_event.event.iIdx < sizeof(v_LGenBase_fsmTables[
                  v_LGenBase_entities[pl_event.event.target.eIdx].fsmCtxList[pl_event.event.target.fsmCtxIdx].tableIdx
                ].timerList) and
              pl_event.event.target.eIdx >=0 
              and pl_event.event.target.eIdx<sizeof(v_LGenBase_entities))
          )
        )
      }
      f_EPTF_LGenBase_getFSMDebugEnabled()
      v_LGenBase_reportEventIsRunning := v_LGenBase_reportEventIsRunning + 1;
      //Find the listener list by the key
      if(v_LGenBase_hasBehaviorListener and not pl_specialEvent){
        f_EPTF_LGenBase_reportEvent4Behavior(pl_event);  
      }
      if(not pl_specialEvent){
        f_EPTF_LGenBase_reportEvent4Generic(pl_event)
      }
      if (ispresent(pl_event.event.target)) {
        if (pl_event.event.target.eIdx >=0 
          and pl_event.event.target.eIdx<sizeof(v_LGenBase_entities)){
          if(not pl_specialEvent){
            f_EPTF_LGenBase_reportEvent4Entity(pl_event)
          }
          if(v_LGenBase_hasEntityIdxListener){
            f_EPTF_LGenBase_reportEvent4EntityIdx(pl_event);
          }
          if(v_LGenBase_hasBehaviorOfEntityListener and not pl_specialEvent){
            f_EPTF_LGenBase_reportEvent4BehaviorOfEntity(pl_event);
          }
          if (ispresent(pl_event.event.target.fsmCtxIdx)) {
            if (c_EPTF_Common_debugSwitch){
              f_EPTF_Base_assert(%definitionId&": FSM context index", 
                (pl_event.event.target.fsmCtxIdx>=0 
                  and pl_event.event.target.fsmCtxIdx<sizeof(v_LGenBase_entities[pl_event.event.target.eIdx].fsmCtxList)));
            }
            f_EPTF_LGenBase_reportEvent4Fsm(pl_event, pl_specialEvent, pl_convertedBehavior, pl_convertedInput);
            if(v_LGenBase_hasFSMOfEntityListener){
              f_EPTF_LGenBase_reportEvent4FSMOfEntity(pl_event);
            }
          }
        }
      }
      if (ispresent(pl_event.event.source) and
        pl_event.event.source.eIdx >=0 
        and pl_event.event.source.eIdx<sizeof(v_LGenBase_entities)){
        
        if(v_LGenBase_hasSourceEntityListener and not pl_specialEvent){
          f_EPTF_LGenBase_reportEvent4SourceEntity(pl_event);
        }
        if(v_LGenBase_hasSourceEntityIndexListener){
          f_EPTF_LGenBase_reportEvent4SourceEntityIndex(pl_event);
        }
        if(v_LGenBase_hasBehaviorOfSourceEntityListener and not pl_specialEvent){
          f_EPTF_LGenBase_reportEvent4BehaviorOfSourceEntity(pl_event);
        }
        if (ispresent(pl_event.event.source.fsmCtxIdx) and not pl_specialEvent) {
          f_EPTF_Base_assert(%definitionId&": FSM context index", 
            (pl_event.event.source.fsmCtxIdx>=0 
              and pl_event.event.source.fsmCtxIdx<sizeof(v_LGenBase_entities[pl_event.event.source.eIdx].fsmCtxList)));
          if(v_LGenBase_hasSourceFsmListener){
            f_EPTF_LGenBase_reportEvent4SourceFsm(pl_event);
          }
          if(v_LGenBase_hasFsmOfSourceEntityListener){
            f_EPTF_LGenBase_reportEvent4FsmOfSourceEntity(pl_event);
          }
        }
      }
      v_LGenBase_reportEventIsRunning := v_LGenBase_reportEventIsRunning - 1;
      if(0 == v_LGenBase_reportEventIsRunning){
        f_EPTF_LGenBase_checkEvents2Post();
      }
    }
  }//PrivateListeners
  
  group privateReportingFunctions{ 
    ///////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_reportEvent4Behavior
    // 
    //  Purpose:
    //    Report an event detected by an AppLib to the entity idx event listeners
    //
    //  Parameters:
    //    pl_event - *in* - <EPTF_LGenBase_EventDescriptor> - the event occured. 
    //
    //  Detailed Comments:
    //    No assertions, since it assumes that it is invoked via 
    //    <f_EPTF_LGenBase_dispatchEvent> that is assumed to perform the validation
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_reportEvent4Behavior(in EPTF_LGenBase_ReportedEventDescriptor pl_event) 
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_idx := -1;
      var boolean vl_hasListener := f_EPTF_FBQ_getBusyHeadIdx(vl_idx, v_LGenBase_behaviorTypes[pl_event.event.bIdx].listeners);
      while ( vl_hasListener )
      {
        var integer vl_listenerIdx := f_EPTF_FBQ_getQueueData(vl_idx, v_LGenBase_behaviorTypes[pl_event.event.bIdx].listeners, 0);
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
          f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Reporting event to listener of behavior "&v_LGenBase_behaviorTypes[pl_event.event.bIdx].name&". Listener: "&log2str(v_LGenBase_listeners[vl_listenerIdx].listener)))
        }
        v_LGenBase_listeners[vl_listenerIdx].listener.fn.apply(pl_event,v_LGenBase_listeners[vl_listenerIdx].listener.args);
        vl_hasListener := f_EPTF_FBQ_getFwdBusyItemIdx(vl_idx, v_LGenBase_behaviorTypes[pl_event.event.bIdx].listeners);
      }
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Reporting event to listener of behavior "&v_LGenBase_behaviorTypes[pl_event.event.bIdx].name&" finished."))
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_reportEvent4Generic
    // 
    //  Purpose:
    //    Report an event detected by an AppLib to the generic event listeners
    //
    //  Parameters:
    //    pl_event - *in* - <EPTF_LGenBase_EventDescriptor> - the event occured 
    //
    //  Return Value:
    //    -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //    No assertions, since it assumes that it is invoked via 
    //    <f_EPTF_LGenBase_dispatchEvent> that is assumed to perform the validation
    //
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_reportEvent4Generic(in EPTF_LGenBase_ReportedEventDescriptor pl_event) 
    runs on EPTF_LGenBase_Private_CT{
      var integer b:=pl_event.event.bIdx, i:= pl_event.event.iIdx;
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(%definitionId&" Reports input "&f_EPTF_LGenBase_bIdx2Str(b)&","&f_EPTF_LGenBase_iIdx2Str(b,i))
      }
      var integer vl_idx := -1;
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTrafficVerbose)){
        f_EPTF_LGenBase_loggingDebugTrafficVerbose(%definitionId&" TC FSM listeners for input "&
          f_EPTF_LGenBase_bIdx2Str(b)&","&f_EPTF_LGenBase_iIdx2Str(b,i)&
          ": "&log2str(v_LGenBase_genericTcListeners[b][i]))
      }
      var boolean vl_isListener := f_EPTF_FBQ_getBusyHeadIdx(vl_idx, v_LGenBase_genericTcListeners[b][i])
      while ( vl_isListener )
      {
        //TODO use constants!
        var integer vl_tcIdx := f_EPTF_FBQ_getQueueData(vl_idx, v_LGenBase_genericTcListeners[b][i], 0);
        var integer vl_siblingIdx := f_EPTF_FBQ_getQueueData(vl_idx, v_LGenBase_genericTcListeners[b][i], 1); // current
        var integer vl_rowIdx := f_EPTF_FBQ_getQueueData(vl_idx, v_LGenBase_genericTcListeners[b][i], 2);
        var integer vl_siblingRef := f_EPTF_FBQ_getQueueData(vl_idx, v_LGenBase_genericTcListeners[b][i], 3); // listen to
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTrafficVerbose)){
          f_EPTF_LGenBase_loggingDebugTrafficVerbose(" TC: "&log2str(vl_tcIdx)&"\nSiblingIdx: "&log2str(vl_siblingIdx)
            &"\nRow: "&log2str(vl_rowIdx)&"\nSiblingRef: "&log2str(vl_siblingRef)&
            "\nIdx in FBQ: "&log2str(vl_idx)&"\nTC: "&log2str(v_LGenBase_trafficCases[vl_tcIdx]))
        }
        var integer vl_eFirst := v_LGenBase_entityGroups[v_LGenBase_trafficCases[vl_tcIdx].eGroupBackref].eOffset
        var integer vl_eCount := v_LGenBase_entityGroups[v_LGenBase_trafficCases[vl_tcIdx].eGroupBackref].eCount
        for ( var integer vl_eIdx := 0; vl_eIdx < vl_eCount ; vl_eIdx := vl_eIdx+1 ){
          var integer vl_fCtxIdx := f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc(vl_eIdx, vl_tcIdx, vl_siblingIdx);
          if (c_EPTF_Common_debugSwitch){
            f_EPTF_Base_assert(%definitionId&": Invalid entity index:"&int2str(vl_eIdx), vl_eIdx>=0 and vl_eIdx<sizeof(v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList)); 
            f_EPTF_Base_assert(%definitionId&": There is no FSM context index in TC "&v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              ", entity#"&int2str(vl_eIdx)&" sibling#"&log2str(vl_siblingIdx)&".",
              -1 < vl_fCtxIdx); 
          }
          f_EPTF_LGenBase_tableListener(
            pl_event, 
            vl_eFirst + vl_eIdx,
            vl_fCtxIdx,
            vl_rowIdx,
            vl_siblingRef)
        }
        vl_isListener := f_EPTF_FBQ_getFwdBusyItemIdx(vl_idx, v_LGenBase_genericTcListeners[b][i])
      }
      vl_isListener := f_EPTF_FBQ_getBusyHeadIdx(vl_idx, v_LGenBase_genericEventListeners[b][i])
      while ( vl_isListener )
      {
        var integer vl_listenerIdx := f_EPTF_FBQ_getQueueData(vl_idx, v_LGenBase_genericEventListeners[b][i], 0);
        v_LGenBase_listeners[vl_listenerIdx].listener.fn.apply( pl_event, v_LGenBase_listeners[vl_listenerIdx].listener.args );
        vl_isListener := f_EPTF_FBQ_getFwdBusyItemIdx(vl_idx, v_LGenBase_genericEventListeners[b][i])
      }
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(%definitionId&" debug: finished reporting input "&f_EPTF_LGenBase_bIdx2Str(b)&","&f_EPTF_LGenBase_iIdx2Str(b,i))
      }
    }
    
    ///////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_reportEvent4Entity
    // 
    //  Purpose:
    //    Report an event detected by an AppLib to the entity  event listeners
    //
    //  Parameters:
    //    pl_event - *in* - <EPTF_LGenBase_EventDescriptor> - the event occured. 
    //    Must contain the 'target' field
    //
    //  Return Value:
    //    -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //    No assertions, since it assumes that it is invoked via 
    //    <f_EPTF_LGenBase_dispatchEvent> that is assumed to perform the validation
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_reportEvent4Entity(in EPTF_LGenBase_ReportedEventDescriptor pl_event) 
    runs on EPTF_LGenBase_Private_CT{
      var integer e:= pl_event.event.target.eIdx, b:=pl_event.event.bIdx, i:= pl_event.event.iIdx;
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Reports input "&f_EPTF_LGenBase_bIdx2Str(b)&","&f_EPTF_LGenBase_iIdx2Str(b,i)&
            ", for entity ",f_EPTF_LGenBase_getEntityName(e)))
      }
      var integer vl_slotIdx := -1
      var integer vl_eGrpIdx := f_EPTF_LGenBase_getEGrpOfEntity(e)
      var boolean vl_isTcListener := f_EPTF_FBQ_getBusyHeadIdx(vl_slotIdx, v_LGenBase_entityTcListeners[b][i])
      while ( vl_isTcListener )
      {
        var integer vl_tcIdx := f_EPTF_FBQ_getQueueData(vl_slotIdx, v_LGenBase_entityTcListeners[b][i], 0);
        var integer vl_siblingIdx := f_EPTF_FBQ_getQueueData(vl_slotIdx, v_LGenBase_entityTcListeners[b][i], 1); // current
        var integer vl_rowIdx := f_EPTF_FBQ_getQueueData(vl_slotIdx, v_LGenBase_entityTcListeners[b][i], 2);
        var integer vl_siblingRef := f_EPTF_FBQ_getQueueData(vl_slotIdx, v_LGenBase_entityTcListeners[b][i], 3); // listen to
        if (c_EPTF_Common_debugSwitch){
          f_EPTF_Base_assert(%definitionId&": Invalid traffic case index:"&int2str(vl_tcIdx), vl_tcIdx>=0 and vl_tcIdx<sizeof(v_LGenBase_trafficCases));
        } 
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
          f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Foud traffic case listening: "&f_EPTF_LGenBase_getTcUniqueNameByTcIdx(vl_tcIdx)))
          f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," EGrpIdx of TC: "&int2str(f_EPTF_LGenBase_getEGrpIdxOfTc(vl_tcIdx))&" EGrpIdx of entity: "&int2str(vl_eGrpIdx)))
        }
        if(f_EPTF_LGenBase_getEGrpIdxOfTc(vl_tcIdx) == vl_eGrpIdx){
          var integer vl_fCtxIdx := f_EPTF_LGenBase_fsmCtxIdxOfSibling(e, vl_tcIdx, vl_siblingIdx);
          if (c_EPTF_Common_debugSwitch){
            var integer vl_eIdx := f_EPTF_LGenBase_getERelIdx(e)
            f_EPTF_Base_assert(%definitionId&": Invalid entity index:"&int2str(vl_eIdx), vl_eIdx>=0 and vl_eIdx<sizeof(v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList)); 
            f_EPTF_Base_assert(%definitionId&": There is no FSM context index in TC "&v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
              ", entity#"&int2str(vl_eIdx)&" sibling#"&log2str(vl_siblingIdx)&".",
              -1 < vl_fCtxIdx); 
          }
          f_EPTF_LGenBase_tableListener(
            pl_event,
            e,
            vl_fCtxIdx,
            vl_rowIdx,
            vl_siblingRef)
        }
        vl_isTcListener := f_EPTF_FBQ_getFwdBusyItemIdx(vl_slotIdx, v_LGenBase_entityTcListeners[b][i])
      }
      var integer vl_listenerListIdx;
      if (f_EPTF_int2int_HashMap_Find (v_LGenBase_behaviorTypes[b].entityListenerHashmapRefs[i],
          e,
          vl_listenerListIdx)) {
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
          f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Found entity#",e," in list of listener lists. Listener list idx: ",vl_listenerListIdx))
        }
        var integer vl_idx := f_EPTF_Common_IndexArray_getFirstBusyIdx(v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx]);
        while ( 0 <= vl_idx )
        {
          var integer vl_listenerIdx := f_EPTF_Common_IndexArray_getElement(v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx],vl_idx);
          if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
            f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId,": Found entityListener[",vl_listenerIdx,"] of entity[",e,"]:=", v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx]))
          }
          v_LGenBase_listeners[vl_listenerIdx].listener.fn.apply(pl_event,v_LGenBase_listeners[vl_listenerIdx].listener.args);
          vl_idx := f_EPTF_Common_IndexArray_getNextBusyIdx(v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx],vl_idx);
        }
      }      
      //var EPTF_IntegerList args := v_LGenBase_entities[e].entityListenerList[thisListener].args;
      //v_LGenBase_entities[e].entityListenerList[thisListener].fn.apply(pl_event,args);
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," debug: finished reporting input[",b,"][",i,"]:=", v_LGenBase_fsmEvents[b][i],
            ", for entity ",f_EPTF_LGenBase_getEntityName(e)))
      }
    }
    
    ///////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_reportEvent4Fsm
    // 
    //  Purpose:
    //    Report an event detected by an AppLib to the FSM contexts
    //
    //  Parameters:
    //    pl_event - *in* - <EPTF_LGenBase_EventDescriptor> - the event occured, 
    //    must contain 'target' field  
    //
    //  Return Value:
    //    -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //    No assertions, since it assumes that it is invoked via 
    //    <f_EPTF_LGenBase_dispatchEvent> that is assumed to perform the validation
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_reportEvent4Fsm(in EPTF_LGenBase_ReportedEventDescriptor pl_event,
      in boolean pl_specialEvent,
      in integer pl_convertedBehavior,
      in integer pl_convertedInput) 
    runs on EPTF_LGenBase_Private_CT{
      var integer e:= pl_event.event.target.eIdx, 
      vl_bIdx:=pl_convertedBehavior, vl_inputIdx:= pl_convertedInput, f:=pl_event.event.target.fsmCtxIdx;
      var charstring vl_eventDesc := ""
      var charstring vl_bDesc := ""
      if (f_EPTF_LGenBase_isFSMDebugEnabled(e, f)){
        if(null != v_LGenBase_fsmEvents[vl_bIdx][vl_inputIdx].logFn){
          vl_eventDesc := v_LGenBase_fsmEvents[vl_bIdx][vl_inputIdx].logFn.apply(e,f,vl_inputIdx)
        }else{
          vl_eventDesc := f_EPTF_LGenBase_iIdx2Str(pl_event.event.bIdx,pl_event.event.iIdx,v_LGenBase_entities[e].fsmCtxList[f].tableIdx)
        }
        vl_bDesc := f_EPTF_LGenBase_bIdx2Str(pl_event.event.bIdx)
      }
      if(f_EPTF_FBQ_itemIsBusy(f, v_LGenBase_entities[e].fsmCtxQueue)){
        var integer vl_tableIdx:=v_LGenBase_entities[e].fsmCtxList[f].tableIdx;
        
        // 1: forward event to listeners
        var boolean vl_found := false;
        if(pl_specialEvent){
          var integer vl_spbIdx := pl_event.event.bIdx*-1
          if (f_EPTF_LGenBase_isFSMDebugEnabled(e, f)){
            f_EPTF_LGenBase_loggingDebugFSM(e, f, log2str(%definitionId,
                ": Reports special input ",vl_eventDesc,
                ",\n of behavior ",vl_bDesc,
                ",\n for entity ",f_EPTF_LGenBase_getEntityName(e),
                ",\n for FSM context[",f ,"]:=", v_LGenBase_entities[e].fsmCtxList[f],
                ",\n which refers FSM table:=",v_LGenBase_fsmTables[vl_tableIdx]))
          }
          if(isbound(v_LGenBase_spEventFSMXrefs[vl_spbIdx][pl_event.event.iIdx].singleFsm[vl_tableIdx])){
            for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_spEventFSMXrefs[vl_spbIdx][pl_event.event.iIdx].singleFsm[vl_tableIdx]) ; vl_i := vl_i+1 )
            {
              f_EPTF_LGenBase_executeFsmCell(
                vl_tableIdx,
                v_LGenBase_spEventFSMXrefs[vl_spbIdx][pl_event.event.iIdx].singleFsm[vl_tableIdx][vl_i].rowIdx, 
                //v_LGenBase_entities[e].fsmCtxList[f].stateIdx, //which table (ruleset), row, column
                e, //for entity e
                f, //in FSM ctx 
                pl_event.reportedArgs, //stepArgs
                v_LGenBase_entities[e].fsmCtxList[f].stateIdx, //store next state here
                pl_event
              );        
            }
            if (f_EPTF_LGenBase_isFSMDebugEnabled(e, f)){
              f_EPTF_LGenBase_loggingDebugFSM(e, f, log2str(%definitionId,
                  ": Finished reporting input[",vl_spbIdx,"][",pl_event.event.iIdx,"]:=", vl_eventDesc,
                  ", of behavior ",vl_bDesc,
                  ", for entity ",f_EPTF_LGenBase_getEntityName(e)))
            }
            vl_found := true 
          }
        }else{
          if (f_EPTF_LGenBase_isFSMDebugEnabled(e, f)){
            f_EPTF_LGenBase_loggingDebugFSM(e, f, log2str(%definitionId,
                ": Reports input[",vl_bIdx,"][",vl_inputIdx,"]:=",vl_eventDesc,
                ",\n of behavior ",vl_bDesc,
                ",\n for entity ",f_EPTF_LGenBase_getEntityName(e),
                ",\n for FSM context[",f ,"]:=", v_LGenBase_entities[e].fsmCtxList[f],
                ",\n which refers FSM table:=",v_LGenBase_fsmTables[vl_tableIdx]))
          }
          var integer  vl_tcIdx := f_EPTF_LGenBase_tcIdxOfFSM(
            e,
            f
          );
          if(isbound(v_LGenBase_behaviorTypes[vl_bIdx].fsmTableXRefDB[vl_inputIdx].singleFsm[vl_tableIdx])){
            for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_behaviorTypes[vl_bIdx].fsmTableXRefDB[vl_inputIdx].singleFsm[vl_tableIdx]) ; vl_i := vl_i+1 )
            {
              if (v_LGenBase_behaviorTypes[vl_bIdx].fsmTableXRefDB[vl_inputIdx].singleFsm[vl_tableIdx][vl_i].siblingRef>-1) {
                // siblingIdx is given in the listener
                // check entity index:
                
                if (pl_event.event.target.eIdx != pl_event.event.source.eIdx) {
                  continue;
                }
                // get fsm ctxIdx from sibling index:
                f_EPTF_Base_assert(%definitionId&": The row#"&
                  log2str(v_LGenBase_behaviorTypes[vl_bIdx].fsmTableXRefDB[vl_inputIdx].singleFsm[vl_tableIdx][vl_i].rowIdx)&
                  " refers to sibling, but the FSM "&
                  v_LGenBase_fsmTables[vl_tableIdx].name& " is not joined to a traffic case.",-1 < vl_tcIdx
                );
                
                // Check if fsm ctxIdx matches the fsm ctxIdx of the sibling:
                var integer vl_siblingIdxOfFSM := f_EPTF_LGenBase_siblingIdxOfFSM(e,f);
                //TODO assert
                var integer vl_siblingIdxToListen :=
                f_EPTF_LGenBase_siblingIdxOfRefInTC(
                  vl_tcIdx,
                  vl_siblingIdxOfFSM,
                  v_LGenBase_behaviorTypes[vl_bIdx].fsmTableXRefDB[vl_inputIdx].singleFsm[vl_tableIdx][vl_i].siblingRef)
                if (f_EPTF_LGenBase_fsmCtxIdxOfSibling(
                    e,
                    vl_tcIdx,
                    vl_siblingIdxToListen
                  ) != pl_event.event.source.fsmCtxIdx) {
                  continue;
                }
              }
              f_EPTF_LGenBase_executeFsmCell(
                vl_tableIdx,
                v_LGenBase_behaviorTypes[vl_bIdx].fsmTableXRefDB[vl_inputIdx].singleFsm[vl_tableIdx][vl_i].rowIdx,
                //v_LGenBase_entities[e].fsmCtxList[f].stateIdx, //which table (ruleset), row, column
                e, //for entity e
                f, //in FSM ctx 
                pl_event.reportedArgs, //stepArgs
                v_LGenBase_entities[e].fsmCtxList[f].stateIdx, //store next state here
                pl_event
              );        
            }
            if (f_EPTF_LGenBase_isFSMDebugEnabled(e, f)){
              f_EPTF_LGenBase_loggingDebugFSM(e, f, log2str(%definitionId,
                  ": Finished reporting input[",vl_bIdx,"][",vl_inputIdx,"]:=", vl_eventDesc,
                  ", of behavior ",vl_bDesc,
                  ", for entity ",f_EPTF_LGenBase_getEntityName(e)))
            }
            vl_found := true 
          }
          if(vl_tcIdx > -1) {
            var integer vl_siblingIdx:=v_LGenBase_entities[e].fsmCtxList[f].siblingIdx;
            if(isbound(v_LGenBase_behaviorTypes[vl_bIdx].fsmTableXRefDB[vl_inputIdx].fsmOfTc[vl_tcIdx][vl_siblingIdx])){
              for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_behaviorTypes[vl_bIdx].fsmTableXRefDB[vl_inputIdx].fsmOfTc[vl_tcIdx][vl_siblingIdx]) ; vl_i := vl_i+1 )
              {
                if (v_LGenBase_behaviorTypes[vl_bIdx].fsmTableXRefDB[vl_inputIdx].fsmOfTc[vl_tcIdx][vl_siblingIdx][vl_i].siblingRef>-1) {
                  // siblingIdx is given in the listener
                  // check entity index:
                  
                  if (pl_event.event.target.eIdx != pl_event.event.source.eIdx) {
                    continue;
                  }
                  // get fsm ctxIdx from sibling index:
                  f_EPTF_Base_assert(%definitionId&": The row#"&
                    log2str(v_LGenBase_behaviorTypes[vl_bIdx].fsmTableXRefDB[vl_inputIdx].fsmOfTc[vl_tcIdx][vl_siblingIdx][vl_i].rowIdx)&
                    " refers to sibling, but the FSM "&
                    v_LGenBase_fsmTables[vl_tableIdx].name& " is not joined to a traffic case.",-1 < vl_tcIdx
                  );
                  
                  // Check if fsm ctxIdx matches the fsm ctxIdx of the sibling:
                  var integer vl_siblingIdxOfFSM := f_EPTF_LGenBase_siblingIdxOfFSM(e,f);
                  //TODO assert
                  var integer vl_siblingIdxToListen :=
                  f_EPTF_LGenBase_siblingIdxOfRefInTC(
                    vl_tcIdx,
                    vl_siblingIdxOfFSM,
                    v_LGenBase_behaviorTypes[vl_bIdx].fsmTableXRefDB[vl_inputIdx].fsmOfTc[vl_tcIdx][vl_siblingIdx][vl_i].siblingRef)
                  if (f_EPTF_LGenBase_fsmCtxIdxOfSibling(
                      e,
                      vl_tcIdx,
                      vl_siblingIdxToListen
                    ) != pl_event.event.source.fsmCtxIdx) {
                    continue;
                  }
                }
                f_EPTF_LGenBase_executeFsmCell(
                  vl_tableIdx,
                  v_LGenBase_behaviorTypes[vl_bIdx].fsmTableXRefDB[vl_inputIdx].fsmOfTc[vl_tcIdx][vl_siblingIdx][vl_i].rowIdx,
                  //v_LGenBase_entities[e].fsmCtxList[f].stateIdx, //which table (ruleset), row, column
                  e, //for entity e
                  f, //in FSM ctx 
                  pl_event.reportedArgs, //stepArgs
                  v_LGenBase_entities[e].fsmCtxList[f].stateIdx, //store next state here
                  pl_event
                );        
              }
              if (f_EPTF_LGenBase_isFSMDebugEnabled(e, f)){
                f_EPTF_LGenBase_loggingDebugFSM(e, f, log2str(%definitionId,
                    ": Finished reporting input[",vl_bIdx,"][",vl_inputIdx,"].fsmOfTc[",vl_tcIdx,"][",vl_siblingIdx,"]:=", vl_eventDesc,
                    ", of behavior ",vl_bDesc,
                    ", for entity ",f_EPTF_LGenBase_getEntityName(e)))
              }
              vl_found := true 
            }
          }
        }
        
        // 2: check if catchall listener exist
        if (sizeof(v_LGenBase_fsmTables[vl_tableIdx].catchAllRowIdxList)>0){
          if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
            f_EPTF_LGenBase_loggingDebugEventDispatch(log2str("The following event:  ",f_EPTF_LGenBase_genericIds2KeyStr(vl_bIdx,vl_inputIdx), " is catched by catchall listener!"))
          }
          if (f_EPTF_LGenBase_isFSMDebugEnabled(e, f)){
            f_EPTF_LGenBase_loggingDebugFSM(e, f, log2str(%definitionId,
                ": Reports input[",vl_bIdx,"][",vl_inputIdx,"]:=",vl_eventDesc,
                ",\n of behavior ",vl_bDesc,
                ",\n for entity ",f_EPTF_LGenBase_getEntityName(e),
                ",\n for 'CatchAll' fields of FSM context[",f ,"]:=", v_LGenBase_entities[e].fsmCtxList[f],
                ",\n which refers FSM table:=",v_LGenBase_fsmTables[vl_tableIdx].name))
          }
          for ( var integer vl_row := 0; vl_row < sizeof(v_LGenBase_fsmTables[vl_tableIdx].catchAllRowIdxList) ; vl_row := vl_row+1 ){
            f_EPTF_LGenBase_executeFsmCell(
              vl_tableIdx,
              v_LGenBase_fsmTables[vl_tableIdx].catchAllRowIdxList[vl_row],
              //v_LGenBase_entities[e].fsmCtxList[f].stateIdx, 
              e, //for entity e
              f, //in FSM ctx 
              pl_event.reportedArgs, //stepArgs
              v_LGenBase_entities[e].fsmCtxList[f].stateIdx, //store next state here
              pl_event
            );        
          }
        }
        // 3: event listener and catchall listener not exist -> unhandled event
        else if (not vl_found) {
          if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
            f_EPTF_LGenBase_loggingDebugEventDispatch(log2str("The following event:  ",f_EPTF_LGenBase_genericIds2KeyStr(vl_bIdx,vl_inputIdx), " is unhandled!"))
          }
          if (f_EPTF_LGenBase_isFSMDebugEnabled(e, f)){
            f_EPTF_LGenBase_loggingDebugFSM(e, f, log2str(%definitionId,
                ": Reports unhandled input[",pl_event.event.bIdx,"][",pl_event.event.iIdx,"]:=",vl_eventDesc,
                ",\n of behavior ",f_EPTF_LGenBase_bIdx2Str(pl_event.event.bIdx),
                ",\n for entity ",f_EPTF_LGenBase_getEntityName(e),
                ",\n for FSM context[",f ,"]:=", v_LGenBase_entities[e].fsmCtxList[f],
                ",\n which refers FSM table:=",v_LGenBase_fsmTables[vl_tableIdx].name))
          }
          if(v_LGenBase_fsmTables[vl_tableIdx].debugLight and
            0 == sizeof(v_LGenBase_fsmTables[vl_tableIdx].unhandledEventRowIdxList)){
            var charstring vl_timerName := ""
            f_EPTF_LGenBase_loggingFsmDebugLight(log2str("DebugLight:FSM:"&v_LGenBase_fsmTables[vl_tableIdx].name&":Entity#"&int2str(e)&"#",
                "\nThere is no listener to",
                "\nInput: ",f_EPTF_LGenBase_iIdx2Str(pl_event.event.bIdx,pl_event.event.iIdx,vl_tableIdx),
                "\nBehavior: ",f_EPTF_LGenBase_bIdx2Str(pl_event.event.bIdx),
                "\nFSM ",v_LGenBase_fsmTables[vl_tableIdx].name,
                "\nin any state"))
          }
          for ( var integer vl_row := 0; vl_row < sizeof(v_LGenBase_fsmTables[vl_tableIdx].unhandledEventRowIdxList) ; vl_row := vl_row+1 ){
            f_EPTF_LGenBase_executeFsmCell(
              vl_tableIdx,
              v_LGenBase_fsmTables[vl_tableIdx].unhandledEventRowIdxList[vl_row],
              //v_LGenBase_entities[e].fsmCtxList[f].stateIdx,
              e, //for entity e
              f, //in FSM ctx 
              pl_event.reportedArgs, //stepArgs
              v_LGenBase_entities[e].fsmCtxList[f].stateIdx, //store next state here
              pl_event
            );        
          }
        }
      }else{
        f_EPTF_LGenBase_loggingWarning(%definitionId&": Event reporting request to an inactive FSM! Entity == "&int2str(e)&" fsmCtxIdx == "&int2str(f))
      }
    }
    
    //TODO move to private
    private function f_EPTF_LGenBase_siblingIdxOfFSM(
      in integer pl_eIdx,
      in integer pl_fCtxIdx
    ) runs on EPTF_LGenBase_Private_CT return integer {
      // TODO: assert
      return v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fCtxIdx].siblingIdx;
    }
    
    private function f_EPTF_LGenBase_siblingIdxOfRefInTC(
      in integer pl_tcIdx, 
      in integer pl_siblingIdxOfFSM, 
      in integer pl_siblingRef
    ) runs on EPTF_LGenBase_Private_CT return integer {
      // TODO: assert
      return v_LGenBase_trafficCases[pl_tcIdx].referredFsmIdxsInSiblings[pl_siblingIdxOfFSM][pl_siblingRef]
    }
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_executeFsmCell
    // 
    //  Purpose:
    //    Launches the functions (test steps) stored in a given
    //    FSM cell via its references 
    //
    //  Parameters:
    //    - pl_cell - *in* - <EPTF_LGenBase_FsmTableCellReference> reference to the cell
    //      to be executed, asserted
    //    - pl_eIdx - *in integer* - on behalf of the entity, asserted
    //    - pl_fIdx - *in integer* - the FSM ctx that the cell is executed w.r.t., mjust be valid 
    //    - pl_args - *in* - <EPTF_IntegerList> - test step arguments to
    //      be supplied to each test step in the cell
    //    - pl_nextState - *inout* - *integer* - the variable which is updated to
    //      the index of the next state. 
    //
    //  Return Value:
    //    -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //
    //  /////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_executeFsmCell(
      in integer vl_tableIdx, //specific table within the behaviorType, 2nd dimension in the FSMTableDataBase
      in integer r, //row index within the table, 3rd dimension in the FSMTableDataBase
      
      in integer e, //on behalf of the entity
      in integer f, //from FSM ctx
      in EPTF_IntegerList pl_stepArgs, //supply args to actions
      inout integer pl_nextState, //the index of the next state
      in EPTF_LGenBase_ReportedEventDescriptor pl_reportedEvent
    ) runs on EPTF_LGenBase_Private_CT  
    {
      var integer vl_state := v_LGenBase_entities[e].fsmCtxList[f].stateIdx
      var EPTF_CharstringList vl_actionList := {} //DebugLight
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId,": Executing cell:={",vl_tableIdx,",",r,",",vl_state,"} on behalf of entity:=", e))      
      }
      if(-1 < v_LGenBase_fsmTables[vl_tableIdx].rows[r].colIdxListByStates[vl_state]){
        var integer vl_cellIdx := v_LGenBase_fsmTables[vl_tableIdx].rows[r].colIdxListByStates[vl_state] //Column index from the state
        if (c_EPTF_Common_debugSwitch){
          f_EPTF_Base_assert(%definitionId&": FSM table index", vl_tableIdx>=0 and vl_tableIdx<sizeof(v_LGenBase_fsmTables)); 
          f_EPTF_Base_assert(%definitionId&": Row index for FSM table["&int2str(vl_tableIdx)&"]",r>=0 and r<sizeof(v_LGenBase_fsmTables[vl_tableIdx].rows)); 
          f_EPTF_Base_assert(%definitionId&": Column index for FSM table["&int2str(vl_tableIdx)&"]",vl_cellIdx>=0 and vl_cellIdx<sizeof(v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList));
        }
        if (f_EPTF_LGenBase_isFSMDebugEnabled(e, f)){
          f_EPTF_LGenBase_loggingDebugFSM(e, f,
            log2str(%definitionId,": Executing cell:={",vl_tableIdx,",",r,",",vl_cellIdx,"} on behalf of entity:=", e,
              "\ncell is FSM[",vl_tableIdx,"].rowList[",r,"][",vl_cellIdx,"]:=", v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx],
              "\ntable is:",v_LGenBase_fsmTables[vl_tableIdx].name,
              "\nstate is:",v_LGenBase_fsmTables[vl_tableIdx].stateList[vl_state]))
        }
        if (ispresent(v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx].actionList)) {
          if (f_EPTF_LGenBase_isFSMDebugEnabled(e, f)){
            f_EPTF_LGenBase_loggingDebugFSM(e, f,
              log2str(%definitionId,": actionList is present:", v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx].actionList))
          }
          for (var integer a:=0; a<sizeof(v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx].actionList); a:=a+1){
            if(v_LGenBase_fsmTables[vl_tableIdx].debugLight){
              vl_actionList[sizeof(vl_actionList)]:=
              f_replaceFirstOccurenceOfSubstring(
                f_replaceFirstOccurenceOfSubstring(
                  "Step name: "&log2str(v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx].actionList[a].step)&
                  " FSM context args: "&f_EPTF_LGenBase_intList2str(v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx].actionList[a].stepContextArgs)&
                  " Step args: "&f_EPTF_LGenBase_intList2str(pl_stepArgs),
                  "refers(", ""),
                ")", "")
            }
            if (f_EPTF_LGenBase_isFSMDebugEnabled(e, f)){
              f_EPTF_LGenBase_loggingDebugFSM(e, f,
                log2str(%definitionId,": executing action:=",v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx].actionList[a]))
            }
            v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx].actionList[a].step.apply(
              {e,{f,v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx].actionList[a].stepContextArgs}, 
                pl_stepArgs, pl_reportedEvent});
          }
        }
        
        //if there is next state calc method
        /*
        if(ispresent(v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].nextStateStack[vl_nextStateStackDepth].nextState)){
        pl_nextState := v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].nextStateStack[vl_nextStateStackDepth].nextState
        }
        */
        if (ispresent(v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx].nextStateCalculation)){
          if (f_EPTF_LGenBase_isFSMDebugEnabled(e, f)){
            f_EPTF_LGenBase_loggingDebugFSM(e, f,
              log2str(%definitionId,": nextStateCalculation is present:", v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx].nextStateCalculation))
          }
          
          pl_nextState := v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx].nextStateCalculation.fn.apply(e,f,
            v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx].nextStateCalculation.contextArgs, 
            {vl_tableIdx,r,vl_state},
            pl_stepArgs )
        } else if //there is next state
        (ispresent(v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx].nextState)){
          if (f_EPTF_LGenBase_isFSMDebugEnabled(e, f)){
            f_EPTF_LGenBase_loggingDebugFSM(e, f,
              log2str(%definitionId,": nextstate is present:", v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx].nextState))
          }
          pl_nextState := v_LGenBase_fsmTables[vl_tableIdx].rows[r].cellList[vl_cellIdx].nextState
        }
        //v_LGenBase_entities[pl_eIdx].fsmCtxList[pl_fIdx].nextStateStackDepth := vl_nextStateStackDepth - 1
        if (f_EPTF_LGenBase_isFSMDebugEnabled(e, f)){
          f_EPTF_LGenBase_loggingDebugFSM(e, f,
            log2str(%definitionId,": the next state is:",v_LGenBase_fsmTables[vl_tableIdx].stateList[pl_nextState]))
        }
        //-----
        // Debug Light
        //-----
        if(v_LGenBase_fsmTables[vl_tableIdx].debugLight){
          var charstring vl_logId := "DebugLight:FSM:"&
          v_LGenBase_fsmTables[vl_tableIdx].name&":Entity#"&int2str(e)&"#"
          f_EPTF_LGenBase_loggingFsmDebugLight(log2str(%definitionId,": "&vl_logId,
              "\nReported event: ",
              f_EPTF_LGenBase_iIdx2Str(pl_reportedEvent.event.bIdx, pl_reportedEvent.event.iIdx,vl_tableIdx),
              "\nBehavior ",f_EPTF_LGenBase_bIdx2Str(pl_reportedEvent.event.bIdx),
              "\nFSM: ",v_LGenBase_fsmTables[vl_tableIdx].name,
              "\nEntity#",e,"#",
              "\nCurrent state: ",v_LGenBase_fsmTables[vl_tableIdx].stateList[vl_state],
              "\nNext state: ",v_LGenBase_fsmTables[vl_tableIdx].stateList[pl_nextState],
              "\nExecuted test steps: ",vl_actionList))
          /*log(%definitionId,": "&vl_logId,"\nExecuted test steps:")
          for ( var integer vl_i := 0; vl_i < sizeof(vl_actionList) ; vl_i := vl_i+1 ){
          var charstring vl_actionLine := log2str(vl_actionList[vl_i])
          //vl_actionList
          }*/
        }
      }else{
        if(v_LGenBase_fsmTables[vl_tableIdx].debugLight and
          0 == sizeof(v_LGenBase_fsmTables[vl_tableIdx].unhandledEventRowIdxList)){
          f_EPTF_LGenBase_loggingFsmDebugLight(log2str("DebugLight:FSM:"&v_LGenBase_fsmTables[vl_tableIdx].name&":Entity#"&int2str(e)&"#",
              "\nThere is no listener to",
              "\nInput: ",f_EPTF_LGenBase_iIdx2Str(pl_reportedEvent.event.bIdx,pl_reportedEvent.event.iIdx,vl_tableIdx),
              "\nBehavior: ",f_EPTF_LGenBase_bIdx2Str(pl_reportedEvent.event.bIdx),
              "\nFSM ",v_LGenBase_fsmTables[vl_tableIdx].name,
              "\nState ",v_LGenBase_fsmTables[vl_tableIdx].stateList[vl_state]))
        }
      }
    } 
    
    private function f_EPTF_LGenBase_intList2str(in EPTF_IntegerList pl_lstIn)
    return charstring{
      var charstring vl_ret := "["
      for ( var integer vl_i := 0; vl_i < sizeof(pl_lstIn) ; vl_i := vl_i+1 ){
        if(vl_i > 0){
          vl_ret := vl_ret & ";"
        }
        vl_ret := vl_ret & int2str(pl_lstIn[vl_i])
      }
      vl_ret := vl_ret & "]"
      return vl_ret
    }
    //  /////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_reportEvent4EntityIdx
    // 
    //  Purpose:
    //    Report an event detected by an AppLib to the entity idx event listeners
    //
    //  Parameters:
    //    pl_event - *in* - <EPTF_LGenBase_EventDescriptor> - the event occured. 
    //
    //  Detailed Comments:
    //    No assertions, since it assumes that it is invoked via 
    //    <f_EPTF_LGenBase_dispatchEvent> that is assumed to perform the validation
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_reportEvent4EntityIdx(in EPTF_LGenBase_ReportedEventDescriptor pl_event) 
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_eIdx:= pl_event.event.target.eIdx;
      var integer vl_idx := f_EPTF_Common_IndexArray_getFirstBusyIdx(v_LGenBase_entities[vl_eIdx].entityIdxListenerList)
      while ( -1 < vl_idx )
      {
        var integer vl_listenerIdx := f_EPTF_Common_IndexArray_getElement(v_LGenBase_entities[vl_eIdx].entityIdxListenerList,vl_idx)
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
          f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Reporting event to listener of entity[",vl_eIdx,"]. Listener: ", v_LGenBase_listeners[vl_listenerIdx].listener))
        }
        v_LGenBase_listeners[vl_listenerIdx].listener.fn.apply(pl_event,v_LGenBase_listeners[vl_listenerIdx].listener.args);
        vl_idx := f_EPTF_Common_IndexArray_getNextBusyIdx(v_LGenBase_entities[vl_eIdx].entityIdxListenerList, vl_idx);
      }
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Reporting event to listener of entity[",vl_eIdx,"] finished"))
      }
    }
    
    private function f_EPTF_LGenBase_reportEvent4FSMOfEntity(inout EPTF_LGenBase_ReportedEventDescriptor pl_event) 
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_eIdx:= pl_event.event.target.eIdx;
      var integer vl_fIdx:= pl_event.event.target.fsmCtxIdx;
      var integer vl_idx := -1;
      if(f_EPTF_FBQ_itemIsBusy(vl_fIdx, v_LGenBase_entities[vl_eIdx].fsmCtxQueue)){
        var boolean vl_hasListener := 
        ispresent(v_LGenBase_entities[vl_eIdx].fsmCtxList[vl_fIdx].fsmOfTargetEntityListeners) and
        f_EPTF_FBQ_getBusyHeadIdx(vl_idx, v_LGenBase_entities[vl_eIdx].fsmCtxList[vl_fIdx].fsmOfTargetEntityListeners);
        while ( vl_hasListener )
        {
          var integer vl_listenerIdx := f_EPTF_FBQ_getQueueData(vl_idx, v_LGenBase_entities[vl_eIdx].fsmCtxList[vl_fIdx].fsmOfTargetEntityListeners, 0);
          if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
            f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Reporting event to listener of FSM #",vl_fIdx," of target entity #",vl_eIdx,". Listener: ", v_LGenBase_listeners[vl_listenerIdx].listener))
          }
          v_LGenBase_listeners[vl_listenerIdx].listener.fn.apply(pl_event,v_LGenBase_listeners[vl_listenerIdx].listener.args);
          vl_hasListener := f_EPTF_FBQ_getFwdBusyItemIdx(vl_idx, v_LGenBase_entities[vl_eIdx].fsmCtxList[vl_fIdx].fsmOfTargetEntityListeners);
        }
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
          f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Reporting event to listener of FSM #",vl_fIdx," of target entity #",vl_eIdx," finished"))
        }
      }
    }
    
    private function f_EPTF_LGenBase_reportEvent4BehaviorOfEntity(in EPTF_LGenBase_ReportedEventDescriptor pl_event) 
    runs on EPTF_LGenBase_Private_CT{
      var integer e:= pl_event.event.target.eIdx, b:=pl_event.event.bIdx;
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId,": Reports event to the listeners of behavior ",v_LGenBase_behaviorTypes[b].name,
            ", of entity ",f_EPTF_LGenBase_getEntityName(e)))
      }
      var integer vl_listenerListIdx;
      if (f_EPTF_int2int_HashMap_Find (v_LGenBase_behaviorTypes[b].behaviorOfEntityHashMap,
          e,
          vl_listenerListIdx)) {
        var integer vl_idx := f_EPTF_Common_IndexArray_getFirstBusyIdx(v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx]);
        while ( 0 <= vl_idx )
        {
          var integer vl_listenerIdx := f_EPTF_Common_IndexArray_getElement(v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx],vl_idx);
          if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
            f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId,": Found entityListener[",vl_listenerIdx,"] of entity[",e,"]:=", v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx]))
          }
          v_LGenBase_listeners[vl_listenerIdx].listener.fn.apply(pl_event,v_LGenBase_listeners[vl_listenerIdx].listener.args);
          vl_idx := f_EPTF_Common_IndexArray_getNextBusyIdx(v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx],vl_idx);
        }
      }      
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId,": Finished reporting event of behavior ",v_LGenBase_behaviorTypes[b].name,
            ", of entity ",f_EPTF_LGenBase_getEntityName(e)))
      }
    }
    
    ///////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_reportEvent4SourceEntity
    // 
    //  Purpose:
    //    Report an event detected by an AppLib to the entity  event listeners
    //
    //  Parameters:
    //    pl_event - *in* - <EPTF_LGenBase_EventDescriptor> - the event occured. 
    //    Must contain the 'target' field
    //
    //  Return Value:
    //    -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //    No assertions, since it assumes that it is invoked via 
    //    <f_EPTF_LGenBase_dispatchEvent> that is assumed to perform the validation
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_reportEvent4SourceEntity(in EPTF_LGenBase_ReportedEventDescriptor pl_event) 
    runs on EPTF_LGenBase_Private_CT{
      var integer e:= pl_event.event.source.eIdx, b:=pl_event.event.bIdx, i:= pl_event.event.iIdx;
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId,": reports input[",b,"][",i,"]:=", v_LGenBase_fsmEvents[b][i],
            ", for entity ",v_LGenBase_entities[e]))
      }
      var integer vl_listenerListIdx;
      if (not f_EPTF_int2int_HashMap_Find (v_LGenBase_behaviorTypes[b].generalSourceListenerHashmapRefs[i],
          e,
          vl_listenerListIdx)) {
        return
      }
      var integer vl_idx := f_EPTF_Common_IndexArray_getFirstBusyIdx(v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx]);
      while ( 0 <= vl_idx )
      {
        var integer vl_listenerIdx := f_EPTF_Common_IndexArray_getElement(v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx],vl_idx);
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
          f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId,": Found entityListener[",vl_listenerIdx,"] of source entity[",e,"]:=", v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx]))
        }
        v_LGenBase_listeners[vl_listenerIdx].listener.fn.apply(pl_event,v_LGenBase_listeners[vl_listenerIdx].listener.args);
        vl_idx := f_EPTF_Common_IndexArray_getNextBusyIdx(v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx], vl_idx);
      }
      //var EPTF_IntegerList args := v_LGenBase_entities[e].entityListenerList[thisListener].args;
      //v_LGenBase_entities[e].entityListenerList[thisListener].fn.apply(pl_event,args);
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Finished reporting input[",b,"][",i,"]:=", v_LGenBase_fsmEvents[b][i],
            ", from entity ",v_LGenBase_entities[e]))
      }
    }
    
    private function f_EPTF_LGenBase_reportEvent4SourceFsm(in EPTF_LGenBase_ReportedEventDescriptor pl_event) 
    runs on EPTF_LGenBase_Private_CT{
      var EPTF_IndexList vl_data;
      var integer vl_idx := -1;
      if(f_EPTF_FBQ_itemIsBusy(pl_event.event.source.fsmCtxIdx, v_LGenBase_entities[pl_event.event.source.eIdx].fsmCtxQueue)){
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
          f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId,": reporting input[",pl_event.event.bIdx,"][",pl_event.event.iIdx,"][",pl_event.event.source.eIdx,"][",pl_event.event.source.fsmCtxIdx,"]"))
        }
        var boolean vl_hasListener := 
        ispresent(v_LGenBase_entities[pl_event.event.source.eIdx].fsmCtxList[pl_event.event.source.fsmCtxIdx].fsmOfSourceFsmListeners) and 
        f_EPTF_FBQ_getBusyHeadIdx(vl_idx, v_LGenBase_entities[pl_event.event.source.eIdx].fsmCtxList[pl_event.event.source.fsmCtxIdx].fsmOfSourceFsmListeners);
        while ( vl_hasListener )
        {
          f_EPTF_FBQ_getQueueDidx(
            vl_idx, 
            v_LGenBase_entities[pl_event.event.source.eIdx].fsmCtxList[pl_event.event.source.fsmCtxIdx].fsmOfSourceFsmListeners,
            vl_data);
          //TODO create const
          if(vl_data[1] == pl_event.event.bIdx and vl_data[2] == pl_event.event.iIdx){
            //invoke listener
            v_LGenBase_listeners[vl_data[0]].listener.fn.apply( 
              pl_event, 
              v_LGenBase_listeners[vl_data[0]].listener.args );
          }
          vl_hasListener := f_EPTF_FBQ_getFwdBusyItemIdx(vl_idx, v_LGenBase_entities[pl_event.event.source.eIdx].fsmCtxList[pl_event.event.source.fsmCtxIdx].fsmOfSourceFsmListeners);
        }
      }
    }
    
    ///////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_reportEvent4SourceEntityIndex
    //  
    //  Purpose:
    //    Report an event detected by an AppLib to the entity idx event listeners
    //
    //  Parameters:
    //    pl_event - *in* - <EPTF_LGenBase_EventDescriptor> - the event occured.  
    //
    //  Detailed Comments  :
    //    No assertions, since it assumes that it is invoked via  
    //    <f_EPTF_LGenBase_dispatchEvent> that is assumed to perform the validation
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_reportEvent4SourceEntityIndex(in EPTF_LGenBase_ReportedEventDescriptor pl_event)  
    runs on EPTF_LGenBase_Private_CT  {
      var integer vl_eIdx:= pl_event.event.source.eIdx;
      var integer vl_idx := f_EPTF_Common_IndexArray_getFirstBusyIdx(v_LGenBase_entities[vl_eIdx].sourceEntityListenerList);
      while ( 0 <= vl_idx )
      {
        var integer vl_listenerIdx := f_EPTF_Common_IndexArray_getElement(v_LGenBase_entities[vl_eIdx].sourceEntityListenerList,vl_idx);
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
          f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Reporting event to listener of source entity[",vl_eIdx,"]. Listener: ", v_LGenBase_listeners[vl_listenerIdx].listener))
        }
        v_LGenBase_listeners[vl_listenerIdx].listener.fn.apply(pl_event,v_LGenBase_listeners[vl_listenerIdx].listener.args);
        vl_idx := f_EPTF_Common_IndexArray_getNextBusyIdx(v_LGenBase_entities[vl_eIdx].sourceEntityListenerList,vl_idx);
      }
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Reporting event to listener of source entity[",vl_eIdx,"] finished"))
      }
    }
    
    private function f_EPTF_LGenBase_reportEvent4FsmOfSourceEntity(in EPTF_LGenBase_ReportedEventDescriptor pl_event)  
    runs on EPTF_LGenBase_Private_CT  {
      var integer vl_eIdx:= pl_event.event.source.eIdx;
      var integer vl_fIdx:= pl_event.event.source.fsmCtxIdx;
      var integer vl_idx := -1;
      if(f_EPTF_FBQ_itemIsBusy(vl_fIdx, v_LGenBase_entities[vl_eIdx].fsmCtxQueue)){
        var boolean vl_hasListener := 
        ispresent(v_LGenBase_entities[vl_eIdx].fsmCtxList[vl_fIdx].fsmOfSourceEntityListeners) and
        f_EPTF_FBQ_getBusyHeadIdx(vl_idx, v_LGenBase_entities[vl_eIdx].fsmCtxList[vl_fIdx].fsmOfSourceEntityListeners);
        while ( vl_hasListener )
        {
          var integer vl_listenerIdx := f_EPTF_FBQ_getQueueData(vl_idx, v_LGenBase_entities[vl_eIdx].fsmCtxList[vl_fIdx].fsmOfSourceEntityListeners, 0);
          if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
            f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Reporting event to listener of FSM #",vl_fIdx," of source entity #",vl_eIdx,". Listener: ", v_LGenBase_listeners[vl_listenerIdx].listener))
          }
          v_LGenBase_listeners[vl_listenerIdx].listener.fn.apply(pl_event,v_LGenBase_listeners[vl_listenerIdx].listener.args);
          vl_hasListener := f_EPTF_FBQ_getFwdBusyItemIdx(vl_idx, v_LGenBase_entities[vl_eIdx].fsmCtxList[vl_fIdx].fsmOfSourceEntityListeners);
        }
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
          f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Reporting event to listener of FSM #",vl_fIdx," of source entity #",vl_eIdx," finished"))
        }
      }
    }   
    
    private function f_EPTF_LGenBase_reportEvent4BehaviorOfSourceEntity(in EPTF_LGenBase_ReportedEventDescriptor pl_event)  
    runs on EPTF_LGenBase_Private_CT  {
      var integer e:= pl_event.event.source.eIdx, b:=pl_event.event.bIdx;
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Reports event to the listeners of behavior ",v_LGenBase_behaviorTypes[b].name,
            ", of source entity ",f_EPTF_LGenBase_getEntityName(e)))
      }
      var integer vl_listenerListIdx;
      if (f_EPTF_int2int_HashMap_Find (v_LGenBase_behaviorTypes[b].behaviorOfSourceHashMap,
          e,
          vl_listenerListIdx)) {
        var integer vl_idx := f_EPTF_Common_IndexArray_getFirstBusyIdx(v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx]);
        while ( 0 <= vl_idx )
        {
          var integer vl_listenerIdx := f_EPTF_Common_IndexArray_getElement(v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx],vl_idx);
          if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
            f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId,": found entityListener[",vl_listenerIdx,"] of entity[",e,"]:=", v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx]))
          }
          v_LGenBase_listeners[vl_listenerIdx].listener.fn.apply(pl_event,v_LGenBase_listeners[vl_listenerIdx].listener.args);
          vl_idx := f_EPTF_Common_IndexArray_getNextBusyIdx(v_LGenBase_entities[e].entityListenerLists[vl_listenerListIdx],vl_idx);
        }
      }         
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugEventDispatch)){
        f_EPTF_LGenBase_loggingDebugEventDispatch(log2str(%definitionId," Finished reporting event of behavior ",v_LGenBase_behaviorTypes[b].name,
            ", of entity ",f_EPTF_LGenBase_getEntityName(e)))
      }
    }
    
  }//group privateReportingFunctions
}//group Private

}  // end of module
