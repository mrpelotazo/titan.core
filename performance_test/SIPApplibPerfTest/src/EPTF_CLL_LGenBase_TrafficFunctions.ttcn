/******************************************************************************
 * Copyright (c) 2000-2018 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v2.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/org/documents/epl-2.0/EPL-2.0.html
 ******************************************************************************///  File:     EPTF_CLL_LGenBase_TrafficFunctions.ttcn
//  Rev:      <RnXnn>
//  Prodnr:   CNL 113 512
//  Updated:  2012-02-20
//  Contact:  http://ttcn.ericsson.se
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
//  Module: EPTF_CLL_LGenBase_TrafficFunctions
//
//  Purpose:
//    This module provides functions for traffic management in TitanSim
//    load generators
//
//  Module Parameters:
//    -
//
//  Module depends on:
//    <EPTF_CLL_Base_Functions>
//    <EPTF_CLL_Common_Definitions>
//    <EPTF_CLL_LGenBase_Definitions>
//    <EPTF_CLL_LGenBase_ConfigDefinitions>
//    <EPTF_CLL_LGenBase_ConfigFunctions>
//    <EPTF_CLL_LGenBase_PhaseDefinitions>
//    <EPTF_CLL_LGenBase_PhaseFunctions>
//    <EPTF_CLL_LGenBase_EventHandlingFunctions>
//    <EPTF_CLL_Scheduler_Definitions>
//    <EPTF_CLL_RBTScheduler_Functions>
//    <EPTF_CLL_FBQ_Definitions>
//    <EPTF_CLL_FBQ_Functions>
//    <EPTF_CLL_RNA_Definitions>
//    <EPTF_CLL_RNA_Functions>
//    <EPTF_CLL_HashMapInt2Int_Functions>
//    <EPTF_CLL_HashMapStr2Int_Functions>
//    <EPTF_CLL_LGenBaseTrafficMixer_Definitions>
//    <EPTF_CLL_LGenBaseTrafficMixer_Functions>
//    <TCCMaths_Functions>
//
//  Current Owner:
//    ELSZSKU
//
//  Last Review Date:
//    2008-
//
//  Detailed Comments:
//
///////////////////////////////////////////////////////////
module EPTF_CLL_LGenBase_TrafficFunctions
{
import from EPTF_CLL_Base_Functions all;
import from EPTF_CLL_Common_Definitions all;
import from EPTF_CLL_LGenBase_Definitions all;
import from EPTF_CLL_LGenBase_ConfigDefinitions all;
import from EPTF_CLL_LGenBase_ConfigFunctions all;
import from EPTF_CLL_LGenBase_EventHandlingFunctions all;
import from EPTF_CLL_Scheduler_Definitions all;
import from EPTF_CLL_RBTScheduler_Functions all;
import from EPTF_CLL_FBQ_Definitions all;
import from EPTF_CLL_FBQ_Functions all;
import from EPTF_CLL_RNA_Definitions all;
import from EPTF_CLL_RNA_Functions all;
import from EPTF_CLL_HashMapInt2Int_Functions all;
import from EPTF_CLL_HashMapStr2Int_Functions all;
import from EPTF_CLL_LGenBaseTrafficMixer_Definitions all;
import from EPTF_CLL_LGenBaseTrafficMixer_Functions all;
import from EPTF_CLL_LGenBaseStats_Definitions all;
import from TCCMaths_Functions all;
import from EPTF_CLL_LGenBase_TemplateFunctions all;
import from EPTF_CLL_LGenBase_LoggingFunctions all;
import from EPTF_CLL_Variable_Functions all;
import from EPTF_CLL_Variable_Definitions all
import from EPTF_CLL_StatMeasure_Functions all
import from EPTF_CLL_StatHandler_Functions all

import from EPTF_CLL_LGenBase_ILog_Functions all;

friend module EPTF_CLL_LGenBase_Functions;
friend module EPTF_CLL_LGenBase_StepFunctions;

///////////////////////////////////////////////////////////
//  Group: BurstCalculation
//
//  Purpose:
//    The EPTF_LGenBase functions related to the traffic calculation
///////////////////////////////////////////////////////////
group BurstCalculation{
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setBurstCalcAlgByIdx
  //
  //  Purpose:
  //   Assign a burst calculation method to the traffic cases or weighted scenarios
  //
  //  Parameters:
  //  pl_burstIdx - *in* *integer* - The index of the burst function
  //  pl_idx - *in* - <EPTF_LGenBase_TcMgmt_AbsIdx> - Union of a traffic case index or a weighted scenario index
  //
  //  Return Value:
  //    *boolean* - If there is a running traffic case, returns false.
  //
  //  Errors & assertions:
  //    -
  //
  //  Detailed Comments:
  //    This function can be used to assign the burst calculation method to a specified traffic case or a weighted scenario.
  //    The parameter <pl_burstIdx> is the index of the burst calculation algorithm. It can be a predefined algorithm such as orig, imst2, imst2, cs, poisson
  //    or a user defined one, defined by <f_EPTF_LGenBase_addBurstCalcFunction>.
  //    The traffic case index or the weighted scenario index should set.
  //    The normal traffic case can be referred by its traffic case index. The weighted scenario can be referred by its global scenario index.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setBurstCalcAlgByIdx(
    in integer pl_burstIdx,
    in EPTF_LGenBase_TcMgmt_AbsIdx pl_idx)
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    
    var boolean vl_isWeighted := false;
    //var boolean vl_returnValue := true;
    
    
    if(ischosen(pl_idx.tcIdx)) { // normal traffic case
      vl_isWeighted := false;
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_idx.tcIdx > -1 and pl_idx.tcIdx < sizeof(v_LGenBase_trafficCases));
      if(f_EPTF_LGenBase_checkSchedulingTimerIsRunning(pl_idx.tcIdx)){
        f_EPTF_LGenBase_loggingError(%definitionId&"Traffic case is running. The burst calculation method can not be set.");
        return false;
      }
      f_EPTF_LGenBase_setBurstCalcAlgInternal(pl_burstIdx, pl_idx.tcIdx, vl_isWeighted);
      
    } else if(ischosen(pl_idx.scIdx)){ // weighted scenario
      vl_isWeighted := true;
      f_EPTF_LGenBase_setBurstCalcAlgInternal(pl_burstIdx, pl_idx.scIdx, vl_isWeighted);
    } else {
      // a bit paranoia
      return false;
    }
    
    return true //vl_returnValue;
  }
  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setBurstCalcAlgByName
  //
  //  Purpose:
  //   Assign a burst calculation method to the traffic cases or weighted scenarios
  //
  //  Parameters:
  //    pl_funcName - *in* - *charstring* - The name of burst calculation
  //    pl_eGrpName - *in* - *charstring* - entity group name
  //    pl_scName - *in* - *charstring* - scenario name
  //    pl_tcName - *in* - *charstring* - traffic case name(optional)
  //
  //  Return Value:
  //    *boolean* - If there is a running traffic case, returns false.
  //
  //  Errors & assertions:
  //    -
  //
  //  Detailed Comments:
  //    This function can be used to assign the burst calculation method to a specified traffic case or a weighted scenario.
  //    The parameter <pl_funcName> is the name of the burst calculation algorithm. It can be a predefined algorithm such as orig, imst2, imst2, cs, poisson
  //    or a user defined one, defined by <f_EPTF_LGenBase_addBurstCalcFunction>.
  //    The traffic case can be referred by its entity group name, scenario name and traffic case name.
  //    If traffic case name is not set, then we are assume that the method should be assigned to a weighted scenario.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setBurstCalcAlgByName(
    in charstring pl_funcName,
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName := "")
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    
    var integer vl_idx;
    var integer vl_burstIdx;
    var boolean vl_isWeighted := false;
    var boolean vl_returnValue := true;
    
    vl_burstIdx := f_EPTF_LGenBase_getBurstCalcFunctionId(pl_funcName);
    if(vl_burstIdx == -1) {
      f_EPTF_LGenBase_loggingError(%definitionId&"This burst calculation method "&pl_funcName&" cannot be found. ");
      //f_EPTF_Base_assert(%definitionId&"This burst calculation method cannot be found.",false);
      return false;
    }
    
    if("" != pl_tcName) { // normal traffic case
      vl_idx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName);
      vl_isWeighted := false;
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",vl_idx > -1 and vl_idx < sizeof(v_LGenBase_trafficCases));
      if(f_EPTF_LGenBase_checkSchedulingTimerIsRunning(vl_idx)){
        f_EPTF_LGenBase_loggingError(%definitionId&"Traffic case is running. The burst calculation method can not be set.");
        return false;
      }
    } else { // weighted scenario
      vl_isWeighted := true;
      vl_idx := f_EPTF_LGenBase_scenarioAbsIdxByName(pl_eGrpName, pl_scName);
    }
    
    f_EPTF_LGenBase_setBurstCalcAlgInternal(vl_burstIdx,vl_idx,vl_isWeighted);
    
    return vl_returnValue;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getBurstCalcAlgByIdx
  //
  //  Purpose:
  //    Gets the bust calculation method of a traffic case or a weighted scenario
  //
  //  Parameters:
  //  pl_idx - *in* - <EPTF_LGenBase_TcMgmt_AbsIdx> - Union of a traffic case index or a weighted scenario index
  //
  //  Return Value:
  //    *integer* - The index of the used burst function
  //
  //  Detailed Comments:
  //    This function returns the index of the burst calculation function assigned to a traffic case.
  //    The normal traffic case can be referred by its traffic case index, the weighted scenario can be referred by its global scenario index.
  //    If traffic case ID is -1, then it returns the global burst calculation method.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getBurstCalcAlgByIdx (
    in EPTF_LGenBase_TcMgmt_AbsIdx pl_idx)
  runs on EPTF_LGenBase_Private_CT
  return integer
  {
    var charstring vl_name;
    if(ischosen(pl_idx.tcIdx)) { // normal traffic case
      if(pl_idx.tcIdx == -1) {
        vl_name := v_LGenBase_burstCalcMode;
      } else {
        f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_idx.tcIdx > -1 and pl_idx.tcIdx < sizeof(v_LGenBase_trafficCases));
        vl_name := v_LGenBase_trafficCases[pl_idx.tcIdx].schedulerData.burstFuncRef.burstCalcMode;
      }
      
    } else if(ischosen(pl_idx.scIdx)){ // weighted scenario
      var integer vl_eGrpIdx;
      var integer vl_scInGrpIdx;
      f_EPTF_LGenBase_scenarioRelIdx(pl_idx.scIdx, vl_eGrpIdx, vl_scInGrpIdx);
      vl_name := v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].schedulerData.burstFuncRef.burstCalcMode;
      
    } else {
      // a bit paranoia
      return -1;
    }
    
    return f_EPTF_LGenBase_getBurstCalcFunctionId(vl_name);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getBurstCalcAlgByName
  //
  //  Purpose:
  //    Gets the bust calculation method of a traffic case or a weighted scenario
  //
  //  Parameters:
  //    pl_eGrpName - *in* - *charstring* - entity group name
  //    pl_scName - *in* - *charstring* - scenario name
  //    pl_tcName - *in* - *charstring* - traffic case name(optional)
  //
  //  Return Value:
  //    *integer* - The index of the used burst function
  //
  //  Detailed Comments:
  //    This function returns the index of the burst calculation function assigned to a traffic case.
  //    The traffic case can be referred by its entity group name, scenario name and traffic case name.
  //    If traffic case name is not set, then we are assume that the method should be assigned to a weighted scenario.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getBurstCalcAlgByName (
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName := "")
  runs on EPTF_LGenBase_Private_CT
  return integer
  {
    
    var integer vl_idx;
    var charstring vl_name;
    
    if("" != pl_tcName) { // normal traffic case
      vl_idx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName);
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",vl_idx > -1 and vl_idx < sizeof(v_LGenBase_trafficCases));
      vl_name := v_LGenBase_trafficCases[vl_idx].schedulerData.burstFuncRef.burstCalcMode;
      
    } else { // weighted scenario
      var integer vl_eGrpIdx;
      var integer vl_scInGrpIdx;
      vl_idx := f_EPTF_LGenBase_scenarioAbsIdxByName(pl_eGrpName, pl_scName);
      f_EPTF_LGenBase_scenarioRelIdx(vl_idx, vl_eGrpIdx, vl_scInGrpIdx);
      vl_name := v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].schedulerData.burstFuncRef.burstCalcMode;
    }
    
    return f_EPTF_LGenBase_getBurstCalcFunctionId(vl_name);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_addBurstCalcFunction
  //
  //  Purpose:
  //    Saves a user defined burst calculation method and its function references to a list.
  //
  //  Parameters:
  //    pl_funcName - *in* - *charstring* - The name of burst calculation
  //    pl_preCalcFunc - *in* <EPTF_LGenBase_burstPreCalc_FT> - The burst precalculation function reference
  //    pl_postCalcFunc - *in* <EPTF_LGenBase_burstPostCalc_FT> - The burst postcalculation function reference
  //
  //  Return Value:
  //    *integer* - The index of the burst calculation function
  //
  //  Errors & assertions:
  //    -
  //
  //  Detailed Comments:
  //    The function saves a user defined burst calculation method and its function references.
  //    The burst calculation method won't be assigned to any traffic case.
  //    This saved method can be accessed by its name or ID later, so the name of the method must be unique.
  //    If there is an error occurred the return value will be -1.
  //    Note: We assume there will be only a few user defined methods, so defined methods cannot be deleted later.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_addBurstCalcFunction(
    in charstring pl_funcName,
    in EPTF_LGenBase_burstPreCalc_FT pl_preCalcFunc,
    in EPTF_LGenBase_burstPostCalc_FT pl_postCalcFunc)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    
    var integer vl_listSize := sizeof(v_LGenBase_burstFuncRefList);
    for ( var integer vl_i := 0; vl_i < vl_listSize ; vl_i := vl_i+1 )
    {
      if(v_LGenBase_burstFuncRefList[vl_i].burstCalcMode == pl_funcName){
        f_EPTF_LGenBase_loggingError(%definitionId&"This "&pl_funcName&" burst calculation method is already defined: ");
        return -1;
      }
    }
    
    v_LGenBase_burstFuncRefList[vl_listSize].burstCalcMode := pl_funcName;
    v_LGenBase_burstFuncRefList[vl_listSize].burstPreCalc := pl_preCalcFunc;
    v_LGenBase_burstFuncRefList[vl_listSize].burstPostCalc := pl_postCalcFunc;
    
    return vl_listSize;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getBurstCalcFunctionId
  //
  //  Purpose:
  //    Gets the index of ther user defined burst calculation method.
  //
  //  Parameters:
  //    pl_funcName - *in* - *charstring* - The name of burst calculation
  //
  //  Return Value:
  //    *integer* - The index of the burst calculation function
  //
  //  Errors & assertions:
  //    -
  //
  //  Detailed Comments:
  //    The function gets the index of the user defined burst calculation method.
  //    If the method cannot be found, it returns -1.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getBurstCalcFunctionId(
    in charstring pl_funcName)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    
    for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_burstFuncRefList) ; vl_i := vl_i+1 )
    {
      if(v_LGenBase_burstFuncRefList[vl_i].burstCalcMode == pl_funcName){
        return vl_i;
      }
    }
    
    return -1;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getBurstCalcFunction
  //
  //  Purpose:
  //    Gets a user defined burst calculation method and its function references from a list.
  //
  //  Parameters:
  //    pl_funcName - *in* - *charstring* - The name of burst calculation
  //    pl_preCalcFunc - *out* <EPTF_LGenBase_burstPreCalc_FT> - The burst precalculation function reference
  //    pl_postCalcFunc - *out* <EPTF_LGenBase_burstPostCalc_FT> - The burst postcalculation function reference
  //
  //  Return Value:
  //    *integer* - The index of the burst calculation function
  //
  //  Errors & assertions:
  //    -
  //
  //  Detailed Comments:
  //    The function gets a user defined burst calculation method and its function references.
  //    If the method cannot be found, it returns -1.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getBurstCalcFunction(
    in charstring pl_funcName,
    inout EPTF_LGenBase_burstPreCalc_FT pl_preCalcFunc,
    inout EPTF_LGenBase_burstPostCalc_FT pl_postCalcFunc)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    
    var integer vl_returnValue := -1;
    
    for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_burstFuncRefList) ; vl_i := vl_i+1 )
    {
      if(v_LGenBase_burstFuncRefList[vl_i].burstCalcMode == pl_funcName){
        pl_preCalcFunc := v_LGenBase_burstFuncRefList[vl_i].burstPreCalc;
        pl_postCalcFunc := v_LGenBase_burstFuncRefList[vl_i].burstPostCalc;
        vl_returnValue := vl_i;
      }
    }
    
    return vl_returnValue;
  }
  
  ////////////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_adjustSchedulerData4NewCps
  //
  //  Purpose: adjust roundedCpsUpdateInterval, idealBurstSize and moduloOperand for new cps
  //
  ///////////////////////////////////////////////////////////
  private function f_EPTF_LGenBase_adjustSchedulerData4NewCps(
    inout EPTF_LGenBase_SchedulerData pl_schData
  ) runs on EPTF_LGenBase_Private_CT {
    var float vl_interval;
    
    f_EPTF_Base_assert(
      %definitionId&": CPS, or weight must be non-negative",
      not ischosen(pl_schData.target.dummy)
      and ((ischosen(pl_schData.target.cpsToReach) and pl_schData.target.cpsToReach>=0.0)
        or (ischosen(pl_schData.target.trafficWeight) and pl_schData.target.trafficWeight>=0.0))
    );
    pl_schData.burstCalcNeeded := true;
    
    var float vl_cpsToReach := pl_schData.target.cpsToReach;
    
    if (pl_schData.burstFuncRef.burstCalcMode == c_EPTF_LGenBase_BurstCalc_poisson) {
      pl_schData.idealBurstSize := 0.0;
      pl_schData.currentBurstSize := 0;
      pl_schData.roundedCpsUpdateInterval := 0.0;
    } else {
    
      if (vl_cpsToReach<=0.0) {
        pl_schData.idealBurstSize := 0.0
        vl_interval := 0.0
      } else {
        if (1.0/vl_cpsToReach<tsp_EPTF_LGenBase_CPS_minUpdateInterval) {
          vl_interval:= tsp_EPTF_LGenBase_CPS_minUpdateInterval
        } else {
          vl_interval := 1.0/vl_cpsToReach
        }
        //round it down to a multiple of tsp_EPTF_ELEMENTARY_TIMESTEP_PARAM
        vl_interval := tsp_EPTF_ELEMENTARY_TIMESTEP_PARAM * int2float(float2int(vl_interval/tsp_EPTF_ELEMENTARY_TIMESTEP_PARAM));
        if (vl_interval<tsp_EPTF_ELEMENTARY_TIMESTEP_PARAM) {
          vl_interval := tsp_EPTF_ELEMENTARY_TIMESTEP_PARAM
        }
        pl_schData.idealBurstSize := vl_cpsToReach  * vl_interval;
        pl_schData.currentBurstSize := float2int(pl_schData.idealBurstSize+0.50000001); // +0.500001 is needed to overcome numerical errors
      }
      pl_schData.roundedCpsUpdateInterval := vl_interval;
    }
    
    if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Using scheduler data:"&log2str(pl_schData))
    }
  }
  
} //BurstCalculation

///////////////////////////////////////////////////////////
//  Group: Conversion
//
//  Purpose:
//    Conversion functions
//
//  Detailed Comments:
//    LGenBase stores the state of the entity in integer form. These functions
//    convert these value types
///////////////////////////////////////////////////////////
group EntityStateConversion{
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_eState2integer
  //
  //  Purpose:
  //    Converts an <EPTF_LGenBase_EntityState> value to integer.
  //
  //  Detailed Comments:
  //    LGenBase stores the state of the entity in integer form.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_eState2integer(in EPTF_LGenBase_EntityState pl_verdict) return integer{
    select( pl_verdict )
    {
      case ( none )
      {
        return c_EPTF_LGenBase_eStateNone;
      }
      case ( pass )
      {
        return c_EPTF_LGenBase_eStatePass;
      }
    }
    return c_EPTF_LGenBase_eStateFail;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_integer2eState
  //
  //  Purpose:
  //    Converts an integer value to <EPTF_LGenBase_EntityState>.
  //
  //  Detailed Comments:
  //    LGenBase stores the state of the entity in integer form.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_integer2eState(in integer pl_int) return EPTF_LGenBase_EntityState{
    select( pl_int )
    {
      case ( c_EPTF_LGenBase_eStateNone )
      {
        return none;
      }
      case ( c_EPTF_LGenBase_eStatePass )
      {
        return pass;
      }
    }
    return fail;
  }
  
}//EntityStateConversion

///////////////////////////////////////////////////////////
//  Group: GetSet
//
//  Purpose:
//    Get/Set functions
///////////////////////////////////////////////////////////
group GetSet{
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setEntityState
  //
  //  Purpose:
  //    Sets the state of an entity in a traffic case.
  //
  //  Detailed Comments:
  //    This state has no relation to the enabled/disabled state of the
  //    entity.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setEntityState(
    in integer pl_entityRelIdx,
    in integer pl_tcIdx,
    in EPTF_LGenBase_EntityState pl_state)
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    f_EPTF_Base_assert(%definitionId&": Invalid entity index.",pl_entityRelIdx > -1 and pl_entityRelIdx < sizeof(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList));
    v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_entityRelIdx].entityState :=
    f_EPTF_LGenBase_eState2integer(pl_state);
  }
  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEntityState
  //
  //  Purpose:
  //    Returns the state of an entity in a traffic case.
  //
  //  Detailed Comments:
  //    This state has no relation to the enabled/disabled state of the
  //    entity.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getEntityState(
    in integer pl_entityRelIdx,
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return EPTF_LGenBase_EntityState{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    f_EPTF_Base_assert(%definitionId&": Invalid entity index.",pl_entityRelIdx > -1 and pl_entityRelIdx < sizeof(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList));
    return f_EPTF_LGenBase_integer2eState(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_entityRelIdx].entityState);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEntityStarts
  //
  //  Purpose:
  //    Returns the nr of starts of an entity in a traffic case.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getEntityStarts(
    in integer pl_entityRelIdx,
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    f_EPTF_Base_assert(%definitionId&": Invalid entity index.",pl_entityRelIdx > -1 and pl_entityRelIdx < sizeof(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList));
    return v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_entityRelIdx].nrOfStarts;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEntityFails
  //
  //  Purpose:
  //    Returns the nr of fails of an entity in a traffic case.
  public function f_EPTF_LGenBase_getEntityFails(
    in integer pl_entityRelIdx,
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    f_EPTF_Base_assert(%definitionId&": Invalid entity index.",pl_entityRelIdx > -1 and pl_entityRelIdx < sizeof(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList));
    return v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_entityRelIdx].nrOfFails;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEntityErrors
  //
  //  Purpose:
  //    Returns the nr of errors of an entity in a traffic case.
  public function f_EPTF_LGenBase_getEntityErrors(
    in integer pl_entityRelIdx,
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    f_EPTF_Base_assert(%definitionId&": Invalid entity index.",pl_entityRelIdx > -1 and pl_entityRelIdx < sizeof(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList));
    return v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_entityRelIdx].nrOfErrors;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEntityTimeouts
  //
  //  Purpose:
  //    Returns the nr of timeouts of an entity in a traffic case.
  public function f_EPTF_LGenBase_getEntityTimeouts(
    in integer pl_entityRelIdx,
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    f_EPTF_Base_assert(%definitionId&": Invalid entity index.",pl_entityRelIdx > -1 and pl_entityRelIdx < sizeof(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList));
    return v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_entityRelIdx].nrOfTimeouts;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEntitySuccesses
  //
  //  Purpose:
  //    Returns the nr  of successes of an entity in a traffic case.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getEntitySuccesses(
    in integer pl_entityRelIdx,
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    f_EPTF_Base_assert(%definitionId&": Invalid entity index.",pl_entityRelIdx > -1 and pl_entityRelIdx < sizeof(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList));
    return v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_entityRelIdx].nrOfSuccesses;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_resetTrafficStats
  //
  //  Purpose:
  //    Resets the nrOfSuccesses, nrOfFails, nrOfErrors, nrOfTimeouts values
  ///////////////////////////////////////////////////////////
  private function f_EPTF_LGenBase_resetTrafficStats()
  runs on EPTF_LGenBase_Private_CT{
    for ( var integer vl_tc := 0; vl_tc < sizeof(v_LGenBase_trafficCases) ; vl_tc := vl_tc+1 ){
      var integer vl_eCount := sizeof(v_LGenBase_trafficCases[vl_tc].entityInfo.itemList)
      for ( var integer vl_e := 0; vl_e < vl_eCount ; vl_e := vl_e+1 ){
        v_LGenBase_trafficCases[vl_tc].entityInfo.itemList[vl_e].nrOfSuccesses := 0
      }
      v_LGenBase_trafficCases[vl_tc].nrOfStarts := 0
      v_LGenBase_trafficCases[vl_tc].nrOfSuccesses := 0
      f_EPTF_LGenBaseStats_trafficSucces( vl_tc )
      for ( var integer vl_cb := 0; vl_cb < sizeof(v_LGenBase_refreshSuccFnList) ; vl_cb := vl_cb+1 ){
        v_LGenBase_refreshSuccFnList[vl_cb].apply( vl_tc )
      }
      v_LGenBase_trafficCases[vl_tc].nrOfFails := 0
      f_EPTF_LGenBaseStats_trafficFail( vl_tc )
      for ( var integer vl_cb := 0; vl_cb < sizeof(v_LGenBase_refreshFailFnList) ; vl_cb := vl_cb+1 ){
        v_LGenBase_refreshFailFnList[vl_cb].apply( vl_tc )
      }
      v_LGenBase_trafficCases[vl_tc].nrOfErrors := 0
      f_EPTF_LGenBaseStats_trafficError( vl_tc )
      for ( var integer vl_cb := 0; vl_cb < sizeof(v_LGenBase_refreshErrorFnList) ; vl_cb := vl_cb+1 ){
        v_LGenBase_refreshErrorFnList[vl_cb].apply( vl_tc )
      }
      v_LGenBase_trafficCases[vl_tc].nrOfTimeouts := 0
      f_EPTF_LGenBaseStats_trafficTimeout( vl_tc )
      for ( var integer vl_cb := 0; vl_cb < sizeof(v_LGenBase_refreshTimeoutFnList) ; vl_cb := vl_cb+1 ){
        v_LGenBase_refreshTimeoutFnList[vl_cb].apply( vl_tc )
      }
    }
  }
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEntityFSMCtxIdx
  //
  //  Purpose:
  //    Public function to get the FSM context index of the entity in a traffic case.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getEntityFSMCtxIdx(
    in integer pl_entityRelIdx,
    in integer pl_tcIdx,
    in integer pl_siblingIdx := 0)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    return f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc(pl_entityRelIdx, pl_tcIdx, pl_siblingIdx)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcStarts
  //
  //  Purpose:
  //    Returns the nr of starts of an Tc in a traffic case.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTcStarts(
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    return v_LGenBase_trafficCases[pl_tcIdx].nrOfStarts;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcFails
  //
  //  Purpose:
  //    Returns the nr of fails of an Tc in a traffic case.
  public function f_EPTF_LGenBase_getTcFails(
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    return v_LGenBase_trafficCases[pl_tcIdx].nrOfFails;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcErrors
  //
  //  Purpose:
  //    Returns the nr of errors of an Tc in a traffic case.
  public function f_EPTF_LGenBase_getTcErrors(
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    return v_LGenBase_trafficCases[pl_tcIdx].nrOfErrors;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcTimeouts
  //
  //  Purpose:
  //    Returns the nr of timeouts of an Tc in a traffic case.
  public function f_EPTF_LGenBase_getTcTimeouts(
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    return v_LGenBase_trafficCases[pl_tcIdx].nrOfTimeouts;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcAvailable
  //
  //  Purpose:
  //    Returns the nr of available entities in a traffic case.
  public function f_EPTF_LGenBase_getTcAvailable(
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    return v_LGenBase_trafficCases[pl_tcIdx].nrOfAvailableEntities
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcAllEntities
  //
  //  Purpose:
  //    Returns the nr of entities in a traffic case.
  public function f_EPTF_LGenBase_getTcAllEntities(
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    return v_LGenBase_trafficCases[pl_tcIdx].nrOfAllEntities
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcNotFinishedEntities
  //
  //  Purpose:
  //    Returns the nr of entities in a traffic case.
  public function f_EPTF_LGenBase_getTcNotFinishedEntities(
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    return v_LGenBase_trafficCases[pl_tcIdx].nrOfNotFinishedEntities
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcRunningEntities
  //
  //  Purpose:
  //    Returns the nr of entities in a traffic case.
  public function f_EPTF_LGenBase_getTcRunningEntities(
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    return v_LGenBase_trafficCases[pl_tcIdx].nrOfRunningEntities
  }
  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcSuccesses
  //
  //  Purpose:
  //    Returns the nr  of successes of an Tc in a traffic case.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTcSuccesses(
    in integer pl_tcIdx)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    return v_LGenBase_trafficCases[pl_tcIdx].nrOfSuccesses;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setTCStartDelay
  //
  //  Purpose:
  //    Sets the start delay of a traffic case.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setTCStartDelay(
    in integer pl_tcIdx,
    in float pl_newDelay)
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    v_LGenBase_trafficCases[pl_tcIdx].startDelay := pl_newDelay;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_addScenarioCreatedCallBack
  //
  //  Purpose:
  //    Registers a callback function to call when a scenario is created
  //
  //  Detailed Comments:
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_addScenarioCreatedCallback(in EPTF_LGenBase_scenarioCreated_FT pl_LGenBase_scenarioCreatedCbf)
  runs on EPTF_LGenBase_Private_CT return integer
  {
    var integer i:= sizeof(v_LGenBase_scenarioCreated);
    v_LGenBase_scenarioCreated[i] := pl_LGenBase_scenarioCreatedCbf;
    return i;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_removeScenarioCreatedCallBack
  //
  //  Purpose:
  //    Removes a callback function to call when a scenario is created
  //
  //  Detailed Comments:
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_removeScenarioCreatedCallback(in integer pl_idx) runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Error: attempting to delete fcb. at invalid idx:" & int2str(pl_idx), pl_idx>-1 and pl_idx<sizeof(v_LGenBase_scenarioCreated));
    
    var EPTF_LGenBase_scenarioCreated_FTList vl_list := v_LGenBase_scenarioCreated;
    var integer i;
    
    v_LGenBase_scenarioCreated:= {};
    for (i:=0; i<pl_idx; i:= i+1)  {
      v_LGenBase_scenarioCreated[i] := vl_list[i];
    }
    
    for (i:=pl_idx; i<sizeof(vl_list)-1; i:= i+1)  {
      v_LGenBase_scenarioCreated[i] := vl_list[i+1];
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_addEntityGroupCreatedCallback
  //
  //  Purpose:
  //    Registers a callback function to call when a entityGroup is created
  //
  //  Detailed Comments:
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_addEntityGroupCreatedCallback(in EPTF_LGenBase_entityGroupCreated_FT pl_LGenBase_entityGroupCreatedCbf)
  runs on EPTF_LGenBase_Private_CT return integer
  {
    var integer i:= sizeof(v_LGenBase_entityGroupCreated);
    v_LGenBase_entityGroupCreated[i] := pl_LGenBase_entityGroupCreatedCbf;
    return i;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_removeEntityGroupCreatedCallBack
  //
  //  Purpose:
  //    Removes a callback function to call when a entityGroup is created
  //
  //  Detailed Comments:
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_removeEntityGroupCreatedCallback(in integer pl_idx) runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Error: attempting to delete fcb. at invalid idx:" & int2str(pl_idx), pl_idx>-1 and pl_idx<sizeof(v_LGenBase_entityGroupCreated));
    
    var EPTF_LGenBase_entityGroupCreated_FTList vl_list := v_LGenBase_entityGroupCreated;
    var integer i;
    
    v_LGenBase_entityGroupCreated:= {};
    for (i:=0; i<pl_idx; i:= i+1)  {
      v_LGenBase_entityGroupCreated[i] := vl_list[i];
    }
    
    for (i:=pl_idx; i<sizeof(vl_list)-1; i:= i+1)  {
      v_LGenBase_entityGroupCreated[i] := vl_list[i+1];
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_addtrafficCaseCreatedCallBack
  //
  //  Purpose:
  //    Registers a callback function to call when a scenario is created
  //
  //  Detailed Comments:
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_addtrafficCaseCreatedCallback(in EPTF_LGenBase_trafficCaseCreated_FT pl_LGenBase_trafficCaseCreatedCbf)
  runs on EPTF_LGenBase_Private_CT return integer
  {
    var integer i:= sizeof(v_LGenBase_trafficCaseCreated);
    v_LGenBase_trafficCaseCreated[i] := pl_LGenBase_trafficCaseCreatedCbf;
    return i;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_removetrafficCaseCreatedCallBack
  //
  //  Purpose:
  //    Removes a callback function to call when a scenario is created
  //
  //  Detailed Comments:
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_removetrafficCaseCreatedCallback(in integer pl_idx) runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Error: attempting to delete fcb. at invalid idx:" & int2str(pl_idx), pl_idx>-1 and pl_idx<sizeof(v_LGenBase_trafficCaseCreated));
    
    var EPTF_LGenBase_trafficCaseCreated_FTList vl_list := v_LGenBase_trafficCaseCreated;
    var integer i;
    
    v_LGenBase_trafficCaseCreated:= {};
    for (i:=0; i<pl_idx; i:= i+1)  {
      v_LGenBase_trafficCaseCreated[i] := vl_list[i];
    }
    
    for (i:=pl_idx; i<sizeof(vl_list)-1; i:= i+1)  {
      v_LGenBase_trafficCaseCreated[i] := vl_list[i+1];
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_addBurstGeneratedCallBack
  //
  //  Purpose:
  //    Registers a callback function to call after a burst generation occurred (after postproc)
  //
  //  Parameters:
  //    pl_burstGenerated - *in* - <EPTF_LGenBase_burstPostCalc_FT> - the callback function
  //
  //  Return Value:
  //    *integer* - Index of the function reference in the list
  //
  //  Detailed Comments:
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_addBurstGeneratedCallBack(in EPTF_LGenBase_burstPostCalc_FT pl_burstGenerated)
  runs on EPTF_LGenBase_Private_CT return integer
  {
    var integer i:= sizeof(v_LGenBase_burstGenerated);
    v_LGenBase_burstGenerated[i] := pl_burstGenerated;
    return i;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_removeBurstGeneratedCallBack
  //
  //  Purpose:
  //    Removes a callback function to call after a burst generation occurred (after postproc)
  //
  //  Parameters:
  //    pl_idx - *in* - *integer* - Index of the function reference in the list
  //
  //  Detailed Comments:
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_removeBurstGeneratedCallback(in integer pl_idx) runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Error: attempting to delete fcb. at invalid idx:" & int2str(pl_idx), pl_idx>-1 and pl_idx<sizeof(v_LGenBase_burstGenerated));
    
    var EPTF_LGenBase_burstPostCalc_FTList vl_list := v_LGenBase_burstGenerated;
    var integer i;
    
    v_LGenBase_burstGenerated := {};
    for (i:=0; i<pl_idx; i:= i+1) {
      v_LGenBase_burstGenerated[i] := vl_list[i];
    }
    
    for (i:=pl_idx; i<sizeof(vl_list)-1; i:= i+1)  {
      v_LGenBase_burstGenerated[i] := vl_list[i+1];
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_checkSchedulingTimerIsRunning
  //
  //  Purpose:
  //    Checks whether the scheduling timer is running in a traffic case
  //
  //  Parameters:
  //    pl_tcIdx - *in* - *integer* - traffic case index (relative)
  //
  //  Return Value:
  //    *boolean* - If scheduling timer is running.
  //
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_checkSchedulingTimerIsRunning(in integer pl_tcIdx) runs on EPTF_LGenBase_Private_CT
  return boolean
  {
    var boolean vl_returnValue := false;
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index.",pl_tcIdx > -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    if(not f_EPTF_LGenBase_isWeightedScenario(
        v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref,
        v_LGenBase_trafficCases[pl_tcIdx].eScenarioBackRef)){ //normal scenario
      if(-1 != v_LGenBase_trafficCases[pl_tcIdx].schedulingTimer){
        vl_returnValue := true;
      }
    } else { //weighted scenario
      
      if(ispresent(v_LGenBase_entityGroups[v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref].scenarios[v_LGenBase_trafficCases[pl_tcIdx].eScenarioBackRef].schedulerData))
      {
        if(-1 != v_LGenBase_entityGroups[v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref].scenarios[v_LGenBase_trafficCases[pl_tcIdx].eScenarioBackRef].schedulerData.schedulingTimer){
          vl_returnValue := true;
        }
      }
    }
    return vl_returnValue;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_checkName
  //
  //  Purpose:
  //    Checks whether the given name contains the name separator specified in a component variable
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_checkName(in charstring pl_name) return boolean{
    template charstring tl_separator := pattern "*{tsp_LGenBase_nameSeparator}*";
    return not match(pl_name, tl_separator);
  }

  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_registerCPSChangedCallback_TC
  // 
  //  Purpose:
  //    Registers a CPS changed callback for the given traffic case instance
  //
  //  Parameters:
  //     pl_eGrpName - *in charstring* - the entity group name
  //     pl_scName - *in charstring* - the scenario name
  //     pl_tcName - *in charstring* - the traffic case name
  //     pl_cpsChangedCallback - *in* <EPTF_LGenBase_TrafficCaseCPSChangedCallbackFn_FT> -  the traffic case CPS changed callback
  //
  //  Return Value:
  //    -
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_registerCPSChangedCallback_TC(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName,
    in EPTF_LGenBase_TrafficCaseCPSChangedCallbackFn_FT pl_cpsChangedCallback
  ) runs on EPTF_LGenBase_Private_CT {    
    var integer vl_eGrpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_eGrpName);
    f_EPTF_Base_assert(%definitionId&": Invalid entity group name: "&pl_eGrpName,-1 < vl_eGrpIdx);
    var integer vl_scIdx := f_EPTF_LGenBase_scNameIndexInEG(vl_eGrpIdx, pl_scName);
    f_EPTF_Base_assert(%definitionId&": Invalid scenario name: "&pl_scName,-1 < vl_scIdx);
    f_EPTF_Base_assert(%definitionId&": CPS change callback cannot be set to weighted scenario: "
      &v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].uniqueName,
      not f_EPTF_LGenBase_isWeightedScenario(vl_eGrpIdx, vl_scIdx));
    var integer vl_tcIdx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName);
    v_LGenBase_trafficCases[vl_tcIdx].cpsChangedCallbackList[sizeof(v_LGenBase_trafficCases[vl_tcIdx].cpsChangedCallbackList)] := pl_cpsChangedCallback;    
  }

  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_deregisterCPSChangedCallback_TC
  // 
  //  Purpose:
  //    DeRegisters a CPS changed callback for the given traffic case instance
  //
  //  Parameters:
  //     pl_eGrpName - *in charstring* - the entity group name
  //     pl_scName - *in charstring* - the scenario name
  //     pl_tcName - *in charstring* - the traffic case name
  //     pl_cpsChangedCallback - *in* <EPTF_LGenBase_TrafficCaseCPSChangedCallbackFn_FT> -  the traffic case CPS changed callback
  //
  //  Return Value:
  //    -
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_deregisterCPSChangedCallback_TC(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName,
    in EPTF_LGenBase_TrafficCaseCPSChangedCallbackFn_FT pl_cpsChangedCallback
  ) runs on EPTF_LGenBase_Private_CT {
    var integer vl_tcIdx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName);

    for(var integer i:=0; i<sizeof(v_LGenBase_trafficCases[vl_tcIdx].cpsChangedCallbackList); i:=i+1) {
      if(v_LGenBase_trafficCases[vl_tcIdx].cpsChangedCallbackList[i]==pl_cpsChangedCallback) {
        v_LGenBase_trafficCases[vl_tcIdx].cpsChangedCallbackList[i] := null;
      }
    }
  }

  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_callCPSChangedCallbacks_TC
  // 
  //  Purpose:
  //    Calls the CPS changed callbacks for the given traffic case instance
  //
  //  Parameters:
  //     pl_tcIdx - *in integer* - the id of the traffic case in the instance DB
  //     pl_cps - *in float* - the new CPS value
  //
  //  Return Value:
  //    -
  //
  ///////////////////////////////////////////////////////////
  private function f_EPTF_LGenBase_callCPSChangedCallbacks_TC(in float pl_cps, in integer pl_tcIdx) runs on EPTF_LGenBase_Private_CT {
    f_EPTF_Base_assert(%definitionId&": Invalid index "&int2str(pl_tcIdx)&
      ". Valid index range: (0.."&int2str(sizeof(v_LGenBase_trafficCases))&").",
      pl_tcIdx >= 0 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));

    for (var integer i:=0; i<sizeof(v_LGenBase_trafficCases[pl_tcIdx].cpsChangedCallbackList); i:=i+1) {
      if (v_LGenBase_trafficCases[pl_tcIdx].cpsChangedCallbackList[i]!=null) {
        v_LGenBase_trafficCases[pl_tcIdx].cpsChangedCallbackList[i].apply(pl_cps,pl_tcIdx);
      }
    }
  }

  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setCPSByNames
  //
  //  Purpose:
  //    Sets the required CPS of the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setCPSByNames(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName,
    in float pl_newCps
  )
  runs on EPTF_LGenBase_Private_CT{
    //We don't handle the previous value
    v_LGenBase_dummyFloat := f_EPTF_LGenBase_setCPS(f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName), pl_newCps);
  }

  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcCpsToReachByName
  //
  //  Purpose:
  //    Retrieves the required CPS of the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTcCpsToReachByName(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName)
  runs on EPTF_LGenBase_Private_CT
  return float{
    var integer vl_tc_idx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName)
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case name: "&
      pl_eGrpName&tsp_LGenBase_nameSeparator&pl_scName&tsp_LGenBase_nameSeparator&pl_tcName,
      -1 < vl_tc_idx)
    return f_EPTF_LGenBase_getTcCpsToReachByIdx(vl_tc_idx);
  }

  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcCpsToReachByIdx
  //
  //  Purpose:
  //    Retrieves the required CPS of the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTcCpsToReachByIdx(
    in integer pl_tcAbsIdx)
  runs on EPTF_LGenBase_Private_CT
  return float{
    f_EPTF_Base_assert(%definitionId&": The traffic case "&v_LGenBase_trafficCases[pl_tcAbsIdx].uniqueName&
      " is in a weighted scenario.",ischosen(v_LGenBase_trafficCases[pl_tcAbsIdx].schedulerData.target.cpsToReach));
    return v_LGenBase_trafficCases[pl_tcAbsIdx].schedulerData.target.cpsToReach;
    //pl_tc.schedulerData.target.cpsToReach
  }

  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setCpsOrWeightOfTcByNames
  //
  //  Purpose:
  //    Sets the required CPS or Weight of the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setCpsOrWeightOfTcByNames(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName,
    in float pl_newCps
  )
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_tcIdx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName);
    if (ischosen(v_LGenBase_trafficCases[vl_tcIdx].schedulerData.target.cpsToReach))
    {
      v_LGenBase_dummyFloat := f_EPTF_LGenBase_setCPS(vl_tcIdx, pl_newCps);
    } else if (ischosen(v_LGenBase_trafficCases[vl_tcIdx].schedulerData.target.trafficWeight))
    {
      v_LGenBase_dummyFloat := f_EPTF_LGenBase_setTcWeight(vl_tcIdx, pl_newCps);
    } else {
      //This code shouldn't be reached, because the configuration reader function should prevent
      f_EPTF_Base_assert(%definitionId&": There is neither cpsToReach, nor trafficWeight defined for the traffic case.",false)
    }
  }

  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getNrOfTCs
  //
  //  Purpose:
  //    Retrieves the number of the traffic cases
  ///////////////////////////////////////////////////////////  

  public function f_EPTF_LGenBase_getNrOfTCs() runs on EPTF_LGenBase_Private_CT return integer{
    return sizeof(v_LGenBase_trafficCases);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setCPS
  //
  //  Purpose:
  //    Sets the required CPS of the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setCPS(
    in integer pl_tcAbsIdx,
    in float pl_newCps
  )
  runs on EPTF_LGenBase_Private_CT
  return float
  {
    if(not ischosen(v_LGenBase_trafficCases[pl_tcAbsIdx].schedulerData.target.cpsToReach)){
      f_EPTF_LGenBase_loggingWarning(%definitionId&": CPS cannot set to weighted TC: "
        &v_LGenBase_trafficCases[pl_tcAbsIdx].uniqueName)
      return 0.0
    }
    if(originating == v_LGenBase_trafficCases[pl_tcAbsIdx].trafficType and
      -1 < v_LGenBase_trafficCases[pl_tcAbsIdx].schedulingTimer){
      f_EPTF_SchedulerComp_CancelEvent(v_LGenBase_trafficCases[pl_tcAbsIdx].schedulingTimer)
      v_LGenBase_trafficCases[pl_tcAbsIdx].schedulingTimer := -1
    }
    var float vl_ret := v_LGenBase_trafficCases[pl_tcAbsIdx].schedulerData.target.cpsToReach ;
    v_LGenBase_trafficCases[pl_tcAbsIdx].schedulerData.target.cpsToReach := pl_newCps
    f_EPTF_LGenBase_callCPSChangedCallbacks_TC(pl_newCps,pl_tcAbsIdx);
    if(originating == v_LGenBase_trafficCases[pl_tcAbsIdx].trafficType){
      //set modulo,roundedUpdateInterval, idealBurstSize
      f_EPTF_LGenBase_adjustSchedulerData4NewCps(v_LGenBase_trafficCases[pl_tcAbsIdx].schedulerData);
      var EPTF_LGenBase_tcState vl_statePrev := v_LGenBase_trafficCases[pl_tcAbsIdx].state;
      if(c_EPTF_LGenBase_tcStateRunning != vl_statePrev){
        return vl_ret; // do not schedule event if TC is not running
      }
      
      // distribute the bursterror differently according to the traffic corrigation => smooth out cumulative bursts
      var integer vl_eGrpIdx := v_LGenBase_trafficCases[pl_tcAbsIdx].eGroupBackref
      v_LGenBase_trafficCases[pl_tcAbsIdx].schedulerData.burstSizeCumulativeError := v_LGenBase_entityGroups[vl_eGrpIdx].trafficCorrigation;

      if(0.0 < pl_newCps){
        // calculate the remaining time from start_delay
        var float vl_execTime := f_EPTF_Base_getRelTimeInSecs() - v_LGenBase_trafficCases[pl_tcAbsIdx].startTime
        var float vl_remainingTime := v_LGenBase_trafficCases[pl_tcAbsIdx].startDelay - vl_execTime;  
        //HL48155 In any case the timer must be rescheduled, even if there is a running scheduled timer action.
        //Otherwise the CPS change won't take action untill the scheduled action timed out.
        //if( -1 == v_LGenBase_trafficCases[pl_tcAbsIdx].schedulingTimer ) // if an event exists already we don't need to reschedule
        {
          if ( tsp_EPTF_ELEMENTARY_TIMESTEP_PARAM > vl_remainingTime) { 
            vl_remainingTime := tsp_EPTF_ELEMENTARY_TIMESTEP_PARAM
          }
          // set different start time for different LGens => smooth out synchronous call generation (far small CPS):
          var float vl_stTrafficCorrigation := v_LGenBase_entityGroups[vl_eGrpIdx].trafficCorrigation/v_LGenBase_trafficCases[pl_tcAbsIdx].schedulerData.target.cpsToReach;
          vl_remainingTime := vl_remainingTime + vl_stTrafficCorrigation;
          f_EPTF_LGenBase_restartActionTimer(v_LGenBase_trafficCases[pl_tcAbsIdx].schedulingTimer, 
            refers(f_EPTF_LGenBase_doTrafficCaseTimerAction), 
            {pl_tcAbsIdx}, 
            vl_remainingTime);
        } 
        /*}else{
        if(-1 < v_LGenBase_trafficCases[pl_tcAbsIdx].schedulingTimer){
        f_EPTF_SchedulerComp_CancelEvent(v_LGenBase_trafficCases[pl_tcAbsIdx].schedulingTimer)
        v_LGenBase_trafficCases[pl_tcAbsIdx].schedulingTimer := -1
        }*/
      }
    }
    return vl_ret;
  }
  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setScenarioCPS
  //
  //  Purpose:
  //    Sets the required CPS of the scenario
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setScenarioCPS(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in float pl_newCps
  )
  runs on EPTF_LGenBase_Private_CT
  return float{
    var integer vl_eGrpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_eGrpName);
    f_EPTF_Base_assert(%definitionId&": Invalid entity group name: "&pl_eGrpName,-1 < vl_eGrpIdx);
    var integer vl_scIdx := f_EPTF_LGenBase_scNameIndexInEG(vl_eGrpIdx, pl_scName);
    f_EPTF_Base_assert(%definitionId&": Invalid scenario name: "&pl_scName,-1 < vl_scIdx);
    var float vl_ret := f_EPTF_LGenBase_setScenarioCPSByIdx(vl_eGrpIdx, vl_scIdx, pl_newCps);
    return vl_ret;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getEGrpName
  //
  //  Purpose:
  //    Public function to get the size of the entity group based on the index of the entity group
  //
  //  Detailed Comments:
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getEGrpName(
    in integer pl_eGrpIdx)
  runs on EPTF_LGenBase_Private_CT
  return charstring{
    f_EPTF_Base_assert(%definitionId&": Invalid entity group index.",pl_eGrpIdx > -1 and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
    return v_LGenBase_entityGroups[pl_eGrpIdx].name;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_registerCPSChangedCallback_SC
  // 
  //  Purpose:
  //    Registers a CPS changed callback for the given scenario instance
  //
  //  Parameters:
  //     pl_eGrpName - *in charstring* - the entity group name
  //     pl_scName - *in charstring* - the scenario name
  //     pl_cpsChangedCallback - *in* <EPTF_LGenBase_TrafficCaseCPSChangedCallbackFn_FT> -  the scenario CPS changed callback
  //
  //  Return Value:
  //    -
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_registerCPSChangedCallback_SC(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in EPTF_LGenBase_ScenarioCPSChangedCallbackFn_FT pl_cpsChangedCallback
  ) runs on EPTF_LGenBase_Private_CT {
    var integer vl_eGrpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_eGrpName);
    f_EPTF_Base_assert(%definitionId&": Invalid entity group name: "&pl_eGrpName,-1 < vl_eGrpIdx);
    var integer vl_scIdx := f_EPTF_LGenBase_scNameIndexInEG(vl_eGrpIdx, pl_scName);
    f_EPTF_Base_assert(%definitionId&": Invalid scenario name: "&pl_scName,-1 < vl_scIdx);
    f_EPTF_Base_assert(%definitionId&": CPS change callback cannot be set to non-weighted scenario: "
      &v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].uniqueName,
      f_EPTF_LGenBase_isWeightedScenario(vl_eGrpIdx, vl_scIdx));
    
    v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].cpsChangedCallbackList[sizeof(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].cpsChangedCallbackList)] := pl_cpsChangedCallback;    
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_deregisterCPSChangedCallback_SC
  // 
  //  Purpose:
  //    DeRegisters a CPS changed callback for the given scenario instance
  //
  //  Parameters:
  //     pl_eGrpName - *in charstring* - the entity group name
  //     pl_scName - *in charstring* - the scenario name
  //     pl_cpsChangedCallback - *in* <EPTF_LGenBase_TrafficCaseCPSChangedCallbackFn_FT> -  the scenario CPS changed callback
  //
  //  Return Value:
  //    -
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_deregisterCPSChangedCallback_SC(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in EPTF_LGenBase_ScenarioCPSChangedCallbackFn_FT pl_cpsChangedCallback
  ) runs on EPTF_LGenBase_Private_CT {
    var integer vl_eGrpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_eGrpName);
    f_EPTF_Base_assert(%definitionId&": Invalid entity group name: "&pl_eGrpName,-1 < vl_eGrpIdx);
    var integer vl_scIdx := f_EPTF_LGenBase_scNameIndexInEG(vl_eGrpIdx, pl_scName);
    f_EPTF_Base_assert(%definitionId&": Invalid scenario name: "&pl_scName,-1 < vl_scIdx);
    
    for(var integer i:=0; i<sizeof(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].cpsChangedCallbackList); i:=i+1) {
      if(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].cpsChangedCallbackList[i]==pl_cpsChangedCallback) {
        v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].cpsChangedCallbackList[i] := null;
      }
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_callCPSChangedCallbacks_SC
  // 
  //  Purpose:
  //    Calls the CPS changed callbacks for the given scenario instance
  //
  //  Parameters:
  //     pl_cps - *in float* - the new CPS value
  //     pl_eGrpIdx - *in integer* - the entity group instance idx
  //     pl_scIdx - *in integer* - the scenario instance idx in entity group
  //
  //  Return Value:
  //    -
  //
  ///////////////////////////////////////////////////////////
  private function f_EPTF_LGenBase_callCPSChangedCallbacks_SC(in float pl_cps, in integer pl_eGrpIdx, in integer pl_scIdx) runs on EPTF_LGenBase_Private_CT {
    f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_eGrpIdx),-1 < pl_eGrpIdx and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
    f_EPTF_Base_assert(%definitionId&": Invalid scenario index: "&int2str(pl_scIdx),-1 < pl_scIdx and pl_scIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios));
    f_EPTF_Base_assert(%definitionId&": CPS cannot set to non-weighted scenario: "
      &v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].uniqueName,
      f_EPTF_LGenBase_isWeightedScenario(pl_eGrpIdx, pl_scIdx));
    
    for (var integer i:=0; i<sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].cpsChangedCallbackList); i:=i+1) {
      if (v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].cpsChangedCallbackList[i]!=null) {
        v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].cpsChangedCallbackList[i].apply(pl_cps,pl_eGrpIdx,pl_scIdx);
      }
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setScenarioCPSByIdx
  //
  //  Purpose:
  //    Sets the required CPS of the scenario
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setScenarioCPSByIdx(
    in integer pl_eGrpIdx,
    in integer pl_scIdx,
    in float pl_newCps,
    in boolean pl_forceAdjust := false
  )
  runs on EPTF_LGenBase_Private_CT
  return float{
    f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_eGrpIdx),-1 < pl_eGrpIdx and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
    f_EPTF_Base_assert(%definitionId&": Invalid scenario index: "&int2str(pl_scIdx),-1 < pl_scIdx and pl_scIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios));
    f_EPTF_Base_assert(%definitionId&": CPS cannot set to non-weighted scenario: "
      &v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].uniqueName,
      f_EPTF_LGenBase_isWeightedScenario(pl_eGrpIdx, pl_scIdx));
    var float vl_ret := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].schedulerData.target.cpsToReach;
    if(pl_forceAdjust or v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].schedulerData.target.cpsToReach == pl_newCps) {
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": setting the same CPS value ignored.");
      return vl_ret;
    }
    if(originating == v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].trafficType and
      -1 < v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].schedulerData.schedulingTimer){
      f_EPTF_SchedulerComp_CancelEvent(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].schedulerData.schedulingTimer)
      v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].schedulerData.schedulingTimer := -1
    }
    v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].schedulerData.target.cpsToReach := pl_newCps;
    f_EPTF_LGenBase_callCPSChangedCallbacks_SC(pl_newCps,pl_eGrpIdx,pl_scIdx);
    if(originating == v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].trafficType){
      f_EPTF_LGenBase_adjustSchedulerData4NewCps(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].schedulerData);
      // distribute the bursterror differently according to the traffic corrigation => smooth out cumulative bursts
      v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].schedulerData.burstSizeCumulativeError := v_LGenBase_entityGroups[pl_eGrpIdx].trafficCorrigation;
      var EPTF_LGenBase_tcState vl_statePrev := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].state;
      if(c_EPTF_LGenBase_tcStateRunning != vl_statePrev){
        return vl_ret; // do not schedule event if SC is not running
      }
      if(0.0 < pl_newCps){
        // set different start time for different LGens => smooth out synchronous call generation (far small CPS):
        var float vl_stTrafficCorrigation := v_LGenBase_entityGroups[pl_eGrpIdx].trafficCorrigation/v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].schedulerData.target.cpsToReach;
        f_EPTF_LGenBase_restartActionTimer(
          v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].schedulerData.schedulingTimer,
          refers(f_EPTF_LGenBase_doWeightedScenarioTimerAction),
          {pl_eGrpIdx, pl_scIdx},
          vl_stTrafficCorrigation
        );
        /*}else{
        if(-1 < v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].schedulerData.schedulingTimer){
        f_EPTF_SchedulerComp_CancelEvent(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].schedulerData.schedulingTimer)
        v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].schedulerData.schedulingTimer := -1
        }*/
      }
    }
    return vl_ret;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcCpsToReachByName
  //
  //  Purpose:
  //    Retrieves the required CPS of the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getScCpsToReachByName(
    in charstring pl_eGrpName,
    in charstring pl_scName)
  runs on EPTF_LGenBase_Private_CT
  return float{
    var integer vl_eGrpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_eGrpName);
    var integer vl_scRelIdx := f_EPTF_LGenBase_scNameIndexInEG(vl_eGrpIdx, pl_scName);
    return f_EPTF_LGenBase_getScCpsToReachByIdx(vl_eGrpIdx, vl_scRelIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Wrapper function for backward compatibility
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getScCpsSoReachByName(
    in charstring pl_eGrpName,
    in charstring pl_scName)
  runs on EPTF_LGenBase_Private_CT
  return float{
    return f_EPTF_LGenBase_getScCpsToReachByName(pl_eGrpName, pl_scName)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getScCpsToReachByIdx
  //
  //  Purpose:
  //    Retrieves the required CPS of the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getScCpsToReachByIdx(
    in integer pl_eGrpIdx,
    in integer pl_scRelIdx)
  runs on EPTF_LGenBase_Private_CT
  return float{
    f_EPTF_Base_assert(%definitionId&": The "&v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scRelIdx].uniqueName&
      " scenario is not a weighted scenario.",
      f_EPTF_LGenBase_isWeightedScenario(pl_eGrpIdx, pl_scRelIdx));
    return v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scRelIdx].schedulerData.target.cpsToReach;
    //pl_tc.schedulerData.target.cpsToReach
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setTcWeight
  //
  //  Purpose:
  //    Sets the required CPS of the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setTcWeight(
    in integer pl_tcAbsIdx,
    in float pl_newWeight)
  runs on EPTF_LGenBase_Private_CT
  return float{
    f_EPTF_Base_assert(%definitionId&": Weight cannot set to normal TC: "
      &v_LGenBase_trafficCases[pl_tcAbsIdx].uniqueName,
      ischosen(v_LGenBase_trafficCases[pl_tcAbsIdx].schedulerData.target.trafficWeight));
    
    var float vl_ret := v_LGenBase_trafficCases[pl_tcAbsIdx].schedulerData.target.trafficWeight ;
    var integer vl_eGrpIdx := v_LGenBase_trafficCases[pl_tcAbsIdx].eGroupBackref;
    var integer vl_scInGrpIdx := v_LGenBase_trafficCases[pl_tcAbsIdx].eScenarioBackRef;
    
    v_LGenBase_trafficCases[pl_tcAbsIdx].schedulerData.target.trafficWeight := pl_newWeight
    
    var boolean vl_mixerAcceptsMix := f_EPTF_TrafficMixer_acceptNewTrafficMix(
      v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].trafficMixData,
      f_EPTF_LGenBase_getEnabledWeightListFromScenario(vl_eGrpIdx,vl_scInGrpIdx),
      v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].weightedScData.deterministicMix
    )
    f_EPTF_Base_assert(%definitionId&": initializing traffic mix for TC in weighted SC "&v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].name& ": mixer has not accepted traffic mix",
      vl_mixerAcceptsMix);
    
    //set modulo,roundedUpdateInterval, idealBurstSize
    //f_EPTF_LGenBase_adjustSchedulerData4NewCps(v_LGenBase_trafficCases[pl_tcAbsIdx].schedulerData);
    
    return vl_ret;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getCPSByNames
  //
  //  Purpose:
  //    Retrieves the last reached CPS of the traffic case
  //
  //  Detailed Comments:
  //    This function retrives the content of the lastCPS field
  //    of the traffic case descriptor. To retrieve the measured 
  //    last CPS use the <f_EPTF_LGenBase_getMeasuredCPSByNames>
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getCPSByNames(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName
  )
  runs on EPTF_LGenBase_Private_CT
  return float{
    var integer vl_tcAbsIdx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName);
    return f_EPTF_LGenBase_getCPS(vl_tcAbsIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getCPS
  //
  //  Purpose:
  //    Retrieves the last reached CPS of the traffic case
  //
  //  Detailed Comments:
  //    This function retrives the content of the lastCPS field
  //    of the traffic case descriptor. To retrieve the measured 
  //    last CPS use the <f_EPTF_LGenBase_getMeasuredCPSByIdx>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getCPS(
    in integer pl_tcAbsIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return float{
    return v_LGenBase_trafficCases[pl_tcAbsIdx].lastCPS;
  }
  
  //TODO comment  
  public function f_EPTF_LGenBase_getMeasuredCPSByNames(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName
  )
  runs on EPTF_LGenBase_Private_CT
  return float{
    var charstring vl_varName := 
    f_EPTF_LGenBase_getNamePrefix(pl_eGrpName, pl_scName, pl_tcName) & c_EPTF_LGenBaseStats_nameOfTcLastCps
    var integer vl_varIdx := f_EPTF_Var_getId(vl_varName)
    if(0 > vl_varIdx){
      f_EPTF_LGenBase_loggingWarning(%definitionId&": Invalid traffic case names: "&pl_eGrpName&","&pl_scName&","&pl_tcName)
      return 0.0
    } 
    var EPTF_Var_DirectContent vl_content
    f_EPTF_Var_getContent(vl_varIdx, vl_content)
    return vl_content.floatVal
  }
  
  //TODO comment  
  public function f_EPTF_LGenBase_getMeasuredCPSByIdx(
    in integer pl_tcAbsIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return float{
    var charstring vl_eGrpName, vl_scName, vl_tcName
    f_EPTF_LGenBase_trafficCaseIdNames(pl_tcAbsIdx, vl_eGrpName, vl_scName, vl_tcName)
    return f_EPTF_LGenBase_getMeasuredCPSByNames(vl_eGrpName, vl_scName, vl_tcName)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_tcTimerIsRunning
  //
  //  Purpose:
  //    Retrieves whether a named timer is running
  //    in the FSM of the traffic case.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_tcTimerIsRunning(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName,
    in charstring pl_timerName,
    in integer pl_eRelIdx,
    in integer pl_siblingIdx := 0
  )
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    var integer vl_tcAbsIdx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName);
    var integer vl_grpIdx := v_LGenBase_trafficCases[vl_tcAbsIdx].eGroupBackref;
    f_EPTF_Base_assert(%definitionId& "Invalid entity index.",pl_eRelIdx<v_LGenBase_entityGroups[vl_grpIdx].eCount and pl_eRelIdx > -1);
    var integer vl_eAbsIdx := v_LGenBase_entityGroups[vl_grpIdx].eOffset+pl_eRelIdx;
    var integer vl_fsmCtxIdx := f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc(pl_eRelIdx, vl_tcAbsIdx, pl_siblingIdx);
    if(0 > vl_fsmCtxIdx){
      return false;
    } 
    var integer vl_timerIdx := -1;
    var integer vl_i := 0;
    var integer vl_fsmIdx := v_LGenBase_trafficCases[vl_tcAbsIdx].fsmIdx;
    while ( vl_timerIdx < 0 and vl_i < sizeof(v_LGenBase_fsmTables[vl_fsmIdx].timerList) )
    {
      if(pl_timerName == v_LGenBase_fsmTables[vl_fsmIdx].timerList[vl_i].name){
        vl_timerIdx := vl_i;
      }
      vl_i := vl_i + 1;
    }
    f_EPTF_Base_assert(%definitionId& "Invalid timer name: "&pl_timerName,-1 < vl_timerIdx);
    return f_EPTF_LGenBase_fsmTimerIsRunning(vl_eAbsIdx,vl_fsmCtxIdx,vl_timerIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_nrOfBusyEntities
  //
  //  Purpose:
  //    Returns the count of busy entities in a traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_nrOfBusyEntities(
    in integer pl_tcIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return integer
  {
    if(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.entitySelection == round_robin) {
      return f_EPTF_FBQ_getLengthOfBusyChain(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.fbq);
    } else {
      return f_EPTF_RNA_getLengthOfBusyList(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.rna);
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_getTcState
  //
  //  Purpose:
  //    Returns the state of a traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_getTcState(
    in integer pl_tcIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return EPTF_LGenBase_tcState
  {
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    return v_LGenBase_trafficCases[pl_tcIdx].state
  }
  
  //TODO comment
  public function f_EPTF_LGenBase_getScStateByNames(
    in charstring pl_eGrpName,
    in charstring pl_scName
  )
  runs on EPTF_LGenBase_Private_CT
  return EPTF_LGenBase_tcState
  {
    var integer vl_eGrpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_eGrpName);
    f_EPTF_Base_assert(%definitionId&": Invalid entity group name: "&pl_eGrpName,-1 != vl_eGrpIdx);
    var integer vl_scIdx := f_EPTF_LGenBase_scNameIndexInEG(vl_eGrpIdx, pl_scName);
    f_EPTF_Base_assert(%definitionId&": Invalid scenario name: "&pl_scName,-1 != vl_scIdx);
    return f_EPTF_LGenBase_getScState(vl_eGrpIdx, vl_scIdx)
  }
  
  //TODO comment
  public function f_EPTF_LGenBase_getScState(
    in integer pl_eGrpIdx,
    in integer pl_scIdxInGrp
  )
  runs on EPTF_LGenBase_Private_CT
  return EPTF_LGenBase_tcState
  {
    return v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdxInGrp].state
  }
}//GetSet

///////////////////////////////////////////////////////////
//  Group: StartStop
//
//  Purpose:
//    Functions to start, stop, pause, etc. the traffic cases and scenarios
///////////////////////////////////////////////////////////
group StartStop{
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_stopTrafficCase
  //
  //  Purpose:
  //    Calls f_EPTF_LGenBase_stopTrafficCaseByIdx and stops the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_stopTrafficCase(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName
  )
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_LGenBase_stopTrafficCaseByIdx(f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName));
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_startTrafficCase
  //
  //  Purpose:
  //    Calls f_EPTF_LGenBase_enableTrafficCaseInternal and starts the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_startTrafficCase(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName
  )
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_tcAbsIdx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName);
    f_EPTF_LGenBase_startTrafficCaseByIdx(vl_tcAbsIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_startTrafficCaseByIdx
  //
  //  Purpose:
  //    Calls f_EPTF_LGenBase_enableTrafficCaseInternal and starts the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_startTrafficCaseByIdx(
    in integer pl_tcAbsIdx
  )
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_eGrpIdx := v_LGenBase_trafficCases[pl_tcAbsIdx].eGroupBackref
    var integer vl_scInGrpIdx := v_LGenBase_trafficCases[pl_tcAbsIdx].eScenarioBackRef
    if(f_EPTF_LGenBase_isWeightedScenario(vl_eGrpIdx, vl_scInGrpIdx)){
      // if scenario is weighted and it is not running, start it:
      if (v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].state != c_EPTF_LGenBase_tcStateRunning) {
        f_EPTF_LGenBase_enableScenarioOnEntityGroup(vl_eGrpIdx, vl_scInGrpIdx, true);
        if (v_LGenBase_trafficCases[pl_tcAbsIdx].state == c_EPTF_LGenBase_tcStateRunning) {
          return; // traffic case is already running, do not need to start it
        }
      }
    }
    
    f_EPTF_LGenBase_enableTrafficCaseInternal(pl_tcAbsIdx, true);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_startWeightedScenario
  //
  //  Purpose:
  //    Sends <c_EPTF_LGenBase_inputIdx_testMgmt_stopTC> to the
  //    entities in the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_startWeightedScenario(
    in charstring pl_eGrpName,
    in charstring pl_scName)
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_eGrpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_eGrpName);
    var integer vl_scInGrpIdx := f_EPTF_LGenBase_scNameIndexInEG(vl_eGrpIdx, pl_scName)
    if (f_EPTF_LGenBase_isWeightedScenario(vl_eGrpIdx,vl_scInGrpIdx)) {
      f_EPTF_LGenBase_enableScenarioOnEntityGroup(vl_eGrpIdx, vl_scInGrpIdx, true)
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_finishLaunchTC
  //
  //  Purpose:
  //    Calls the <f_EPTF_LGenBase_disableTrafficCaseInternal>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_finishLaunchTC(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName
  )
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_tcAbsIdx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName);
    f_EPTF_LGenBase_finishLaunchTCByIdx(vl_tcAbsIdx)
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_finishLaunchTCByIdx
  //
  //  Purpose:
  //    Calls the <f_EPTF_LGenBase_disableTrafficCaseInternal>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_finishLaunchTCByIdx(
    in integer pl_tcAbsIdx
  )
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcAbsIdx),-1 < pl_tcAbsIdx and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases));
    f_EPTF_LGenBase_disableTrafficCaseInternal(pl_tcAbsIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_finishTCByName
  //
  //  Purpose:
  //    Stops the traffic case like the custom finish condition
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_finishTCByName(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName
  )
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_tcAbsIdx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName);
    f_EPTF_LGenBase_finishTCByIdx(vl_tcAbsIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_finishTCByIdx
  //
  //  Purpose:
  //    Stops the traffic case like the custom finish condition
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_finishTCByIdx(
    in integer pl_tcAbsIdx
  )
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcAbsIdx),-1 < pl_tcAbsIdx and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases));
    f_EPTF_LGenBase_groupFinishedDetected(pl_tcAbsIdx, c_EPTF_LGenBase_customConditionTrue)
  }
  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_stopTrafficCaseByIdx
  //
  //  Purpose:
  //    Sends <c_EPTF_LGenBase_inputIdx_testMgmt_stopTC> to the
  //    entities in the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_stopTrafficCaseByIdx(
    in integer pl_tcIdx
  )
  runs on EPTF_LGenBase_Private_CT{
    if(terminating == v_LGenBase_trafficCases[pl_tcIdx].trafficType){
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Stop called for terminating tc "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName&
        ". The feature is not implemented yet.");
      return;
    }
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcIdx),-1 < pl_tcIdx and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": StopTrafficCaseByIdx called for tc "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
    v_LGenBase_trafficCases[pl_tcIdx].stopped := true
    f_EPTF_LGenBase_disableTrafficCaseInternal(pl_tcIdx);
    v_LGenBase_trafficCases[pl_tcIdx].state := c_EPTF_LGenBase_tcStateStopping;
    f_EPTF_LGenBase_tcStateChanged(pl_tcIdx);
    var integer vl_maxEntity := v_LGenBase_entityGroups[v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref].eCount;
    f_EPTF_FBQ_initFreeBusyQueue(v_LGenBase_trafficCases[pl_tcIdx].stoppingEntityInfo);
    //var integer vl_maxEntities := sizeof(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList);
    //f_EPTF_FBQ_createFreeSlots(vl_maxEntities, v_LGenBase_trafficCases[pl_tcIdx].stoppingEntityInfo);
    f_EPTF_FBQ_createFreeSlots(vl_maxEntity, v_LGenBase_trafficCases[pl_tcIdx].stoppingEntityInfo);
    
    if(not f_EPTF_SchedulerComp_scheduleAction(
        T_EPTF_componentClock.read + tsp_EPTF_LGenBase_abortStopProcess,
        refers(f_EPTF_LGenBase_stopProcessTimedOut),
        {pl_tcIdx,0},
        v_LGenBase_trafficCases[pl_tcIdx].stopTimeoutTimer)) {
      f_EPTF_LGenBase_loggingError(%definitionId&" can not schedule the timer event to abort the stop process.");
      f_EPTF_Base_stop();
    }
    for ( var integer vl_i := 0; vl_i < vl_maxEntity ; vl_i := vl_i+1 )
    {
      var EPTF_LGenBase_ReportedEventDescriptor vl_stopTcOfFsmEvent := c_EPTF_LGenBase_emptyReportedEventDescriptor;
      vl_stopTcOfFsmEvent.event.bIdx := c_EPTF_LGenBase_bIdx;
      vl_stopTcOfFsmEvent.event.iIdx := c_EPTF_LGenBase_inputIdx_testMgmt_stopTC;
      vl_stopTcOfFsmEvent.event.target := {
        eIdx := v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[vl_i].entityIdx,
        fsmCtxIdx := f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc(vl_i,pl_tcIdx,0)
      };
      vl_stopTcOfFsmEvent.reportedArgs := {pl_tcIdx};
      f_EPTF_LGenBase_dispatchEvent(vl_stopTcOfFsmEvent);
    }
    if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&
        ": Timer: "&log2str(v_LGenBase_trafficCases[pl_tcIdx].stopTimeoutTimer))
    }
    v_LGenBase_trafficCases[pl_tcIdx].lastCPS := 0.0;
    
    // if in weighted scenario: recalculate the traffic mix:
    var integer vl_eGrpIdx := v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref
    var integer vl_scInGrpIdx := v_LGenBase_trafficCases[pl_tcIdx].eScenarioBackRef
    if(f_EPTF_LGenBase_isWeightedScenario(vl_eGrpIdx, vl_scInGrpIdx))
    {
      var boolean vl_mixerAcceptsMix := f_EPTF_TrafficMixer_acceptNewTrafficMix(
        v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].trafficMixData,
        f_EPTF_LGenBase_getEnabledWeightListFromScenario(vl_eGrpIdx,vl_scInGrpIdx),
        v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].weightedScData.deterministicMix
      )
      f_EPTF_Base_assert(%definitionId&": initializing traffic mix for TC in weighted SC "&v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].name& ": mixer has not accepted traffic mix",
        vl_mixerAcceptsMix);
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_stopProcessTimedOut
  //
  //  Purpose:
  //    This function is called when the traffic case had been stopped, but
  //    not all the entities handled the stop event in a predefined interval.
  ///////////////////////////////////////////////////////////
  private function f_EPTF_LGenBase_stopProcessTimedOut(
    in EPTF_ScheduledAction pl_action,
    in integer pl_eventIndex)
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    var integer vl_tcIdx := pl_action.actionId[0];
    var charstring vl_msg := "";
    v_LGenBase_trafficCases[vl_tcIdx].stopTimeoutTimer := -1;
    f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": StopProcessTimedOut called for tc "&v_LGenBase_trafficCases[vl_tcIdx].uniqueName);
    f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": State of tc: "&c_EPTF_LGenBase_stateNames[v_LGenBase_trafficCases[vl_tcIdx].state]);
    select( v_LGenBase_trafficCases[vl_tcIdx].state )
    {
      case ( c_EPTF_LGenBase_tcStateAborting )
      {
        v_LGenBase_trafficCases[vl_tcIdx].state := c_EPTF_LGenBase_tcStateAborted;
        vl_msg :=%definitionId&": WARNING: "&"Abort the entities of the traffic case "&v_LGenBase_trafficCases[vl_tcIdx].uniqueName&" has been timed out.";
        f_EPTF_LGenBase_logNotRespondedEntities(vl_tcIdx, "abort")
      }
      case ( c_EPTF_LGenBase_tcStateStopping )
      {
        v_LGenBase_trafficCases[vl_tcIdx].state := c_EPTF_LGenBase_tcStateStopped;
        if(null != v_LGenBase_detectPhaseFinishFn){v_LGenBase_detectPhaseFinishFn.apply( vl_tcIdx )}
        //f_EPTF_LGenBase_callPhaseFinishConditions(vl_tcIdx);
        vl_msg :=%definitionId&": WARNING: "&"Stop the entities of the traffic case "&v_LGenBase_trafficCases[vl_tcIdx].uniqueName&" has been timed out.";
        f_EPTF_LGenBase_logNotRespondedEntities(vl_tcIdx, "stop")
      }
      case ( c_EPTF_LGenBase_tcStateFinished, c_EPTF_LGenBase_tcStateTerminated )
      {
        vl_msg := %definitionId&": Stop the entities of the traffic case "&v_LGenBase_trafficCases[vl_tcIdx].uniqueName&" has been timed out.";
        f_EPTF_LGenBase_logNotRespondedEntities(vl_tcIdx, "stop or abort")
      }
      case else
      {
        if(2 > sizeof(pl_action.actionId) or 1 != pl_action.actionId[1]){
          vl_msg :=%definitionId&": WARNING: "&": The traffic case is in invalid "&c_EPTF_LGenBase_stateNames[v_LGenBase_trafficCases[vl_tcIdx].state]&" state!";
        }else{
          vl_msg :=%definitionId&": WARNING: "&": Not all the entities answered to the stop or abort event. State: "&c_EPTF_LGenBase_stateNames[v_LGenBase_trafficCases[vl_tcIdx].state];
        }
        f_EPTF_LGenBase_logNotRespondedEntities(vl_tcIdx, "stop or abort")
      }
    }
    f_EPTF_FBQ_initFreeBusyQueue(v_LGenBase_trafficCases[vl_tcIdx].stoppingEntityInfo);
    f_EPTF_LGenBase_tcStateChanged(vl_tcIdx);
    f_EPTF_LGenBase_loggingWarning(vl_msg);
    return true;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_singleShotTc
  //
  //  Purpose:
  //    Starts a traffic on the first available entity in the traffic case.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_singleShotTc(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName,
    in integer pl_eIdx := -1
  )
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_tcIdx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName)
    f_EPTF_LGenBase_singleShotTcByIdx(vl_tcIdx,pl_eIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_singleShotTcByIdx
  //
  //  Purpose:
  //    Starts a traffic on the first available or the selected entity in the traffic case.
  //
  //  Detailed Comment:
  //    The index of the entity is realtive index in the entity group
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_singleShotTcByIdx(
    in integer pl_tcIdx,
    in integer pl_eIdx := -1,
    in boolean pl_singleShotDebug := false
  )
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    f_EPTF_Base_assert(%definitionId&": Invalid entity index: "&int2str(pl_eIdx),pl_eIdx < v_LGenBase_entityGroups[v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref].eCount)
    var integer vl_eIdxInTC := pl_eIdx
    if(0 > vl_eIdxInTC){
      vl_eIdxInTC := f_EPTF_LGenBase_getNextFreeEntity(pl_tcIdx)
    }else{
    }
    if (vl_eIdxInTC >=0) {
      var integer vl_logBufferVar := -1
      var integer vl_eAbsIdx := vl_eIdxInTC+v_LGenBase_entityGroups[v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref].eOffset
      if(pl_singleShotDebug){
        f_EPTF_Var_newCharstring(c_EPTF_LGenBase_fsmSingleShotVarPrefix&f_EPTF_LGenBase_getEntityName(vl_eAbsIdx), "", vl_logBufferVar)
        for ( var integer vl_postproc := 0; vl_postproc < sizeof(v_LGenBase_singleShotDebugPostprocList) ; vl_postproc := vl_postproc+1 ){
          f_EPTF_Var_addPostProcFn(vl_logBufferVar, v_LGenBase_singleShotDebugPostprocList[vl_postproc])
        }
      }
      v_LGenBase_dummyBool := f_EPTF_LGenBase_doStartStep(vl_eIdxInTC, pl_tcIdx, true, pl_singleShotDebug, vl_logBufferVar);
    }else{
      f_EPTF_LGenBase_loggingWarning(%definitionId&": There is no free entity in traffic case "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName)
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_singleShotSc
  //
  //  Purpose:
  //    Starts a traffic on the first available entity in the
  //    enabled traffic cases of the scenario.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_singleShotSc(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in integer pl_eIdx := -1
  )
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_eGrpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_eGrpName);
    f_EPTF_Base_assert(%definitionId&": Invalid entity group name: "&pl_eGrpName,-1 != vl_eGrpIdx);
    var integer vl_scIdx := f_EPTF_LGenBase_scNameIndexInEG(vl_eGrpIdx, pl_scName);
    f_EPTF_Base_assert(%definitionId&": Invalid scenario name: "&pl_scName,-1 != vl_scIdx);
    f_EPTF_LGenBase_singleShotScByIdx(vl_eGrpIdx, vl_scIdx, pl_eIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_singleShotScByIdx
  //
  //  Purpose:
  //    Starts a traffic on the first available entity in the
  //    enabled traffic cases of the scenario.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_singleShotScByIdx(
    in integer pl_eGrpIdx,
    in integer pl_scIdx,
    in integer pl_eIdx := -1
  )
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Invalid entity group index: "&int2str(pl_eGrpIdx),-1 < pl_eGrpIdx and pl_eGrpIdx < sizeof(v_LGenBase_entityGroups));
    f_EPTF_Base_assert(%definitionId&": Invalid scenario index: "&int2str(pl_scIdx),-1 < pl_scIdx and pl_scIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios));
    f_EPTF_Base_assert(%definitionId&": Invalid entity index: "&int2str(pl_eIdx),pl_eIdx < v_LGenBase_entityGroups[pl_eGrpIdx].eCount)
    var integer vl_tcCount := sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList)
    for ( var integer vl_i := 0; vl_i < vl_tcCount ; vl_i := vl_i+1 )
    {
      if(v_LGenBase_trafficCases[v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList[vl_i]].enabled){
        f_EPTF_LGenBase_singleShotTcByIdx(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList[vl_i], pl_eIdx);
      }
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_createScenarios2EntityGroup
  //
  //  Purpose:
  //    Adds a traffic case list to the entity group
  //
  //  Detailed Comments:
  //    This function creates the
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_TcMgmt_createScenarios2EntityGroup(
    in EPTF_LGenBase_TcMgmt_Scenarios2GrpList pl_list)
  runs on EPTF_LGenBase_Private_CT{
    for ( var integer vl_i := 0; vl_i < sizeof(pl_list) ; vl_i := vl_i+1 )
    {
      for ( var integer vl_sc := 0; vl_sc < sizeof(pl_list[vl_i].scenarioNames) ; vl_sc := vl_sc+1 )
      {
        f_EPTF_LGenBase_createScenario2EntityGroup({pl_list[vl_i].eGrpName, pl_list[vl_i].scenarioNames[vl_sc]},false);
      }
    }
  }
  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_createScenario2EntityGroup
  //
  //  Purpose:
  //    Adds a traffic case list to the entity group
  //
  //  Detailed Comments:
  //    This function creates the scenario to an entity group
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_createScenario2EntityGroup(
    in EPTF_LGenBase_Scenario2Grp pl_scenarioDesc,
    in boolean pl_autoStart := true)
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_eGrpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_scenarioDesc.eGrpName);
    if(vl_eGrpIdx == -1){
      f_EPTF_LGenBase_loggingError(%definitionId&": Invalid entity group: "&pl_scenarioDesc.eGrpName);
    }
    var integer vl_scIdx := f_EPTF_LGenBase_scenarioNameIndex(pl_scenarioDesc.scenarioName);
    if(vl_scIdx == -1){
      f_EPTF_LGenBase_loggingError(%definitionId&": Invalid scenario name: "&pl_scenarioDesc.scenarioName);
    }
    if(-1 != f_EPTF_LGenBase_scNameIndexInEG(vl_eGrpIdx, pl_scenarioDesc.scenarioName)){
      f_EPTF_LGenBase_loggingError(%definitionId&": Scenario "&pl_scenarioDesc.scenarioName&" already exists in group "&pl_scenarioDesc.eGrpName);
    }
    var EPTF_LGenBase_ScenarioOfGrp vl_sc := c_EPTF_LGenBase_emptyScenarioOfGrp;
    vl_sc.name := pl_scenarioDesc.scenarioName;
    vl_sc.uniqueName := pl_scenarioDesc.eGrpName&tsp_LGenBase_nameSeparator&pl_scenarioDesc.scenarioName;
    vl_sc.weightedScData := v_LGenBase_scenarioTypes[vl_scIdx].weightedScData;//EGBOZIE: new, is omit for weighted scenario
    vl_sc.phaseData := v_LGenBase_scenarioTypes[vl_scIdx].phaseData;// phase data
    var integer vl_scIdxInGrp := sizeof(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios);
    var integer vl_tcCount := sizeof(v_LGenBase_scenarioTypes[vl_scIdx].tcList);
    var boolean vl_isWeightedSc := ispresent(vl_sc.weightedScData);//EGBOZIE
    var EPTF_ProbabilityList vl_new_wList := {};//EGBOZIE used only for weighted SC
    var integer vl_tcAbsIdx;
    vl_sc.absIdx := f_EPTF_FBQ_getOrCreateFreeSlot(v_LGenBase_scenarios);
    vl_sc.trafficType := v_LGenBase_scenarioTypes[vl_scIdx].trafficType
    f_EPTF_FBQ_setQueueDidx(vl_sc.absIdx, {vl_eGrpIdx,vl_scIdxInGrp}, v_LGenBase_scenarios);
    f_EPTF_FBQ_moveFromFreeToBusyTail(vl_sc.absIdx, v_LGenBase_scenarios);
    v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp] := vl_sc;
    //Create and initialize all the traffic case specimen
    for(var integer vl_i := 0;  vl_i < vl_tcCount; vl_i := vl_i + 1){
      vl_tcAbsIdx := f_EPTF_LGenBase_createTc2EntityGroup(
        v_LGenBase_scenarioTypes[vl_scIdx].tcList[vl_i],
        vl_eGrpIdx,
        vl_scIdxInGrp,
        v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp]);
      f_EPTF_Base_assert(%definitionId&": Error assigning the traffic case "&
        v_LGenBase_scenarioTypes[vl_scIdx].tcList[vl_i].tcPrivateName&" to group "&
        pl_scenarioDesc.eGrpName, -1 != v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].tcIdxList[vl_i]);
      //vl_tcAbsIdx := vl_sc.tcIdxList[vl_i];
      
    }
    for(var integer vl_i := 0;  vl_i < vl_tcCount; vl_i := vl_i + 1){
      vl_tcAbsIdx := v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].tcIdxList[vl_i];
      v_LGenBase_trafficCases[vl_tcAbsIdx].trafficStartFinishConditionsAndActions := c_EPTF_LGenBase_emptyTrafficStartFinishConditionsAndActionsDesc;
      if(v_LGenBase_scenarioTypes[vl_scIdx].conditionsFromTc){
        //Use conditions and actions declared in the tc type declaration
        f_EPTF_LGenBase_convertTrafficStartFinishConditionsInternalDeclarator2Desc(
          v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp],
          v_LGenBase_trafficCaseTypes[v_LGenBase_trafficCases[vl_tcAbsIdx].tcTypeIdx].trafficStartFinishConditions,
          v_LGenBase_trafficCases[vl_tcAbsIdx].trafficStartFinishConditionsAndActions)
        f_EPTF_LGenBase_convertEntityFinishConditionsInternalDeclarator2Desc(
          v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp],
          v_LGenBase_trafficCaseTypes[v_LGenBase_trafficCases[vl_tcAbsIdx].tcTypeIdx].entityFinishConditions,
          v_LGenBase_trafficCases[vl_tcAbsIdx].entityFinishConditions)
        f_EPTF_Base_assert(%definitionId&": There is range loop condition without range",
          (not ispresent(v_LGenBase_trafficCases[vl_tcAbsIdx].trafficStartFinishConditionsAndActions.nrOfRangeLoop))or
          v_LGenBase_trafficCases[vl_tcAbsIdx].v_sizeofRanges > 0);
        f_EPTF_LGenBase_convertTcEntityFinishActions2Desc(
          v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp],
          v_LGenBase_trafficCaseTypes[v_LGenBase_trafficCases[vl_tcAbsIdx].tcTypeIdx].entityFinishActions,
          v_LGenBase_trafficCases[vl_tcAbsIdx].entityFinishActions);
        f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList(
          v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp],
          v_LGenBase_trafficCaseTypes[v_LGenBase_trafficCases[vl_tcAbsIdx].tcTypeIdx].trafficFinishedActions,
          v_LGenBase_trafficCases[vl_tcAbsIdx].trafficFinishedActions);
      }else{
        //Use conditions and actions declared in the tcOfScenario
        f_EPTF_LGenBase_convertEntityFinishConditionsInternalDeclarator2Desc(
          v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp],
          v_LGenBase_scenarioTypes[vl_scIdx].tcList[vl_i].entityFinishConditions,
          v_LGenBase_trafficCases[vl_tcAbsIdx].entityFinishConditions);
        f_EPTF_LGenBase_convertTrafficStartFinishConditionsInternalDeclarator2Desc(
          v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp],
          v_LGenBase_scenarioTypes[vl_scIdx].tcList[vl_i].trafficStartFinishConditionsAndActions,
          v_LGenBase_trafficCases[vl_tcAbsIdx].trafficStartFinishConditionsAndActions);
        f_EPTF_LGenBase_convertTcEntityFinishActions2Desc(
          v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp],
          v_LGenBase_scenarioTypes[vl_scIdx].tcList[vl_i].entityFinishActions,
          v_LGenBase_trafficCases[vl_tcAbsIdx].entityFinishActions);
        f_EPTF_LGenBase_convertGroupActionsList2GroupActionsDescList(
          v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp],
          v_LGenBase_scenarioTypes[vl_scIdx].tcList[vl_i].trafficFinishedActions,
          v_LGenBase_trafficCases[vl_tcAbsIdx].trafficFinishedActions);
      }
      v_LGenBase_trafficCases[vl_tcAbsIdx].paramRanges := v_LGenBase_scenarioTypes[vl_scIdx].tcList[vl_i].ranges;
      v_LGenBase_trafficCases[vl_tcAbsIdx].v_sizeofRanges := sizeof(v_LGenBase_trafficCases[vl_tcAbsIdx].paramRanges);
      
      v_LGenBase_trafficCases[vl_tcAbsIdx].customParams := v_LGenBase_scenarioTypes[vl_scIdx].tcList[vl_i].params;
      
      var integer vl_paramCount := sizeof(v_LGenBase_trafficCases[vl_tcAbsIdx].customParams);
      for ( var integer vl_par := 0; vl_par < vl_paramCount ; vl_par := vl_par+1 )
      {
        f_EPTF_str2int_HashMap_Insert(v_LGenBase_trafficCases[vl_tcAbsIdx].paramHashMap,
          v_LGenBase_trafficCases[vl_tcAbsIdx].customParams[vl_par].aName&
          tsp_LGenBase_nameSeparator&
          v_LGenBase_trafficCases[vl_tcAbsIdx].customParams[vl_par].pName,
          vl_par);
      }
      
      
      if (vl_isWeightedSc){
        var integer vl_tcIdx := v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].tcIdxList[vl_i];
        f_EPTF_Base_assert(%definitionId&": collecting traffic weights: TC["&int2str(vl_i)&"] in weighted SC shall have a weight instead of cpsToReach!",
          ischosen(v_LGenBase_trafficCases[vl_tcIdx].schedulerData.target.trafficWeight));
        if (v_LGenBase_trafficCases[v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].tcIdxList[vl_i]].enabled) {
          vl_new_wList[vl_i] := v_LGenBase_trafficCases[vl_tcIdx].schedulerData.target.trafficWeight;
        } else {
          vl_new_wList[vl_i] := 0.0;
        }
      }
    }
    //now take care for extra data in case of weighted scenario
    if (vl_isWeightedSc) {
      
      v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].schedulerData := c_EPTF_LGenBase_emptySchedulerData4TcWeight
      v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].schedulerData.target.cpsToReach := v_LGenBase_scenarioTypes[vl_scIdx].weightedScData.cpsToReach
      v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].schedulerData.roundedCpsUpdateInterval := tsp_EPTF_cpsUpdateInterval
      //{{"cs", null, null}, false, {cpsToReach:= v_LGenBase_scenarioTypes[vl_scIdx].weightedScData.cpsToReach},0,0,0.0,tsp_EPTF_cpsUpdateInterval,0.0,-1,0,{false,0.0,{}}}
      // setting burst calc for weighted
      var charstring vl_burstName;
      if(ispresent(v_LGenBase_scenarioTypes[vl_scIdx].weightedScData.scheduler)) {
        if(ischosen(v_LGenBase_scenarioTypes[vl_scIdx].weightedScData.scheduler.preDefinedName)){
          vl_burstName := f_EPTF_LGenBase_BurstFuncName2Char(v_LGenBase_scenarioTypes[vl_scIdx].weightedScData.scheduler.preDefinedName);
        } else {
          vl_burstName := v_LGenBase_scenarioTypes[vl_scIdx].weightedScData.scheduler.userDefinedName;
        }
      } else {
        if("" != v_LGenBase_burstCalcMode) {
          vl_burstName := v_LGenBase_burstCalcMode;
        } else {
          f_EPTF_Base_assert(%definitionId&"No Global or Local burst calculation method is set.",false);
        }
      }
      
      var integer vl_burstId;
      vl_burstId := f_EPTF_LGenBase_getBurstCalcFunctionId(vl_burstName);
      v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].schedulerData.burstFuncRef.burstCalcMode := v_LGenBase_burstFuncRefList[vl_burstId].burstCalcMode;
      v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].schedulerData.burstFuncRef.burstPreCalc := v_LGenBase_burstFuncRefList[vl_burstId].burstPreCalc;
      v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].schedulerData.burstFuncRef.burstPostCalc := v_LGenBase_burstFuncRefList[vl_burstId].burstPostCalc;
      
      
      f_EPTF_LGenBase_adjustSchedulerData4NewCps(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].schedulerData);
      // distribute the bursterror differently according to the traffic corrigation => smooth out cumulative bursts
      v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].schedulerData.burstSizeCumulativeError := v_LGenBase_entityGroups[vl_eGrpIdx].trafficCorrigation;
      v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].trafficMixData := {
        wList := vl_new_wList, // initial weight of each traffic
        pList := {}, // probability of each traffic ( == eloszlas-Fv), will be inited later
        currentBurst := {},
        burstList := {},
        burstListIdx := 0
      }
      var boolean vl_mixerAcceptsMix := f_EPTF_TrafficMixer_acceptNewTrafficMix(
        v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].trafficMixData,
        vl_new_wList,
        v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].weightedScData.deterministicMix
      );
      f_EPTF_Base_assert(%definitionId&": initializing traffic mix for TC in weighted SC "&pl_scenarioDesc.scenarioName& ": mixer has not accepted traffic mix",
        vl_mixerAcceptsMix);
    }
    if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
      f_EPTF_LGenBase_loggingDebugConfig(%definitionId&": constructed scenario:"&log2str(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp]))
    }
    f_EPTF_LGenBaseStats_createScenarioVars(vl_eGrpIdx, vl_scIdxInGrp);
    for (var integer x:= 0; x<sizeof(v_LGenBase_scenarioCreated); x:= x+1)
    {
      v_LGenBase_scenarioCreated[x].apply( vl_eGrpIdx, vl_scIdxInGrp );
    }
    for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].tcIdxList) ; vl_i := vl_i+1 )
    {
      f_EPTF_LGenBase_tcStateChanged(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].tcIdxList[vl_i]);
    }
    for ( var integer vl_tc := 0; vl_tc < sizeof(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].tcIdxList) ; vl_tc := vl_tc+1 )
    {
      vl_tcAbsIdx := v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].tcIdxList[vl_tc]
      for (var integer x:= 0; x<sizeof(v_LGenBase_trafficCaseCreated); x:= x+1)
      {
        v_LGenBase_trafficCaseCreated[x].apply( vl_tcAbsIdx );
      }
    }
    
    var boolean vl_autoStart := pl_autoStart;
    if(ispresent(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].phaseData)){
      vl_autoStart := false; // if phase information exists disabling automatic scenario generation
    }
    if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
      f_EPTF_LGenBase_loggingDebugConfig(%definitionId&": The created scenario: "&log2str( v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp] ))
      f_EPTF_LGenBase_loggingDebugConfig(%definitionId&": The traffic cases: ")
      for ( var integer vl_t := 0; vl_t < sizeof(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].tcIdxList) ; vl_t := vl_t+1 )
      {
        f_EPTF_LGenBase_loggingDebugConfig(%definitionId&": "&log2str(v_LGenBase_trafficCases[v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdxInGrp].tcIdxList[vl_t]]))
      }
    }
    //EGBOZIE: code refactored into a standalone function
    f_EPTF_LGenBase_enableScenarioOnEntityGroup(
      vl_eGrpIdx, //entity group
      vl_scIdxInGrp, //scenario index in group
      vl_autoStart or terminating == vl_sc.trafficType)
  }
  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_restoreScenario
  //
  //  Purpose:
  //    Initializes the entities and the statistics of a traffic cases of the scenario.
  //
  //  Detailed Comments:
  //    This function is used to reset the entities and the statistics
  //    of the traffic casees of a scenario before restart. If pl_autoStart
  //    and the enabled field of the declarator of the traffic case is true, starts the affected traffic cases
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_restoreScenario(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in boolean pl_autoStart := true
  )
  runs on EPTF_LGenBase_Private_CT
  return boolean
  {
    var integer vl_eGrpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_eGrpName);
    f_EPTF_Base_assert(%definitionId&": Invalid entity group name: "&pl_eGrpName,-1 != vl_eGrpIdx);
    var integer vl_scIdx := f_EPTF_LGenBase_scNameIndexInEG(vl_eGrpIdx, pl_scName);
    f_EPTF_Base_assert(%definitionId&": Invalid scenario name: "&pl_scName,-1 != vl_scIdx);
    return f_EPTF_LGenBase_restoreScenarioByIdx(vl_eGrpIdx, vl_scIdx, pl_autoStart);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_restoreScenarioByIdx
  //
  //  Purpose:
  //    Initializes the entities and the statistics of a traffic cases of the scenario.
  //
  //  Detailed Comments:
  //    This function is used to reset the entities and the statistics
  //    of the traffic casees of a scenario before restart. If pl_autoStart
  //    and the enabled field of the declarator of the traffic case is true, starts the affected traffic cases
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_restoreScenarioByIdx(
    in integer pl_eGrpIdx,
    in integer pl_scIdx,
    in boolean pl_autoStart := true
  )
  runs on EPTF_LGenBase_Private_CT
  return boolean
  {
    var integer vl_max := sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList);
    for ( var integer vl_i := 0; vl_i < vl_max ; vl_i := vl_i+1 )
    {
      var integer vl_tcIdx := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList[vl_i];
      if(c_EPTF_LGenBase_tcStateRunning == v_LGenBase_trafficCases[vl_tcIdx].state){
        f_EPTF_LGenBase_loggingWarning(%definitionId&": The running traffic case "&v_LGenBase_trafficCases[vl_tcIdx].uniqueName&" can not be restored!");
        return false;
      }
    }
    var boolean vl_ret := true;
    for ( var integer vl_i := 0; vl_i < vl_max ; vl_i := vl_i+1 )
    {
      var integer vl_tcIdx := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList[vl_i];
      if(not f_EPTF_LGenBase_restoreTCbyIdx(vl_tcIdx)) { vl_ret := false; }
      if(v_LGenBase_trafficCases[vl_tcIdx].enabledAtStartup){
        f_EPTF_LGenBase_enableTrafficCaseInternal(
          vl_tcIdx,
          pl_autoStart);
      }else{
        v_LGenBase_trafficCases[vl_tcIdx].enabled := false;
      }
    }
    return vl_ret;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_restoreTC
  //
  //  Purpose:
  //    Initializes the entities and the statistics of a traffic case
  //
  //  Detailed Comments:
  //    This function is used to reset the entities and the statistics
  //    of a traffic case before restart.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_restoreTC(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName
  )
  runs on EPTF_LGenBase_Private_CT
  return boolean
  {
    var integer vl_tcIdx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName);
    return f_EPTF_LGenBase_restoreTCbyIdx(vl_tcIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_restoreTCbyIdx
  //
  //  Purpose:
  //    Initializes the entities and the statistics of a traffic case
  //
  //  Detailed Comments:
  //    This function is used to reset the entities and the statistics
  //    of a traffic case before restart.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_restoreTCbyIdx(
    in integer pl_tcIdx
  )
  runs on EPTF_LGenBase_Private_CT
  return boolean
  {
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index",pl_tcIdx> -1 and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    if(c_EPTF_LGenBase_tcStateRunning == v_LGenBase_trafficCases[pl_tcIdx].state){
      f_EPTF_LGenBase_loggingWarning(%definitionId&": The running traffic case "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName&" can not be restored!");
      return false;
    }
    if(-1 != v_LGenBase_trafficCases[pl_tcIdx].stopTimeoutTimer){
      if(not f_EPTF_SchedulerComp_CancelEvent(v_LGenBase_trafficCases[pl_tcIdx].stopTimeoutTimer)) {
        f_EPTF_LGenBase_loggingWarning(%definitionId&": Cancelling stop timeout timer failed.");
      }
      v_LGenBase_trafficCases[pl_tcIdx].stopTimeoutTimer := -1;
      v_LGenBase_trafficCases[pl_tcIdx].stoppingEntityInfo := c_EPTF_emptyFreeBusyQueue;
    }
    f_EPTF_LGenBase_initTCInternal(
      v_LGenBase_trafficCases[pl_tcIdx],
      pl_tcIdx,
      v_LGenBase_trafficCases[pl_tcIdx].enableEntitiesAtStartup,
      false
    )
    v_LGenBase_trafficCases[pl_tcIdx].state := c_EPTF_LGenBase_tcStateIdle;
    f_EPTF_LGenBase_tcStateChanged(pl_tcIdx);
    return true;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_abortTrafficCase
  //
  //  Purpose:
  //    Sends <c_EPTF_LGenBase_inputIdx_testMgmt_abortTC> to the
  //    entities in the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_abortTrafficCase(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName
  )
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_eGrpIdx := f_EPTF_LGenBase_entityGrpNameIndex(pl_eGrpName);
    f_EPTF_Base_assert(%definitionId&": Invalid entity group name: "&pl_eGrpName,-1 != vl_eGrpIdx);
    var integer vl_scIdx := f_EPTF_LGenBase_scNameIndexInEG(vl_eGrpIdx, pl_scName);
    f_EPTF_Base_assert(%definitionId&": Invalid scenario name: "&pl_scName,-1 != vl_scIdx);
    var integer vl_tcIdx := f_EPTF_LGenBase_tcOfScenario(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx], pl_tcName);
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case name: "&pl_scName,-1 != vl_tcIdx);
    f_EPTF_LGenBase_abortTrafficCaseByIdx(f_EPTF_LGenBase_trafficCaseAbsIdx(vl_eGrpIdx, vl_scIdx, vl_tcIdx));
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_stopWeightedScenarioByIdx
  //
  //  Purpose:
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_stopWeightedScenarioByIdx(
    in integer pl_eGrpIdx,
    in integer pl_scInGrpIdx)
  runs on EPTF_LGenBase_Private_CT{
    if (v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData.schedulingTimer>-1) {
      f_EPTF_LGenBase_stopScTimerInternal(pl_eGrpIdx,pl_scInGrpIdx);
    }
    f_EPTF_LGenBase_stopScenarioByIdx(pl_eGrpIdx,pl_scInGrpIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_stopScenarioByIdx
  //
  //  Purpose:
  //    Sends <c_EPTF_LGenBase_inputIdx_testMgmt_abortTC> to the
  //    entities in the traffic cases of the scenario
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_stopScenarioByIdx(
    in integer pl_eGrpIdx,
    in integer pl_scInGrpIdx)
  runs on EPTF_LGenBase_Private_CT{
    if(terminating == v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].trafficType){
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Stop called for terminating scenario "&
        v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].uniqueName&
        ". The feature is not implemented yet.");
      return;
    }
    for ( var integer vl_tc := 0; vl_tc < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].tcIdxList) ; vl_tc := vl_tc+1 )
    {
      var integer vl_tcIdx := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].tcIdxList[vl_tc];
      f_EPTF_LGenBase_stopTrafficCaseByIdx(vl_tcIdx);
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_abortWeightedScenarioByIdx
  //
  //  Purpose:
  //    Sends <c_EPTF_LGenBase_inputIdx_testMgmt_abortTC> to the
  //    entities in the traffic cases of the scenario
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_abortWeightedScenarioByIdx(
    in integer pl_eGrpIdx,
    in integer pl_scInGrpIdx)
  runs on EPTF_LGenBase_Private_CT{
    if (v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData.schedulingTimer>-1) {
      f_EPTF_LGenBase_stopScTimerInternal(pl_eGrpIdx,pl_scInGrpIdx);
    }
    f_EPTF_LGenBase_abortScenarioByIdx(pl_eGrpIdx,pl_scInGrpIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_abortScenarioByIdx
  //
  //  Purpose:
  //    Sends <c_EPTF_LGenBase_inputIdx_testMgmt_abortTC> to the
  //    entities in the traffic cases of the scenario
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_abortScenarioByIdx(
    in integer pl_eGrpIdx,
    in integer pl_scInGrpIdx)
  runs on EPTF_LGenBase_Private_CT{
    if(terminating == v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].trafficType){
      f_EPTF_LGenBase_loggingWarning(%definitionId&": Abort called for terminating scenario "&
        v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].uniqueName&
        ". The feature is not implemented yet.");
      return;
    }
    for ( var integer vl_tc := 0; vl_tc < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].tcIdxList) ; vl_tc := vl_tc+1 )
    {
      var integer vl_tcIdx := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].tcIdxList[vl_tc];
      f_EPTF_LGenBase_abortTrafficCaseByIdx(vl_tcIdx);
    }
  }
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_abortTrafficCaseByIdx
  //
  //  Purpose:
  //    Sends <c_EPTF_LGenBase_inputIdx_testMgmt_abortTC> to the
  //    entities in the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_abortTrafficCaseByIdx(
    in integer pl_tcIdx
  )
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcIdx),-1 < pl_tcIdx and pl_tcIdx < sizeof(v_LGenBase_trafficCases));
    f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
    v_LGenBase_trafficCases[pl_tcIdx].stopped := true
    f_EPTF_LGenBase_disableTrafficCaseInternal(pl_tcIdx);
    v_LGenBase_trafficCases[pl_tcIdx].state := c_EPTF_LGenBase_tcStateAborting;
    f_EPTF_LGenBase_tcStateChanged(pl_tcIdx);
    f_EPTF_FBQ_initFreeBusyQueue(v_LGenBase_trafficCases[pl_tcIdx].stoppingEntityInfo);
    //var integer vl_maxEntities := sizeof(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList);
    //f_EPTF_FBQ_createFreeSlots(vl_maxEntities, v_LGenBase_trafficCases[pl_tcIdx].stoppingEntityInfo);
    var integer vl_maxEntity := v_LGenBase_entityGroups[v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref].eCount;
    f_EPTF_FBQ_createFreeSlots(vl_maxEntity, v_LGenBase_trafficCases[pl_tcIdx].stoppingEntityInfo);
    if(not f_EPTF_SchedulerComp_scheduleAction(
        T_EPTF_componentClock.read + tsp_EPTF_LGenBase_abortStopProcess,
        refers(f_EPTF_LGenBase_stopProcessTimedOut),
        {pl_tcIdx,0},
        v_LGenBase_trafficCases[pl_tcIdx].stopTimeoutTimer)) {
      f_EPTF_LGenBase_loggingError(%definitionId&" Can not schedule the timer event to abort the stop process.");
      f_EPTF_Base_stop();
    }
    v_LGenBase_trafficCases[pl_tcIdx].lastCPS := 0.0;
    for ( var integer vl_i := 0; vl_i < vl_maxEntity ; vl_i := vl_i+1 )
    {
      var EPTF_LGenBase_ReportedEventDescriptor vl_abortTcOfFsmEvent := c_EPTF_LGenBase_emptyReportedEventDescriptor;
      vl_abortTcOfFsmEvent.event.bIdx := c_EPTF_LGenBase_bIdx;
      vl_abortTcOfFsmEvent.event.iIdx := c_EPTF_LGenBase_inputIdx_testMgmt_abortTC;
      vl_abortTcOfFsmEvent.event.target := {
        eIdx := v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[vl_i].entityIdx,
        fsmCtxIdx := f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc(vl_i, pl_tcIdx, 0)
      };
      vl_abortTcOfFsmEvent.reportedArgs := {pl_tcIdx};
      f_EPTF_LGenBase_dispatchEvent(vl_abortTcOfFsmEvent);
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_startLaunchTC
  //
  //  Purpose:
  //    Initializes and starts a traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_startLaunchTC(
    in integer pl_tcIdx,
    in boolean pl_silentIfRunning := false)
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Start traffic case "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
    var EPTF_LGenBase_tcState vl_statePrev := v_LGenBase_trafficCases[pl_tcIdx].state;
    if(c_EPTF_LGenBase_tcStatePaused != vl_statePrev and
      c_EPTF_LGenBase_tcStateStopped != vl_statePrev and
      c_EPTF_LGenBase_tcStateAborted != vl_statePrev and
      c_EPTF_LGenBase_tcStateIdle != vl_statePrev and
      c_EPTF_LGenBase_tcStateTerminated != vl_statePrev){
      if(c_EPTF_LGenBase_tcStateRunning != vl_statePrev or not pl_silentIfRunning){
        f_EPTF_LGenBase_loggingWarning(%definitionId&": Start launch called for tc "&
          v_LGenBase_trafficCases[pl_tcIdx].uniqueName&" in state "&c_EPTF_LGenBase_stateNames[vl_statePrev]);
      }
      return;
    }
    if(not v_LGenBase_trafficCases[pl_tcIdx].enabled){
      f_EPTF_LGenBase_loggingWarning(%definitionId&": Start launch called for the disabled tc "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
      return;
    }
    v_LGenBase_trafficCases[pl_tcIdx].state := c_EPTF_LGenBase_tcStateRunning;
    
    //TR: MTTSM00016010
    if(c_EPTF_LGenBase_tcStatePaused != vl_statePrev) {
      f_EPTF_SchedulerComp_refreshSnapshotTime();
      v_LGenBase_trafficCases[pl_tcIdx].startTime := f_EPTF_SchedulerComp_snapshotTime();
      f_EPTF_LGenBase_startExecTimeTimer(pl_tcIdx);  // starts execTime timer if needed, not part of the TR correction
    }
    //~TR
    var integer vl_eGrpIdx := v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref
    var integer vl_scInGrpIdx := v_LGenBase_trafficCases[pl_tcIdx].eScenarioBackRef
    var float vl_stTimeDelay := v_LGenBase_trafficCases[pl_tcIdx].startDelay;
    // distribute the bursterror differently according to the traffic corrigation => smooth out cumulative bursts
    v_LGenBase_trafficCases[pl_tcIdx].schedulerData.burstSizeCumulativeError := v_LGenBase_entityGroups[vl_eGrpIdx].trafficCorrigation;
    
    if( 0.0 == vl_stTimeDelay ){ vl_stTimeDelay := 0.01;}  // FIXME: magic number again
    
    if(not f_EPTF_LGenBase_isWeightedScenario(vl_eGrpIdx, vl_scInGrpIdx)){
      if(originating == v_LGenBase_trafficCases[pl_tcIdx].trafficType and
        ischosen(v_LGenBase_trafficCases[pl_tcIdx].schedulerData.target.cpsToReach) and
        0.0 < v_LGenBase_trafficCases[pl_tcIdx].schedulerData.target.cpsToReach){
        // set different start time for different LGens => smooth out synchronous call generation (far small CPS):
        var float vl_stTrafficCorrigation := v_LGenBase_entityGroups[vl_eGrpIdx].trafficCorrigation/v_LGenBase_trafficCases[pl_tcIdx].schedulerData.target.cpsToReach;
        if(not f_EPTF_SchedulerComp_scheduleAction(
            v_LGenBase_trafficCases[pl_tcIdx].startTime+vl_stTimeDelay+vl_stTrafficCorrigation,
            refers(f_EPTF_LGenBase_doTrafficCaseTimerAction),
            {pl_tcIdx},
            v_LGenBase_trafficCases[pl_tcIdx].schedulingTimer)) {
          f_EPTF_LGenBase_loggingError(%definitionId&" Can not schedule timer event to delay the start of the traffic case .");
          f_EPTF_Base_stop();
        }
      }
    }else{
      var boolean vl_mixerAcceptsMix := f_EPTF_TrafficMixer_acceptNewTrafficMix(
        v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].trafficMixData,
        f_EPTF_LGenBase_getEnabledWeightListFromScenario(vl_eGrpIdx,vl_scInGrpIdx),
        v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].weightedScData.deterministicMix
      )
      f_EPTF_Base_assert(%definitionId&": initializing traffic mix for TC in weighted SC "&v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].name& ": mixer has not accepted traffic mix",
        vl_mixerAcceptsMix);
      
      f_EPTF_LGenBase_tcStateChanged(pl_tcIdx);
      return;
    }
    if(c_EPTF_LGenBase_tcStatePaused != vl_statePrev){
      f_EPTF_LGenBase_resetTcStats(pl_tcIdx, v_LGenBase_trafficCases[pl_tcIdx]);
      Inc(v_LGenBase_entityGroups[v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref].scenarios[v_LGenBase_trafficCases[pl_tcIdx].eScenarioBackRef].startedTcs);
      for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_tcStartedOrStoppedCallbacks) ; vl_i := vl_i+1 )
      {
        v_LGenBase_tcStartedOrStoppedCallbacks[vl_i].apply( pl_tcIdx, true );
      }
      f_EPTF_LGenBase_dispatchEvent({
          event := {
            bIdx := c_EPTF_LGenBase_bIdx,
            iIdx := c_EPTF_LGenBase_inputIdx_testMgmt_trafficCaseStarted,
            target := omit,
            source := omit
          },
          reportedArgs := {pl_tcIdx}
        });
    }
    f_EPTF_LGenBase_tcStateChanged(pl_tcIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_startLaunchWeightedScenario
  //
  //  Purpose:
  //    Initializes and starts a traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_startLaunchWeightedScenario(
    in integer pl_eGrpIdx,
    in integer pl_scInGrpIdx,
    in boolean pl_checkRunningState := true)
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Start weighted scenario "&v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].name
      & " of group " & v_LGenBase_entityGroups[pl_eGrpIdx].name);
    f_EPTF_Base_assert(%definitionId&": The scenario "&
      v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].uniqueName&" is not weighted.",
      f_EPTF_LGenBase_isWeightedScenario(pl_eGrpIdx, pl_scInGrpIdx))
    v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData.lastBurstSize := 0;
    f_EPTF_LGenBase_adjustSchedulerData4NewCps(
      v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData)
    
    // distribute the bursterror differently according to the traffic corrigation => smooth out cumulative bursts
    v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData.burstSizeCumulativeError := v_LGenBase_entityGroups[pl_eGrpIdx].trafficCorrigation;

    var EPTF_LGenBase_tcState vl_scStatePrev := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].state;
    if(pl_checkRunningState and
      c_EPTF_LGenBase_tcStatePaused != vl_scStatePrev and
      c_EPTF_LGenBase_tcStateStopped != vl_scStatePrev and
      c_EPTF_LGenBase_tcStateAborted != vl_scStatePrev and
      c_EPTF_LGenBase_tcStateIdle != vl_scStatePrev and
      c_EPTF_LGenBase_tcStateTerminated != vl_scStatePrev){
      f_EPTF_LGenBase_loggingWarning(%definitionId&": Start launch called for weighted scenario "&
        v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].uniqueName&
        " in state "&c_EPTF_LGenBase_stateNames[vl_scStatePrev]&
        "\nThe command can not be executed.");
      if(c_EPTF_LGenBase_tcStateRunning != vl_scStatePrev or
        -1 != v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData.schedulingTimer){
        return
      }
    }
    if(not v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].enabled){
      f_EPTF_LGenBase_loggingWarning(%definitionId&": Start launch called for the disabled scenario "&v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].uniqueName);
      return;
    }
    if(c_EPTF_LGenBase_tcStateStopped == vl_scStatePrev or
      c_EPTF_LGenBase_tcStateAborted == vl_scStatePrev or
      c_EPTF_LGenBase_tcStateTerminated == vl_scStatePrev) {
      var boolean vl_ret := f_EPTF_LGenBase_restoreScenarioByIdx(pl_eGrpIdx, pl_scInGrpIdx, false);
      // f_EPTF_LGenBase_restoreScenarioByIdx should fail only if the scenario is running.
      f_EPTF_Base_assert(%definitionId&": restore scenario failed. eGrpIdx: " & int2str(pl_eGrpIdx) &
        ", scInGrpIdx: " & int2str(pl_scInGrpIdx) & ", scState: " &int2str(vl_scStatePrev), vl_ret);
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": generating new traffic mix.");
      if(f_EPTF_LGenBase_isWeightedScenario(pl_eGrpIdx, pl_scInGrpIdx))
      {
        var boolean vl_mixerAcceptsMix := f_EPTF_TrafficMixer_acceptNewTrafficMix(
          v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].trafficMixData,
          f_EPTF_LGenBase_getEnabledWeightListFromScenario(pl_eGrpIdx,pl_scInGrpIdx),
          v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].weightedScData.deterministicMix
        )
        f_EPTF_Base_assert(%definitionId&": initializing traffic mix for TC in weighted SC "&v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].name& ": mixer has not accepted traffic mix",
          vl_mixerAcceptsMix);
      }
    }
    
    var float vl_now := T_EPTF_componentClock.read;
    var boolean vl_paused := c_EPTF_LGenBase_tcStatePaused == v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].state;
    for ( var integer vl_tc := 0; vl_tc < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].tcIdxList) ; vl_tc := vl_tc+1 )
    {
      var integer vl_tcIdx := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].tcIdxList[vl_tc];
      if(v_LGenBase_trafficCases[vl_tcIdx].enabled){
        v_LGenBase_trafficCases[vl_tcIdx].state := c_EPTF_LGenBase_tcStateRunning;
        
        //TR: MTTSM00016010
        if(c_EPTF_LGenBase_tcStatePaused != vl_scStatePrev) {
          v_LGenBase_trafficCases[vl_tcIdx].startTime := vl_now;
          f_EPTF_LGenBase_startExecTimeTimer(vl_tcIdx);  // starts execTime timer if needed, not part of the TR correction
        }
        //~TR
        
        // distribute the bursterror differently according to the traffic corrigation => smooth out cumulative bursts
        v_LGenBase_trafficCases[vl_tcIdx].schedulerData.burstSizeCumulativeError := v_LGenBase_entityGroups[pl_eGrpIdx].trafficCorrigation;
        if(not vl_paused){
          Inc(v_LGenBase_entityGroups[v_LGenBase_trafficCases[vl_tcIdx].eGroupBackref].scenarios[v_LGenBase_trafficCases[vl_tcIdx].eScenarioBackRef].startedTcs);
          f_EPTF_LGenBase_resetTcStats(vl_tcIdx, v_LGenBase_trafficCases[vl_tcIdx]);
          f_EPTF_LGenBase_dispatchEvent({
              event := {
                bIdx := c_EPTF_LGenBase_bIdx,
                iIdx := c_EPTF_LGenBase_inputIdx_testMgmt_trafficCaseStarted,
                target := omit,
                source := omit
              },
              reportedArgs := {vl_tcIdx}
            });
          for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_tcStartedOrStoppedCallbacks) ; vl_i := vl_i+1 )
          {
            v_LGenBase_tcStartedOrStoppedCallbacks[vl_i].apply( vl_tcIdx, true );
          }
          f_EPTF_LGenBase_tcStateChanged(vl_tcIdx);
        }
      }
    }
    if(originating == v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].trafficType and
      ischosen(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData.target.cpsToReach) and
      0.0 < v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData.target.cpsToReach){
      // set different start time for different LGens => smooth out synchronous call generation (far small CPS):
      var float vl_stTrafficCorrigation := v_LGenBase_entityGroups[pl_eGrpIdx].trafficCorrigation/v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData.target.cpsToReach;
      // if event is not scheduled, schedule it:
      if(-1 == v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData.schedulingTimer and
        not f_EPTF_SchedulerComp_scheduleAction(
          vl_now/*+vl_stTimeDelay*/+vl_stTrafficCorrigation,
          refers(f_EPTF_LGenBase_doWeightedScenarioTimerAction),
          {pl_eGrpIdx,pl_scInGrpIdx},
          v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData.schedulingTimer)) {
        f_EPTF_LGenBase_loggingError(%definitionId&" Can not schedule scenario timer event.");
      }
    }
    f_EPTF_LGenBase_setScNewState(pl_eGrpIdx, pl_scInGrpIdx, c_EPTF_LGenBase_tcStateRunning);
  }
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_pauseWeightedScenario
  //
  //  Purpose:
  //    Initializes and starts a traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_pauseWeightedScenario(
    in integer pl_eGrpIdx,
    in integer pl_scInGrpIdx)
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Pausing weighted weighted scenario "&v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].name
      & " of group " & v_LGenBase_entityGroups[pl_eGrpIdx].name);
    if (v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData.schedulingTimer>-1) {
      f_EPTF_LGenBase_stopScTimerInternal(pl_eGrpIdx,pl_scInGrpIdx);
    }
    f_EPTF_LGenBase_setScNewState(pl_eGrpIdx, pl_scInGrpIdx, c_EPTF_LGenBase_tcStatePaused);
    
    // MTTSM00016748 - if a traffic case is finished (launchFinish) while the scenario is paused but there are still active TCs,
    //  checkTcState would put the scenario state back to "Running" (without re-starting the timer-action)
    //  fix: also set the state of the TCs to "Paused"
    for ( var integer vl_tc := 0; vl_tc < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].tcIdxList) ; vl_tc := vl_tc+1 )
    {
      var integer vl_tcIdx := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].tcIdxList[vl_tc];
      if(v_LGenBase_trafficCases[vl_tcIdx].state == c_EPTF_LGenBase_tcStateRunning){
        v_LGenBase_trafficCases[vl_tcIdx].state := c_EPTF_LGenBase_tcStatePaused;
      }
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_pauseScenario
  //
  //  Purpose:
  //    Hangs up running the scenario
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_pauseScenario(
    in integer pl_eGrpIdx,
    in integer pl_scInGrpIdx)
  runs on EPTF_LGenBase_Private_CT{
    if(terminating == v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].trafficType){
      f_EPTF_LGenBase_loggingWarning(%definitionId&": Abort called for terminating scenario "&
        v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].uniqueName&
        ". The feature is not implemented yet.");
      return;
    }
    for ( var integer vl_tc := 0; vl_tc < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].tcIdxList) ; vl_tc := vl_tc+1 )
    {
      var integer vl_tcIdx := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].tcIdxList[vl_tc];
      if(-1 != v_LGenBase_trafficCases[vl_tcIdx].schedulingTimer and
        originating == v_LGenBase_trafficCases[vl_tcIdx].trafficType){
        f_EPTF_LGenBase_pauseTrafficCaseByIdx(vl_tcIdx);
      }
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_pauseTrafficCase
  //
  //  Purpose:
  //    Stops the periodic timer events of a traffic case and sets its
  //    state to Paused
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_pauseTrafficCase(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName
  )
  runs on EPTF_LGenBase_Private_CT{
    var integer vl_tcIdx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName);
    //Remove next timer event, if exists
    f_EPTF_LGenBase_pauseTrafficCaseByIdx(vl_tcIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_pauseTrafficCaseByIdx
  //
  //  Purpose:
  //    Stops the periodic timer events of a traffic case and sets its
  //    state to Paused
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_pauseTrafficCaseByIdx(
    in integer pl_tcIdx
  )
  runs on EPTF_LGenBase_Private_CT{
    if(terminating == v_LGenBase_trafficCases[pl_tcIdx].trafficType){
      f_EPTF_LGenBase_loggingWarning(%definitionId&": Pause called for terminating tc "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName&
        ". The feature is not implemented yet.");
      return;
    }
    var EPTF_LGenBase_tcState vl_statePrev := v_LGenBase_trafficCases[pl_tcIdx].state;
    if(c_EPTF_LGenBase_tcStateRunning != vl_statePrev){
      f_EPTF_LGenBase_loggingWarning(%definitionId&": Pause called for tc "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName&" in state "&c_EPTF_LGenBase_stateNames[vl_statePrev]);
      return;
    }
    f_EPTF_Base_assert(%definitionId&": Weighted traffic cases can not be paused. Use disable instead.",ischosen(v_LGenBase_trafficCases[pl_tcIdx].schedulerData.target.cpsToReach));
    //Remove next timer event, if exists
    if(not f_EPTF_LGenBase_stopTcTimerInternal(v_LGenBase_trafficCases[pl_tcIdx])) {
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Could not stop traffic case timer for traffic case "& v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
    }
    v_LGenBase_trafficCases[pl_tcIdx].state := c_EPTF_LGenBase_tcStatePaused;
    f_EPTF_LGenBase_tcStateChanged(pl_tcIdx);
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_startEntity
  //
  //  Purpose:
  //    Starts a traffic on the entity of a traffic case
  //
  //  Return Value:
  //    Returns false if the entity is busy
  //
  //  Detailed Comments:
  //    Calls the <f_EPTF_LGenBase_doStartStep> function
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_startEntity(
    in charstring pl_eGrpName,
    in charstring pl_scName,
    in charstring pl_tcName,
    in integer pl_eRelIdx,
    in boolean pl_dispatchStartEvent := true
  )
  runs on EPTF_LGenBase_Private_CT
  return boolean
  {
    var integer vl_tcIdx := f_EPTF_LGenBase_trafficCaseId(pl_eGrpName, pl_scName, pl_tcName);
    return f_EPTF_LGenBase_doStartStep(pl_eRelIdx, vl_tcIdx, pl_dispatchStartEvent)
  }
  
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_createTc2EntityGroup
  //
  //  Purpose:
  //    Creates a specimen of traffic case to the entity group
  //    and initializes it.
  //
  //  Detailed Comments:
  //    The finish actions will be empty after executing the function.
  //    They must be filled from its caller <f_EPTF_LGenBase_createScenario2EntityGroup>
  //    function after all the traffic cases had been created.
  ///////////////////////////////////////////////////////////
  private function f_EPTF_LGenBase_createTc2EntityGroup(
    in EPTF_LGenBase_TcOfScenarioInternalDeclarator pl_tcDecl,
    in integer pl_eGrpIdx,
    in integer pl_scIdxInGrp,
    inout EPTF_LGenBase_ScenarioOfGrp pl_sc)
  runs on EPTF_LGenBase_Private_CT
  return integer{
    var EPTF_LGenBase_TcDescriptor vl_tc := c_EPTF_LGenBase_TcMgmt_emptytcDescriptor;
    var integer vl_newTcIdx := sizeof(v_LGenBase_trafficCases);
    vl_tc.privateName := pl_tcDecl.tcPrivateName;
    vl_tc.tcTypeIdx := f_EPTF_LGenBase_tcTypeNameIndex(pl_tcDecl.tcTypeName);
    if(-1 != vl_tc.tcTypeIdx){
      //Check behavior types
      //TODO Test it
      if(v_LGenBase_entityGroups[pl_eGrpIdx].eTypeIdx != v_LGenBase_trafficCaseTypes[vl_tc.tcTypeIdx].entityTypeIdx and
        not f_EPTF_LGenBase_areETypesCompatible(v_LGenBase_entityGroups[pl_eGrpIdx].eTypeIdx, v_LGenBase_trafficCaseTypes[vl_tc.tcTypeIdx].entityTypeIdx)){
        f_EPTF_LGenBase_loggingError(%definitionId&": Incompatible entity types in tc "&v_LGenBase_trafficCaseTypes[vl_tc.tcTypeIdx].name&
          " and entity group "&v_LGenBase_entityGroups[pl_eGrpIdx].name&"!");
      }
      vl_tc.fsmIdx := v_LGenBase_trafficCaseTypes[vl_tc.tcTypeIdx].fsmIdx;
      //Compared with the TC type FSM in f_EPTF_LGenBase_validateScenarioType
      vl_tc.fsmList[0].fsmTypeIdx := vl_tc.fsmIdx;
      vl_tc.fsmList[0].siblingName := v_LGenBase_fsmTables[v_LGenBase_trafficCaseTypes[vl_tc.tcTypeIdx].fsmIdx].name
      vl_tc.customEntitySuccPrev := v_LGenBase_trafficCaseTypes[vl_tc.tcTypeIdx].customEntitySuccPrev;
      vl_tc.customEntitySucc2 :=  v_LGenBase_trafficCaseTypes[vl_tc.tcTypeIdx].customEntitySucc2;
    }
    //customEntitySuccPrev can be declared only in tc type, but 
    //customEntitySucc2 can be declared even as a tcParam
    if("" != pl_tcDecl.customEntitySucc){
      var EPTF_LGenBase_evaluateSuccess4EntityAtEntityGroup2_FT vl_prev := vl_tc.customEntitySucc2;
      f_EPTF_LGenBase_getCustomEntitySuccFn(pl_tcDecl.customEntitySucc, vl_tc.customEntitySucc2);
      if(null != vl_prev and vl_tc.customEntitySucc2 != vl_prev){
        f_EPTF_LGenBase_loggingError(%definitionId&
        ": The entity success calculation function of traffic case "&vl_tc.uniqueName&
        " is defined in both the traffic case description and its type declaration, and they are different.")
      }
    }
    for ( var integer vl_fsm := 0; vl_fsm < sizeof(pl_tcDecl.fsmList) ; vl_fsm := vl_fsm+1 ) {
      vl_tc.fsmList[vl_fsm].fsmTypeIdx := pl_tcDecl.fsmList[vl_fsm].fsmTypeIndex
      vl_tc.fsmList[vl_fsm].siblingName := pl_tcDecl.fsmList[vl_fsm].siblingName
    }
    vl_tc.eGroupBackref := pl_eGrpIdx; //back-reference to the entity group that owns this descriptor
    vl_tc.eScenarioBackRef := pl_scIdxInGrp; //The index of the scenario of the tc in the entity group
    vl_tc.eTcRelIdx := sizeof(pl_sc.tcIdxList);
    vl_tc.schedulerData.target := pl_tcDecl.target; //EGBOZIE:cps or weight
    vl_tc.templateSetIdx := f_EPTF_LGenBase_initTemplateSet(pl_tcDecl.templateSet);
    vl_tc.trafficType := pl_sc.trafficType
    if (originating == vl_tc.trafficType and ischosen(vl_tc.schedulerData.target.cpsToReach)) {
      f_EPTF_LGenBase_adjustSchedulerData4NewCps(vl_tc.schedulerData);
      // distribute the bursterror differently according to the traffic corrigation => smooth out cumulative bursts
      vl_tc.schedulerData.burstSizeCumulativeError := v_LGenBase_entityGroups[pl_eGrpIdx].trafficCorrigation;
    }
    vl_tc.entityInfo := c_EPTF_LGenBase_emptyEntityInfo;
    if(ispresent(pl_tcDecl.entitySelection)) {
      vl_tc.entityInfo.entitySelection := pl_tcDecl.entitySelection;
    } else {
      vl_tc.entityInfo.entitySelection := round_robin;
    }
    vl_tc.startDelay := pl_tcDecl.startDelay;
    
    vl_tc.schedulingTimer := -1;	//event queue Idx of the traffic-start peridodic event
    vl_tc.enableEntitiesAtStartup := pl_tcDecl.enableEntities or terminating == vl_tc.trafficType;
    vl_tc.enabledAtStartup := pl_tcDecl.enable;
    vl_tc.v_sizeofRanges :=  sizeof(pl_tcDecl.ranges);
    //f_EPTF_LGenBase_initTCInternal(vl_tc, vl_newTcIdx, pl_tcDecl.enableEntities, true);
    vl_tc.enabled := pl_tcDecl.enable;
    
    vl_tc.uniqueName := f_EPTF_LGenBaseStats_getTCName(v_LGenBase_entityGroups[pl_eGrpIdx].name,pl_sc.name, vl_tc.privateName);
    vl_tc.paramHashMap := f_EPTF_str2int_HashMap_New(vl_tc.uniqueName&c_EPTF_LGenBase_tcParamsHasmapPostfix);
    //Book in traffic case specimen list
    if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugConfig)){
      f_EPTF_LGenBase_loggingDebugConfig(log2str(%definitionId&": ",vl_tc))
    }
    v_LGenBase_trafficCases[vl_newTcIdx] := vl_tc;
    //Initialize
    f_EPTF_LGenBase_initTCInternal(v_LGenBase_trafficCases[vl_newTcIdx], vl_newTcIdx, vl_tc.enableEntitiesAtStartup, true);
    //Book in entity group's scenario
    pl_sc.tcIdxList[vl_tc.eTcRelIdx] := vl_newTcIdx;
    
    // setting burst calc method for every traffic cases
    var charstring vl_burstName := "";
    if(ispresent(pl_tcDecl.scheduler)) 	// setting scheduler by traffic case config parameter
    {
      vl_burstName := pl_tcDecl.scheduler;
    } else { 				// setting scheduler by global parameter
      if("" != v_LGenBase_burstCalcMode) {
        vl_burstName := v_LGenBase_burstCalcMode;
      } else {
        f_EPTF_Base_assert(%definitionId&"No Global or Local burst calculation method is set.",false);
      }
    }
    var integer vl_burstId;
    vl_burstId := f_EPTF_LGenBase_getBurstCalcFunctionId(vl_burstName);
    if(vl_burstId != -1) {
      f_EPTF_LGenBase_setBurstCalcAlgInternal(vl_burstId, vl_newTcIdx, false);
    } else {
      //TODO Test it
      f_EPTF_LGenBase_loggingError(%definitionId&"No calculation method is set with this name.");
    }
    
    if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": "&log2str(vl_tc))
    }
    return vl_newTcIdx;
  }
} //StartStop

///////////////////////////////////////////////////////////
//  Group: EnableDisable
//
//  Purpose:
//    Functions to enable and disable entities, traffic cases and scenarios
///////////////////////////////////////////////////////////
group EnableDisable{
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_enableScenarioOnEntityGroup
  //
  //  Purpose:
  //    Enables a scenario on an Entity Group and optonally starts
  //
  //  Detailed Comments:
  //    This function creates the
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_enableScenarioOnEntityGroup(
    in integer pl_eGrpIdx, //entity group
    in integer pl_scIdxInGrp, //scenario index in group
    in boolean pl_autoStart := true)
  runs on EPTF_LGenBase_Private_CT{
    var EPTF_LGenBase_tcState vl_scStatePrev := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdxInGrp].state;
    if(c_EPTF_LGenBase_tcStatePaused != vl_scStatePrev and
      c_EPTF_LGenBase_tcStateStopped != vl_scStatePrev and
      c_EPTF_LGenBase_tcStateAborted != vl_scStatePrev and
      c_EPTF_LGenBase_tcStateIdle != vl_scStatePrev and
      c_EPTF_LGenBase_tcStateTerminated != vl_scStatePrev){
      f_EPTF_LGenBase_loggingWarning(%definitionId&": Start launch called for scenario "&
        v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdxInGrp].uniqueName&
        " in state "&c_EPTF_LGenBase_stateNames[vl_scStatePrev]);
      return;
    }
    if(pl_autoStart){
      var integer vl_scAbsIdx := f_EPTF_LGenBase_scenarioAbsIdx(pl_eGrpIdx, pl_scIdxInGrp)
      f_EPTF_LGenBase_dispatchEvent({
          event := {
            bIdx := c_EPTF_LGenBase_bIdx,
            iIdx := c_EPTF_LGenBase_inputIdx_testMgmt_scenarioStarted,
            target := omit,
            source := omit
          },
          reportedArgs := {pl_eGrpIdx, pl_scIdxInGrp, vl_scAbsIdx}
        });
    }
    var integer vl_tcCount := sizeof(
      v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdxInGrp].tcIdxList);
    for(var integer vl_i := 0;  vl_i < vl_tcCount; vl_i := vl_i + 1){
      if ( v_LGenBase_trafficCases[
          v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdxInGrp].tcIdxList[vl_i]].enabled or
        terminating == v_LGenBase_trafficCases[
          v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdxInGrp].tcIdxList[vl_i]].trafficType)
      {
        f_EPTF_LGenBase_enableTrafficCaseInternal(
          v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdxInGrp].tcIdxList[vl_i], pl_autoStart);
      }
      else
      {
        f_EPTF_LGenBase_disableTrafficCaseInternal(
          v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdxInGrp].tcIdxList[vl_i]);
      }
      
    }
    if (pl_autoStart and ispresent(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdxInGrp].weightedScData))
    {//EGBOZIE: new for weighted sc.
      f_EPTF_LGenBase_startLaunchWeightedScenario(pl_eGrpIdx,pl_scIdxInGrp,false)
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_enableEntityInTrafficCase
  //
  //  Purpose:
  //    Enables an entity in the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_enableEntityInTrafficCase(
    in integer pl_tcIdx,
    in integer pl_eRelIdx
  )
  runs on EPTF_LGenBase_Private_CT{
    if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Enable entity #"&int2str(pl_eRelIdx)&" in traffic case "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
    }
    //HN33148 Unnecessary warning removed
    //HN15601
    v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_eRelIdx].disabled := false;
    if(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_eRelIdx].finished){
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Enable finished entity #"&int2str(pl_eRelIdx)&" in traffic case "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
      }
      return;
    }
    if(not v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_eRelIdx].isRunning){
      if(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.entitySelection == round_robin) {
        if(f_EPTF_FBQ_itemIsBusy(pl_eRelIdx, v_LGenBase_trafficCases[pl_tcIdx].entityInfo.fbq)){
          //Not running, not finished, busy -> disabled
          f_EPTF_FBQ_moveFromBusyToFreeTail(pl_eRelIdx, v_LGenBase_trafficCases[pl_tcIdx].entityInfo.fbq);
          Inc(v_LGenBase_trafficCases[pl_tcIdx].nrOfAvailableEntities);
        }
      } else {
        if(f_EPTF_RNA_itemIsBusy(pl_eRelIdx, v_LGenBase_trafficCases[pl_tcIdx].entityInfo.rna)){
          //Not running, not finished, busy -> disabled
          if(not f_EPTF_RNA_moveFromBusyToFreeSlot(pl_eRelIdx, v_LGenBase_trafficCases[pl_tcIdx].entityInfo.rna)){
            f_EPTF_Base_assert(%definitionId&": Error in f_EPTF_RNA_moveFromBusyToFreeSlot",false)
          }
          Inc(v_LGenBase_trafficCases[pl_tcIdx].nrOfAvailableEntities);
        }
      }
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_disableEntityInTrafficCase
  //
  //  Purpose:
  //    Disables an entity in the traffic case
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_disableEntityInTrafficCase(
    in integer pl_tcIdx,
    in integer pl_eRelIdx
  )
  runs on EPTF_LGenBase_Private_CT{
    f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Disable entity #"&int2str(pl_eRelIdx)&" in traffic case "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
    //HN15601
    v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_eRelIdx].disabled := true;
    if(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_eRelIdx].finished){
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Disable finished entity #"&int2str(pl_eRelIdx)&" in traffic case "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
      }
      return;
    }
    if(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.entitySelection == round_robin) {
      if(f_EPTF_FBQ_itemIsFree(pl_eRelIdx, v_LGenBase_trafficCases[pl_tcIdx].entityInfo.fbq)){
        f_EPTF_FBQ_moveFromFreeToBusyTail(pl_eRelIdx, v_LGenBase_trafficCases[pl_tcIdx].entityInfo.fbq);
        Dec(v_LGenBase_trafficCases[pl_tcIdx].nrOfAvailableEntities);
        SetIfLt(v_LGenBase_trafficCases[pl_tcIdx].minAvailable, v_LGenBase_trafficCases[pl_tcIdx].nrOfAvailableEntities);
        SetIfGt(v_LGenBase_trafficCases[pl_tcIdx].maxBusy,f_EPTF_FBQ_getLengthOfBusyChain(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.fbq));
      }
    } else {
      if(f_EPTF_RNA_itemIsFree(pl_eRelIdx, v_LGenBase_trafficCases[pl_tcIdx].entityInfo.rna)){
        if(not f_EPTF_RNA_moveFromFreeToBusySlot(pl_eRelIdx, v_LGenBase_trafficCases[pl_tcIdx].entityInfo.rna)){
          f_EPTF_Base_assert(%definitionId&": Error in f_EPTF_RNA_moveFromFreeToBusySlot",false)
        }
        Dec(v_LGenBase_trafficCases[pl_tcIdx].nrOfAvailableEntities);
        SetIfLt(v_LGenBase_trafficCases[pl_tcIdx].minAvailable, v_LGenBase_trafficCases[pl_tcIdx].nrOfAvailableEntities);
        SetIfGt(v_LGenBase_trafficCases[pl_tcIdx].maxBusy,f_EPTF_RNA_getLengthOfBusyList(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.rna));
      }
    }
  }
}//EnableDisable

///////////////////////////////////////////////////////////
//  Group: EvaluateSuccess4EntityAtEntityGroupFunctions
//
//  Purpose:
//    Predefined methods to return the new state of the entity after a traffic
///////////////////////////////////////////////////////////
group EvaluateSuccess4EntityAtEntityGroupFunctions{
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_successSucNoFail
  //
  //  Purpose:
  //    This preregistered function returns pass if the entity had
  //    never reported failed finish of any traffic.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_successSucNoFail(
    in integer pl_tcIdx,
    in integer pl_eIdxInTc,
    in boolean pl_lastSuccess
  )
  runs on EPTF_LGenBase_Private_CT
  return EPTF_LGenBase_EntityState{
    var EPTF_LGenBase_EntityItem vl_dataidx := v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_eIdxInTc];
    if(0 == vl_dataidx.nrOfSuccesses and 0 == vl_dataidx.nrOfFails and
      0 == vl_dataidx.nrOfErrors and 0 == vl_dataidx.nrOfTimeouts){
      return none;
    }else{
      if(0 == vl_dataidx.nrOfFails and 0 == vl_dataidx.nrOfErrors and 0 == vl_dataidx.nrOfTimeouts){
        return pass;
      }
      return fail;
    }
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_successIfOnceSuccess
  //
  //  Purpose:
  //    This preregistered function returns pass if the entity had
  //    reported successful finish of a traffic at least once.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_successIfOnceSuccess(
    in integer pl_tcIdx,
    in integer pl_eIdxInTc,
    in boolean pl_lastSuccess
  )
  runs on EPTF_LGenBase_Private_CT
  return EPTF_LGenBase_EntityState{
    if(0 < v_LGenBase_trafficCases[pl_tcIdx].entityInfo.itemList[pl_eIdxInTc].nrOfSuccesses){
      return pass;
    }
    return fail;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_successIfLastSuccess
  //
  //  Purpose:
  //    This preregistered function returns pass if the last traffic on the
  //    entity successfully finished.
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_successIfLastSuccess(
    in integer pl_tcIdx,
    in integer pl_eIdxInTc,
    in boolean pl_lastSuccess
  )
  runs on EPTF_LGenBase_Private_CT
  return EPTF_LGenBase_EntityState{
    if(pl_lastSuccess){
      return pass;
    }
    return fail;
  }
}

///////////////////////////////////////////////////////////
//  Group: ObsoleteFunctions
//
//  Purpose:
//    The obsolete functions of the EPTF_LGenBase TrafficFunctions feature
//    Please try not to use them.
//
///////////////////////////////////////////////////////////
group ObsoleteFunctions{
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setBurstCalcMode
  //
  //  Purpose:
  //    Sets the method of bust calculation
  //
  //  Parameters:
  //  pl_EPTF_LGenBase_burstFunc - *in* <EPTF_LGenBase_burstFunc> - The type of method of bust calculation
  //
  //  Return Value:
  //    If there is a running traffic case, returns false.
  //
  //  Errors & assertions:
  //    - The method must not be "userDefined".
  //
  //  Detailed Comments:
  //    If there is a running traffic case, the burst calculation method can not be
  //    set, then the function returns false, and does nothing.
  //    The method must be one of the valid predefined values.
  //    Note: This function is obsoleted. Use <f_EPTF_LGenBase_setBurstCalcAlgByName>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setBurstCalcMode(
    in EPTF_LGenBase_burstFunc pl_EPTF_LGenBase_burstFunc)
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    f_EPTF_LGenBase_loggingWarning(%definitionId&": This is an obsolete function. Use f_EPTF_LGenBase_setBurstCalcAlgByName.");
    
    for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_trafficCases) ; vl_i := vl_i+1 )
    {
      if(-1 != v_LGenBase_trafficCases[vl_i].schedulingTimer){
        f_EPTF_LGenBase_loggingError(%definitionId&"The "&v_LGenBase_trafficCases[vl_i].uniqueName&" traffic case is a running. The burst calculation method can not be set.");
        return false
      }
    }
    v_LGenBase_burstCalcMode := f_EPTF_LGenBase_BurstFuncName2Char(pl_EPTF_LGenBase_burstFunc);
    
    return true;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBase_setBurstCalcFunctions
  //
  //  Purpose:
  //    Sets the bust calculation functions
  //
  //  Return Value:
  //    If there is a running traffic case, returns false.
  //
  //  Errors & assertions:
  //    - The method must not be "userDefined"
  //
  //  Detailed Comments:
  //    If the predefined calculation methodes don't fit requirements, users can write their own methods.
  //    If there is a running traffic case, the burst calculation method can not be
  //    set, then the function returns false, and does nothing.
  //    Function sets the burst calculation method to "userDefined".
  //    Note: This function is obsoleted. Use <f_EPTF_LGenBase_setBurstCalcAlgByName>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setBurstCalcFunctions(
    in EPTF_LGenBase_burstPreCalc_FT pl_preFunc,
    in EPTF_LGenBase_burstPostCalc_FT pl_postFunc)
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    f_EPTF_LGenBase_loggingWarning(%definitionId&": This is an obsolete function. Use f_EPTF_LGenBase_setBurstCalcAlgByName.");
    
    for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_trafficCases) ; vl_i := vl_i+1 )
    {
      if(-1 != v_LGenBase_trafficCases[vl_i].schedulingTimer){
        f_EPTF_LGenBase_loggingError(%definitionId&"The "&v_LGenBase_trafficCases[vl_i].uniqueName&" traffic case is a running. The burst calculation method can not be set.");
        return false
      }
    }
    v_LGenBase_dummyInt := f_EPTF_LGenBase_addBurstCalcFunction("userDefined",pl_preFunc,pl_postFunc);
    v_LGenBase_burstCalcMode := "userDefined";
    return true;
  }
  
  
} //group ObsoleteFunctions

///////////////////////////////////////////////////////////
//  Group: PrivateFunctions
//
//  Purpose:
//    The private functions of the EPTF_LGenBase feature
//    Don't use them from outside of EPTF_LGenBase
//
///////////////////////////////////////////////////////////
group PrivateFunctions{
  group conditionsAndActions{
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_checkGroupFinishConditionFired
    //
    //  Purpose:
    //    Filters the finish conditions already fired
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_checkGroupFinishConditionFired(
      in EPTF_LGenBase_ConditionTrue pl_fired,
      in EPTF_LGenBase_ConditionTrue pl_source,
      out EPTF_LGenBase_ConditionTrue pl_dest)
    runs on EPTF_LGenBase_Private_CT{
      pl_dest := c_EPTF_LGenBase_emptyConditionTrue
      pl_dest.nrOfExecStart := pl_source.nrOfExecStart and not pl_fired.nrOfExecStart
      pl_dest.nrOfSuccesses := pl_source.nrOfSuccesses and not pl_fired.nrOfSuccesses
      pl_dest.nrOfFails := pl_source.nrOfFails and not pl_fired.nrOfFails
      pl_dest.nrOfErrors := pl_source.nrOfErrors and not pl_fired.nrOfErrors
      pl_dest.nrOfTimeouts := pl_source.nrOfTimeouts and not pl_fired.nrOfTimeouts
      pl_dest.nrOfRangeLoop := pl_source.nrOfRangeLoop and not pl_fired.nrOfRangeLoop
      pl_dest.execTime := pl_source.execTime and not pl_fired.execTime
      pl_dest.entitiesFinished := pl_source.entitiesFinished and not pl_fired.entitiesFinished
      pl_dest.availableEntitiesFinished := pl_source.availableEntitiesFinished and not pl_fired.availableEntitiesFinished
      pl_dest.customFinishCondition := pl_source.customFinishCondition and not pl_fired.customFinishCondition
      pl_dest.anythingFinished := pl_source.anythingFinished and not pl_fired.anythingFinished
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": New finish conditions: "&log2str(pl_dest));
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_setGroupFinishConditionFired
    //
    //  Purpose:
    //    Registers the finish conditions fired
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_setGroupFinishConditionFired(
      in EPTF_LGenBase_ConditionTrue pl_source,
      inout EPTF_LGenBase_ConditionTrue pl_dest)
    runs on EPTF_LGenBase_Private_CT{
      pl_dest.nrOfExecStart := pl_dest.nrOfExecStart or pl_source.nrOfExecStart
      pl_dest.nrOfSuccesses := pl_dest.nrOfSuccesses or pl_source.nrOfSuccesses
      pl_dest.nrOfFails := pl_dest.nrOfFails or pl_source.nrOfFails
      pl_dest.nrOfErrors := pl_dest.nrOfErrors or pl_source.nrOfErrors
      pl_dest.nrOfTimeouts := pl_dest.nrOfTimeouts or pl_source.nrOfTimeouts
      pl_dest.nrOfRangeLoop := pl_dest.nrOfRangeLoop or pl_source.nrOfRangeLoop
      pl_dest.execTime := pl_dest.execTime or pl_source.execTime
      pl_dest.entitiesFinished := pl_dest.entitiesFinished or pl_source.entitiesFinished
      pl_dest.availableEntitiesFinished := pl_source.availableEntitiesFinished or pl_source.availableEntitiesFinished
      pl_dest.customFinishCondition := pl_dest.customFinishCondition or pl_source.customFinishCondition
      pl_dest.anythingFinished := pl_dest.anythingFinished or pl_source.anythingFinished
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_execFinishActions
    //
    //  Purpose:
    //    Executes the group finish actions of a traffic case
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_execFinishActions(
      in integer pl_tcIdx,
      in EPTF_LGenBase_ConditionTrue pl_conditions := c_EPTF_LGenBase_emptyConditionTrue)
    runs on EPTF_LGenBase_Private_CT{
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Finish conditions to be executed: "&log2str(pl_conditions));
      }
      f_EPTF_LGenBase_setGroupFinishConditionFired(
        pl_conditions,
        v_LGenBase_trafficCases[pl_tcIdx].groupFinishConditionProcessed);
      if( pl_conditions.customFinishCondition and
        ispresent(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.customFinishConditionFuncRef) and
        0 != sizeof(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.customFinishConditionFuncRef.actions)){
        f_EPTF_LGenBase_execGroupActions(
          v_LGenBase_trafficCases[pl_tcIdx],
          v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.customFinishConditionFuncRef.actions,
          pl_tcIdx)
      }
      if( pl_conditions.entitiesFinished and
        ispresent(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.entitiesFinished) and
        0 != sizeof(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.entitiesFinished.actions)){
        f_EPTF_LGenBase_execGroupActions(
          v_LGenBase_trafficCases[pl_tcIdx],
          v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.entitiesFinished.actions,
          pl_tcIdx)
      }
      if( pl_conditions.availableEntitiesFinished and
        ispresent(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.availableEntitiesFinished) and
        0 != sizeof(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.availableEntitiesFinished.actions)){
        f_EPTF_LGenBase_execGroupActions(
          v_LGenBase_trafficCases[pl_tcIdx],
          v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.availableEntitiesFinished.actions,
          pl_tcIdx)
      }
      if( pl_conditions.execTime and
        ispresent(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.execTime) and
        0 != sizeof(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.execTime.actions)){
        f_EPTF_LGenBase_execGroupActions(
          v_LGenBase_trafficCases[pl_tcIdx],
          v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.execTime.actions,
          pl_tcIdx)
      }
      if( pl_conditions.nrOfExecStart and
        ispresent(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfExecStart) and
        0 != sizeof(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfExecStart.actions)){
        f_EPTF_LGenBase_execGroupActions(
          v_LGenBase_trafficCases[pl_tcIdx],
          v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfExecStart.actions,
          pl_tcIdx)
      }
      if( pl_conditions.nrOfFails and
        ispresent(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfFails) and
        0 != sizeof(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfFails.actions)){
        f_EPTF_LGenBase_execGroupActions(
          v_LGenBase_trafficCases[pl_tcIdx],
          v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfFails.actions,
          pl_tcIdx)
      }
      if( pl_conditions.nrOfErrors and
        ispresent(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfErrors) and
        0 != sizeof(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfErrors.actions)){
        f_EPTF_LGenBase_execGroupActions(
          v_LGenBase_trafficCases[pl_tcIdx],
          v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfErrors.actions,
          pl_tcIdx)
      }
      if( pl_conditions.nrOfTimeouts and
        ispresent(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfTimeouts) and
        0 != sizeof(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfTimeouts.actions)){
        f_EPTF_LGenBase_execGroupActions(
          v_LGenBase_trafficCases[pl_tcIdx],
          v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfTimeouts.actions,
          pl_tcIdx)
      }
      if( pl_conditions.nrOfRangeLoop and
        ispresent(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfRangeLoop) and
        0 != sizeof(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfRangeLoop.actions)){
        f_EPTF_LGenBase_execGroupActions(
          v_LGenBase_trafficCases[pl_tcIdx],
          v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfRangeLoop.actions,
          pl_tcIdx)
      }
      if( pl_conditions.nrOfSuccesses and
        ispresent(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfSuccesses) and
        0 != sizeof(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfSuccesses.actions)){
        f_EPTF_LGenBase_execGroupActions(
          v_LGenBase_trafficCases[pl_tcIdx],
          v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.nrOfSuccesses.actions,
          pl_tcIdx)
      }
      if( pl_conditions.anythingFinished and
        ispresent(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.anythingFinished) and
        0 != sizeof(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.anythingFinished.actions)){
        f_EPTF_LGenBase_execGroupActions(
          v_LGenBase_trafficCases[pl_tcIdx],
          v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.anythingFinished.actions,
          pl_tcIdx)
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_startExecTimeTimer
    // 
    //  Purpose:
    //    Starts an "execution time expired" event if needed
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_startExecTimeTimer(in integer pl_tcIdx)   
    runs on EPTF_LGenBase_Private_CT
    { 
      // there is no need for execTime timer setting, quit
      if ( not ispresent(v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.execTime) or
        not v_LGenBase_groupFinishConditionMask.execTime )  {  return; }     
      
      if(not f_EPTF_SchedulerComp_scheduleAction(
          v_LGenBase_trafficCases[pl_tcIdx].startTime + v_LGenBase_trafficCases[pl_tcIdx].trafficStartFinishConditionsAndActions.execTime.time,
          refers(f_EPTF_LGenBase_handleExecTimeExpired),
          {pl_tcIdx}, // EPTF_ScheduledAction
          v_LGenBase_trafficCases[pl_tcIdx].execTimeTimer)) 
      {
        f_EPTF_LGenBase_loggingError(%definitionId&": Can not schedule timer event.");
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_handleExecTimeExpired
    // 
    //  Purpose:
    //    When the "execution time expired" event arrives this function handles it.
    ///////////////////////////////////////////////////////////  
    private function f_EPTF_LGenBase_handleExecTimeExpired(
      in EPTF_ScheduledAction pl_action,
      in integer pl_eventIndex) 
    runs on EPTF_LGenBase_Private_CT
    return boolean
    {
      var integer pl_tcIdx := pl_action.actionId[0];
      var EPTF_LGenBase_ConditionTrue pl_execTimeFired := c_EPTF_LGenBase_emptyConditionTrue;
      pl_execTimeFired.execTime := true;
      pl_execTimeFired.anythingFinished := true;
      
      f_EPTF_LGenBase_groupFinishedDetected(pl_tcIdx, pl_execTimeFired);
      return true; // needed because this function is an actionHandler, must return boolean
    }
  }
  ///////////////////////////////////////////////////////////
  //  Group: PrivatePredefinedBurstCal
  //
  //  Purpose:
  //    The predefined burst calculation functions
  //
  ///////////////////////////////////////////////////////////
  group PrivatePredefinedBurstCal{
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_BurstCalc_init
    //
    //  Purpose:
    //    Stores predefined burst calculation functions in the list of LGenBase
    //
    //  Parameters:
    //    -
    //
    //  Return Value:
    //    *boolean*
    ///////////////////////////////////////////////////////////
    friend function f_EPTF_LGenBase_BurstCalc_init()
    runs on EPTF_LGenBase_Private_CT
    {
      var integer vl_temp
      //FIXME The terminating needs own pre/post functions
      vl_temp := f_EPTF_LGenBase_addBurstCalcFunction(c_EPTF_LGenBase_BurstCalc_terminating,refers(f_EPTF_LGenBase_burstPreCalcCS),refers(f_EPTF_LGenBase_burstPostCalcOrig));
      f_EPTF_Base_assert(%definitionId&" Error registering the burst calculation function "&c_EPTF_LGenBase_BurstCalc_terminating , vl_temp == c_EPTF_LGenBase_BurstCalcFnIdx_terminating )
      vl_temp := f_EPTF_LGenBase_addBurstCalcFunction(c_EPTF_LGenBase_BurstCalc_orig,refers(f_EPTF_LGenBase_burstPreCalcCS),refers(f_EPTF_LGenBase_burstPostCalcOrig));
      f_EPTF_Base_assert(%definitionId&" Error registering the burst calculation function "&c_EPTF_LGenBase_BurstCalc_orig , vl_temp == c_EPTF_LGenBase_BurstCalcFnIdx_orig )
      vl_temp := f_EPTF_LGenBase_addBurstCalcFunction(c_EPTF_LGenBase_BurstCalc_imst,refers(f_EPTF_LGenBase_burstPreCalcCS),refers(f_EPTF_LGenBase_burstPostCalcOrig));
      f_EPTF_Base_assert(%definitionId&" Error registering the burst calculation function "&c_EPTF_LGenBase_BurstCalc_imst , vl_temp == c_EPTF_LGenBase_BurstCalcFnIdx_imst )
      vl_temp := f_EPTF_LGenBase_addBurstCalcFunction(c_EPTF_LGenBase_BurstCalc_imst2,refers(f_EPTF_LGenBase_burstPreCalcCS),refers(f_EPTF_LGenBase_burstPostCalcOrig));
      f_EPTF_Base_assert(%definitionId&" Error registering the burst calculation function "&c_EPTF_LGenBase_BurstCalc_imst2 , vl_temp == c_EPTF_LGenBase_BurstCalcFnIdx_imst2 )
      vl_temp := f_EPTF_LGenBase_addBurstCalcFunction(c_EPTF_LGenBase_BurstCalc_cs,refers(f_EPTF_LGenBase_burstPreCalcCS),refers(f_EPTF_LGenBase_burstPostCalcOrig));
      f_EPTF_Base_assert(%definitionId&" Error registering the burst calculation function "&c_EPTF_LGenBase_BurstCalc_cs , vl_temp == c_EPTF_LGenBase_BurstCalcFnIdx_cs )
      vl_temp := f_EPTF_LGenBase_addBurstCalcFunction(c_EPTF_LGenBase_BurstCalc_poisson,refers(f_EPTF_LGenBase_burstPreCalcPoisson),refers(f_EPTF_LGenBase_burstPostCalcPoisson));
      f_EPTF_Base_assert(%definitionId&" Error registering the burst calculation function "&c_EPTF_LGenBase_BurstCalc_poisson , vl_temp == c_EPTF_LGenBase_BurstCalcFnIdx_poisson )
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_setBurstCalcAlgInternal
    //
    //  Purpose:
    //    Internal function for setting Burst Function Reference for a traffic case
    //
    //  Parameters:
    //  pl_burstIdx - *in* *integer* - The index of the burst function
    //  pl_idx - *in* - *integer* - traffic case index or a weighted scenario index
    //  pl_isWeighted - *in* - *boolean* - if the algorithm is assigned to a weighted scenario or a normal traffic case
    //
    //  Return Value:
    //    *boolean*
    //
    //  Detailed Comments:
    //    The function sets the burst calculation algorithm to a normal traffic case or a weighted scenario.
    //    If pl_isWeighted is true the algorithm is assigned to a weighted scenario. Default value is false.
    //    This internal function does not checks if the indexes are valid or the traffic case is running ->
    //    it is because when we initializing a scenario, the scenario indices are not set and we cannot check their validity.
    ///////////////////////////////////////////////////////////
    friend function f_EPTF_LGenBase_setBurstCalcAlgInternal(
      in integer pl_burstIdx,
      in integer pl_tcIdx, //FIXME Sometimes tc idx, sometimes sc idx?!
      in boolean pl_isWeighted := false) //FIXME this should be retrieved from the TC
    runs on EPTF_LGenBase_Private_CT{
      
      var integer vl_eGrpIdx;
      var integer vl_scInGrpIdx;
      
      if(pl_isWeighted) { // weighted scenario
        
        f_EPTF_LGenBase_scenarioRelIdx(pl_tcIdx, vl_eGrpIdx, vl_scInGrpIdx);
        v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].schedulerData.burstFuncRef.burstCalcMode := v_LGenBase_burstFuncRefList[pl_burstIdx].burstCalcMode;
        v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].schedulerData.burstFuncRef.burstPreCalc := v_LGenBase_burstFuncRefList[pl_burstIdx].burstPreCalc;
        v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].schedulerData.burstFuncRef.burstPostCalc := v_LGenBase_burstFuncRefList[pl_burstIdx].burstPostCalc;
        
      } else { // normal traffic case
        if(pl_tcIdx == -1){
          v_LGenBase_burstCalcMode := v_LGenBase_burstFuncRefList[pl_burstIdx].burstCalcMode; // setting component variable
        } else {
          v_LGenBase_trafficCases[pl_tcIdx].schedulerData.burstFuncRef.burstCalcMode := v_LGenBase_burstFuncRefList[pl_burstIdx].burstCalcMode;
          v_LGenBase_trafficCases[pl_tcIdx].schedulerData.burstFuncRef.burstPreCalc := v_LGenBase_burstFuncRefList[pl_burstIdx].burstPreCalc;
          v_LGenBase_trafficCases[pl_tcIdx].schedulerData.burstFuncRef.burstPostCalc := v_LGenBase_burstFuncRefList[pl_burstIdx].burstPostCalc;
        }
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_burstPreCalcOrig
    //
    //  Purpose:
    //    The burst precalculation function for EPTF traffic
    //
    //  Parameters:
    //    pl_schData - *inout* - <EPTF_LGenBase_SchedulerData> - Scheduler data (eg. lastBurstSize)
    //    pl_when - *in* - *float* - time of scheduled event
    //    pl_maxSend - *out* - *integer* - maximum number of send
    //    pl_nextCallTime - *out* - *float* - the next call time
    //
    //  Return Value:
    //    -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //    Obsolete function, calls the CS
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_burstPreCalcOrig(
      inout EPTF_LGenBase_SchedulerData pl_schData,
      in float pl_when,
      out integer pl_maxSend,
      out float pl_nextCallTime) runs on EPTF_LGenBase_Private_CT
    {
      f_EPTF_LGenBase_burstPreCalcCS(pl_schData,pl_when,pl_maxSend,pl_nextCallTime)
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_burstPreCalcCS
    //
    //  Purpose:
    //    The burst precalculation function for EPTF traffic
    //
    //  Parameters:
    //    pl_schData - *inout* - <EPTF_LGenBase_SchedulerData> - Scheduler data (eg. lastBurstSize)
    //    pl_when - *in* - *float* - time of scheduled event
    //    pl_maxSend - *out* - *integer* - maximum number of send
    //    pl_nextCallTime - *out* - *float* - the next call time
    //
    //  Return Value:
    //    -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_burstPreCalcCS(
      inout EPTF_LGenBase_SchedulerData pl_schData,
      in float pl_when,
      out integer pl_maxSend,
      out float pl_nextCallTime) runs on EPTF_LGenBase_Private_CT
    {
      var float  vl_currentBurstSizeAsFloat := int2float(pl_schData.currentBurstSize);
      var integer vl_currentBurstSizeAsInt :=  float2int(vl_currentBurstSizeAsFloat)
      var float vl_idealBurstSize := pl_schData.idealBurstSize
      var integer vl_cumulativeBurstSize := 0;
      //pl_schData.idealBurstSize     := pl_schData.cpsToReach  * pl_schData.roundedCpsUpdateInterval;
      pl_nextCallTime   := pl_when + pl_schData.roundedCpsUpdateInterval;
      // Step#1:
      // if we are late (i.e., timer lag grows beyond CpsUpdateInterval)
      // or if last burst was less than ideal
      if(pl_nextCallTime < f_EPTF_SchedulerComp_snapshotTime() or
        vl_currentBurstSizeAsInt < float2int(vl_idealBurstSize)
      ){
        // increase currentBurstSize towards the idealBurstSize:
        // Overload factor: (f_EPTF_SchedulerComp_snapshotTime() - pl_when)/CpsUpdateInterval
        // 0.0 ... 1.0 shall mean "full size burst", since burst is not delayed beyond the CpsUpdateInterval
        // >1.0 means "reduced burst", since burst is delayed beyond the CpsUpdateInterval
        // >2.0 means "no burst"
        var float vl_TLag := f_EPTF_SchedulerComp_snapshotTime() - pl_when;
        //if there have been not burst last time, then try to recover
        //with a gradient of 2.0
        if (vl_currentBurstSizeAsFloat == 0.0) {vl_currentBurstSizeAsFloat := 1.0}
        //currentBurstSize := currentBurstSize * (2 - vl_TLag / pl_schData.roundedCpsUpdateInterval);
        if(0.0 != pl_schData.roundedCpsUpdateInterval){
          vl_currentBurstSizeAsFloat := vl_currentBurstSizeAsFloat * (2.0 - vl_TLag / pl_schData.roundedCpsUpdateInterval)+0.5;

          if (vl_currentBurstSizeAsFloat > pl_schData.idealBurstSize) {
            vl_currentBurstSizeAsFloat := pl_schData.idealBurstSize;
          }
          if (vl_currentBurstSizeAsFloat < 1.0) {
            vl_currentBurstSizeAsFloat := 1.0;
          }

        }else{
          f_EPTF_LGenBase_loggingWarning(%definitionId&": The function has been called when the CPS is 0.0!")
          //Don't generate traffic
          vl_currentBurstSizeAsFloat := 0.0
        }
        vl_currentBurstSizeAsInt := float2int(vl_currentBurstSizeAsFloat+0.5)
        pl_schData.currentBurstSize := vl_currentBurstSizeAsInt;

        //if nextCalltime is "in the past", then reset it to full interval into the future
        if(pl_nextCallTime < f_EPTF_SchedulerComp_snapshotTime() ) {
          pl_nextCallTime := f_EPTF_SchedulerComp_snapshotTime() +tsp_EPTF_ELEMENTARY_TIMESTEP_PARAM;
          // corrigate calls to generate, because extra time added to pl_nextCallTime (calls generated during tsp_EPTF_ELEMENTARY_TIMESTEP_PARAM should be added):
          vl_currentBurstSizeAsInt := float2int(vl_currentBurstSizeAsFloat*(1.0+tsp_EPTF_ELEMENTARY_TIMESTEP_PARAM/pl_schData.roundedCpsUpdateInterval)+0.5);
          if(-1 < v_LGenBase_precalcTC){
            v_LGenBase_trafficCases[v_LGenBase_precalcTC].cpsOverrunCounter := v_LGenBase_trafficCases[v_LGenBase_precalcTC].cpsOverrunCounter + 1
          }
        }
      } else {

        // new_error := old_error + (ideal-actual)
        var float vl_currentCumulativeBurstSizeError := pl_schData.burstSizeCumulativeError +
          (vl_idealBurstSize - int2float(vl_currentBurstSizeAsInt));
        //cumulativeBurstSize is the integer part of the currentBurst + currentCumulativeBurstSizeError
        vl_cumulativeBurstSize := float2int(vl_currentCumulativeBurstSizeError)
        vl_currentCumulativeBurstSizeError :=vl_currentCumulativeBurstSizeError - int2float(vl_cumulativeBurstSize)

        pl_schData.burstSizeCumulativeError :=  vl_currentCumulativeBurstSizeError;
        //pl_schData.currentBurstSize := vl_currentBurstSizeAsInt; // currentBurstSize is not changed here
      }
      
      //set number to send
      pl_maxSend := vl_currentBurstSizeAsInt + vl_cumulativeBurstSize;
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Scheduler data:"&log2str(pl_schData));
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_burstPreCalcPoisson
    //
    //  Purpose:
    //    The burst precalculation function for poisson distribution traffic
    //
    //  Parameters:
    //    pl_schData - *inout* - <EPTF_LGenBase_SchedulerData> - Scheduler data (eg. lastBurstSize)
    //    pl_when - *in* - *float* - time of scheduled event
    //    pl_maxSend - *out* - *integer* - maximum number of send
    //    pl_nextCallTime - *out* - *float* - the next call time
    //
    //  Return Value:
    //    -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_burstPreCalcPoisson(
      inout EPTF_LGenBase_SchedulerData pl_schData,
      in float pl_when,
      out integer pl_maxSend,
      out float pl_nextCallTime) runs on EPTF_LGenBase_Private_CT
    {
      var float vl_elementaryTimestep := tsp_EPTF_ELEMENTARY_TIMESTEP_PARAM;
      var integer vl_notStarted := pl_schData.lastBurstSize;  			   // not started traffic
      var float vl_lastCallTime := pl_schData.roundedCpsUpdateInterval; 	   // last exponential arriving time
      pl_nextCallTime := vl_lastCallTime + tsp_EPTF_cpsUpdateInterval;   	   // next exponential starting time
      var integer vl_toStart := 0; 						   // traffic to start
      var float vl_lambda := pl_schData.target.cpsToReach * vl_elementaryTimestep; // lambda - expected cps in one elementary timestep
      pl_maxSend := 0;
      var boolean vl_success := false;
      var integer vl_nrOfIntervals := 1;
      var integer vl_nrOfTimeSteps := 1;
      var float vl_scale := vl_elementaryTimestep;
      
      if(pl_schData.target.cpsToReach>0.0) { // cpsToReach should not be 0 because of logarithm statement.
        
        if(vl_lastCallTime == 0.0) { // if we call burst calculation at first time
          vl_lastCallTime := pl_when;
        }
        
        // overload protection: increase vl_lastCallTime if TLag is higher than 10 times the CPS update interval (to tolarate 10*CPS bursts)
        var float vl_lastCpsUpdateInterval := vl_elementaryTimestep*10.0; // = 10 times the CPS update interval
        var float vl_TLag := f_EPTF_SchedulerComp_snapshotTime() - pl_when;
        if (vl_lastCpsUpdateInterval < vl_TLag) {

          var float vl_TLagFactor :=  vl_TLag / vl_lastCpsUpdateInterval - 1.0;
          if (vl_TLagFactor>1.0) {
            vl_TLagFactor := 1.0;
          }
          // increase vl_lastCallTime to decrease CPS: It reaches the snapshotTime+vl_elementaryTimestep when vl_TLag = 2.0*vl_lastCpsUpdateInterval
          vl_lastCallTime := vl_lastCallTime + (f_EPTF_SchedulerComp_snapshotTime()+vl_elementaryTimestep-vl_lastCallTime)*vl_TLagFactor;
        }
        
        
        if(pl_schData.target.cpsToReach >= 20.0) { // if cps is big
          // we calculate nr of starts according to the poisson table
          
          if((vl_lambda) >= 200.0) {  // if lambda is large, we are scaleing down
            vl_lambda := vl_lambda / 100.0;
            vl_scale := vl_scale / 100.0;
          }
          if((vl_lambda) <= 2.0) {  // if lambda is small, we are scaleing up
            vl_lambda := vl_lambda * 10.0;
            vl_scale := vl_scale * 10.0;
          }
          
          vl_nrOfIntervals := float2int((f_EPTF_SchedulerComp_snapshotTime() - vl_lastCallTime) / vl_scale) + 1;
          pl_nextCallTime := vl_lastCallTime + int2float(vl_nrOfIntervals) * vl_scale;
          
          for(var integer vl_i := 0; vl_i < vl_nrOfIntervals; vl_i := vl_i + 1){ // maybe more updateintervals passed
            vl_toStart := vl_toStart + f_getNext_poissonValue(vl_lambda, pl_schData.poissonTable, vl_success);
          }
        }
        
        if(not(vl_success)) { // if cps is small or poisson calculating failed
          // we calculate exponential starting times
          vl_toStart := 1;
          pl_nextCallTime := vl_lastCallTime + f_gen_Exponential_Distribution(pl_schData.target.cpsToReach);
          while(pl_nextCallTime < (f_EPTF_SchedulerComp_snapshotTime() + vl_elementaryTimestep)) { // maybe more elementary timesteps passed
            pl_nextCallTime := pl_nextCallTime + f_gen_Exponential_Distribution(pl_schData.target.cpsToReach);
            vl_toStart := vl_toStart + 1;
          }
        }
      }
      
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": burstPreCalcPoisson");
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTrafficVerbose)){
        f_EPTF_LGenBase_loggingDebugTrafficVerbose(%definitionId&
          ": using poisson table: "&log2str(vl_success)&
          "\nvl_lambda: "&log2str(vl_lambda)&" / "&log2str(vl_scale)&
          "\nvl_nrOfIntervals: "&log2str(vl_nrOfIntervals)&
          "\nvl_notStarted: "&log2str(vl_notStarted)&
          "\nvl_lastCallTime: "&log2str(vl_lastCallTime)&
          "\npl_nextCallTime: "&log2str(pl_nextCallTime)&
          "\nvl_toStart: "&log2str(vl_toStart)&
          "\npl_when: "&log2str(pl_when)&
          "\nf_EPTF_SchedulerComp_snapshotTime(): "&log2str(f_EPTF_SchedulerComp_snapshotTime()))
      }
      pl_schData.roundedCpsUpdateInterval := pl_nextCallTime;
      pl_maxSend := vl_toStart + vl_notStarted;
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Scheduler data:"&log2str(pl_schData)&" pl_maxSend: "&log2str(pl_maxSend))
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_burstPreCalcIMST
    //
    //  Purpose:
    //    The burst precalculation function for IMST traffic
    //
    //  Parameters:
    //    pl_schData - *inout* - <EPTF_LGenBase_SchedulerData> - Scheduler data (eg. lastBurstSize)
    //    pl_when - *in* - *float* - time of scheduled event
    //    pl_maxSend - *out* - *integer* - maximum number of send
    //    pl_nextCallTime - *out* - *float* - the next call time
    //
    //  Return Value:
    //    -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //    Obsolete function, calls the CS
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_burstPreCalcIMST(
      inout EPTF_LGenBase_SchedulerData pl_schData,
      in float pl_when,
      out integer pl_maxSend,
      out float pl_nextCallTime) runs on EPTF_LGenBase_Private_CT
    {
      f_EPTF_LGenBase_burstPreCalcCS(pl_schData,pl_when,pl_maxSend,pl_nextCallTime)
    }
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_burstPreCalcIMST2
    //
    //  Purpose:
    //    The burst precalculation function for IMST traffic with a faster algorithm
    //
    //  Parameters:
    //    pl_schData - *inout* - <EPTF_LGenBase_SchedulerData> - Scheduler data (eg. lastBurstSize)
    //    pl_when - *in* - *float* - time of scheduled event
    //    pl_maxSend - *out* - *integer* - maximum number of send
    //    pl_nextCallTime - *out* - *float* - the next call time
    //
    //  Return Value:
    //    -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //    Obsolete function, calls the CS
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_burstPreCalcIMST2(
      inout EPTF_LGenBase_SchedulerData pl_schData,
      in float pl_when,
      out integer pl_maxSend,
      out float pl_nextCallTime) runs on EPTF_LGenBase_Private_CT
    {
      f_EPTF_LGenBase_burstPreCalcCS(pl_schData,pl_when,pl_maxSend,pl_nextCallTime)
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_burstPostCalcOrig
    //
    //  Purpose:
    //    The burst postcalculation function for EPTF traffic
    //
    //  Parameters:
    //    pl_schData - *inout* - <EPTF_LGenBase_SchedulerData> - Scheduler data (eg. lastBurstSize)
    //    pl_maxSend - *in* - *integer* - maximum number of send
    //    pl_sent - *in* - integer - the number of sent traffic
    //
    //  Return Value:
    //    boolean -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_burstPostCalcOrig(
      inout EPTF_LGenBase_SchedulerData pl_schData,
      in integer pl_maxSend,
      in integer pl_sent) runs on EPTF_LGenBase_Private_CT
    {
      
      pl_schData.lastBurstSize := pl_sent;
      pl_schData.burstSizeCumulativeError := pl_schData.burstSizeCumulativeError+int2float(pl_maxSend-pl_sent);
      
    }
    
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_burstPostCalcPoisson
    //
    //  Purpose:
    //    The burst postcalculation function for Poisson distribution traffic
    //
    //  Parameters:
    //    pl_schData - *inout* - <EPTF_LGenBase_SchedulerData> - Scheduler data (eg. lastBurstSize)
    //    pl_maxSend - *in* - *integer* - maximum number of send
    //    pl_sent - *in* - integer - the number of sent traffic
    //
    //  Return Value:
    //    boolean -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_burstPostCalcPoisson(
      inout EPTF_LGenBase_SchedulerData pl_schData,
      in integer pl_maxSend,
      in integer pl_sent) runs on EPTF_LGenBase_Private_CT
    {
      
      pl_schData.lastBurstSize := pl_maxSend - pl_sent;
      
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_burstPostCalcIMST
    //
    //  Purpose:
    //    The burst postcalculation function for IMST traffic
    //
    //  Parameters:
    //    pl_schData - *inout* - <EPTF_LGenBase_SchedulerData> - Scheduler data (eg. lastBurstSize)
    //    pl_maxSend - *in* - *integer* - maximum number of send
    //    pl_sent - *in* - integer - the number of sent traffic
    //
    //  Return Value:
    //    boolean -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //    Obsolete function, calls the CS
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_burstPostCalcIMST(
      inout EPTF_LGenBase_SchedulerData pl_schData,
      in integer pl_maxSend,
      in integer pl_sent) runs on EPTF_LGenBase_Private_CT
    {
      f_EPTF_LGenBase_burstPostCalcOrig(pl_schData,pl_maxSend,pl_sent)
    }
  } //group PrivatePredefinedBurstCal
  
  ///////////////////////////////////////////////////////////
  //  Group: PrivateTrafficManagement
  //
  //  Purpose:
  //    Private functions of the traffic management
  ///////////////////////////////////////////////////////////
  group PrivateTrafficManagement{
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_doTrafficCaseTimerAction
    //
    //  Purpose:
    //    The handler function that will be called to handle the traffic case action
    //
    //  Parameters:
    //    pl_action - *in* - <EPTF_ScheduledAction> -
    //    pl_eventIndex - *in* - *integer* -
    //
    //  Return Value:
    //    boolean - True
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_doTrafficCaseTimerAction(
      in EPTF_ScheduledAction pl_action,
      in integer pl_eventIndex)
    runs on EPTF_LGenBase_Private_CT
    return boolean{
      var integer vl_maxSend;
      var float vl_nextCallTime;
      var float vl_currentTime := f_EPTF_SchedulerComp_snapshotTime();
      var integer vl_tcIdx := pl_action.actionId[0];
      v_LGenBase_trafficCases[vl_tcIdx].schedulingTimer := -1;
      
      if(c_EPTF_Common_debugSwitch) {
        f_EPTF_Base_assert(%definitionId&"Burst PreCalc is empty.",null != v_LGenBase_trafficCases[vl_tcIdx].schedulerData.burstFuncRef.burstPreCalc);
        if(f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){   
          f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&":-------------- "&v_LGenBase_trafficCases[vl_tcIdx].uniqueName&" ----------------------");
          f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": pl_when: "&log2str(pl_action.when))
          f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": snaphot time: "&log2str(vl_currentTime))
        }
      }      
      //precalculation of burst
      v_LGenBase_precalcTC := vl_tcIdx
      v_LGenBase_trafficCases[vl_tcIdx].schedulerData.burstFuncRef.burstPreCalc.apply(
        v_LGenBase_trafficCases[vl_tcIdx].schedulerData,
        pl_action.when,
        vl_maxSend,
        vl_nextCallTime
      ); //EBENMOL
      v_LGenBase_precalcTC := -1
      v_LGenBase_trafficCases[vl_tcIdx].schedulerData.burstCalcNeeded := false; // burst recalc dont need any more
      //Start TC for entities
      var integer vl_eIdxInTC;
      vl_eIdxInTC := f_EPTF_LGenBase_getNextFreeEntity(vl_tcIdx)
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Relative idx of the entity: "&int2str(vl_eIdxInTC))
      var integer vl_sent := 0;
      
      if(ispresent(v_LGenBase_trafficCases[vl_tcIdx].trafficStartFinishConditionsAndActions.nrOfExecStart) and
        v_LGenBase_groupFinishConditionMask.nrOfExecStart){
        var integer vl_t := v_LGenBase_trafficCases[vl_tcIdx].trafficStartFinishConditionsAndActions.nrOfExecStart.count;
        if(vl_maxSend > vl_t){
          vl_maxSend := vl_t;
        }
      }
      if (  v_LGenBase_trafficCases[vl_tcIdx].enabled) {v_LGenBase_trafficCases[vl_tcIdx].currentSent := 0}
      var EPTF_LGenBase_ConditionTrue vl_finishedRec := c_EPTF_LGenBase_emptyConditionTrue;
      if(0 < vl_maxSend){
        while ( vl_sent < vl_maxSend and
          -1 < vl_eIdxInTC and
          v_LGenBase_trafficCases[vl_tcIdx].enabled and
          not vl_finishedRec.anythingFinished)
        {
          vl_finishedRec.anythingFinished := f_EPTF_LGenBase_startEntityInternal(
            v_LGenBase_trafficCases[vl_tcIdx],
            vl_tcIdx,
            vl_eIdxInTC,
            true,
            vl_finishedRec);
          vl_sent := vl_sent + 1;
          Inc(v_LGenBase_trafficCases[vl_tcIdx].currentSent);
          //Check group conditions
          //v_LGenBase_trafficCases[vl_tcIdx].groupFinishConditions.nrOfGrpLoop
          //v_LGenBase_trafficCases[vl_tcIdx].groupFinishConditions.nrOfRangeLoop
          if( not vl_finishedRec.anythingFinished ){
            vl_eIdxInTC := f_EPTF_LGenBase_getNextFreeEntity(vl_tcIdx)
          }
        }
      }
      if(vl_maxSend != vl_sent){
        v_LGenBase_trafficCases[vl_tcIdx].entityUnderrunCounter := 
        v_LGenBase_trafficCases[vl_tcIdx].entityUnderrunCounter + vl_maxSend - vl_sent
      }
      if(vl_currentTime - v_LGenBase_trafficCases[vl_tcIdx].lastCallTime > 0.0){
        v_LGenBase_trafficCases[vl_tcIdx].lastCPS := int2float(v_LGenBase_trafficCases[vl_tcIdx].lastSent) / (vl_currentTime - v_LGenBase_trafficCases[vl_tcIdx].lastCallTime);
      }
      //postcalculation of burst
      v_LGenBase_trafficCases[vl_tcIdx].schedulerData.burstFuncRef.burstPostCalc.apply(v_LGenBase_trafficCases[vl_tcIdx].schedulerData,vl_maxSend,vl_sent);
      
      for (var integer x:= 0; x<sizeof(v_LGenBase_burstGenerated); x:= x+1)
      {
        v_LGenBase_burstGenerated[x].apply( v_LGenBase_trafficCases[vl_tcIdx].schedulerData, vl_maxSend, vl_sent ); //  burst generated callback
      }
      
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&":-------------- "&v_LGenBase_trafficCases[vl_tcIdx].uniqueName&" ----------------------"&
          "\nsentMsgs: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].sentMsgs)&
          "\nreceivedAnswers: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].receivedAnswers)&
          "\npending: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].sentMsgs - v_LGenBase_trafficCases[vl_tcIdx].receivedAnswers)&
          "\nNot finished entities: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].nrOfNotFinishedEntities))
      }
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTrafficVerbose)){
        f_EPTF_LGenBase_loggingDebugTrafficVerbose(%definitionId&
          ": burstSizeCumulativeError: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].schedulerData.burstSizeCumulativeError)&
          "\npl_when: "&log2str(pl_action.when)&
          "\nvl_nextCallTime: "&log2str(vl_nextCallTime)&
          "\nsent: "&log2str(vl_sent)&
          "\nsnaphot time: "&log2str(vl_currentTime)&
          "\nlast time: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].lastCallTime)&
          "\nlast Sent: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].lastSent)&
          "\ncurrent Sent: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].currentSent)&
          "\nlast CPS: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].lastCPS))
      }
      v_LGenBase_trafficCases[vl_tcIdx].lastSent := v_LGenBase_trafficCases[vl_tcIdx].currentSent;
      v_LGenBase_trafficCases[vl_tcIdx].lastCallTime := vl_currentTime;
      if(vl_finishedRec.anythingFinished){
        f_EPTF_LGenBase_groupFinishedDetected(vl_tcIdx, vl_finishedRec);
      }else{
        if(v_LGenBase_trafficCases[vl_tcIdx].enabled){ //May be, the traffic case has been disabled
          //Start timer
          if(not f_EPTF_SchedulerComp_scheduleAction(
              vl_nextCallTime,
              refers(f_EPTF_LGenBase_doTrafficCaseTimerAction),
              {vl_tcIdx},
              v_LGenBase_trafficCases[vl_tcIdx].schedulingTimer)){
            f_EPTF_LGenBase_loggingError(%definitionId&"Can not schedule traffic case timer event.");
          }
          f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Created timer of tc "&v_LGenBase_trafficCases[vl_tcIdx].uniqueName&" == "&int2str(v_LGenBase_trafficCases[vl_tcIdx].schedulingTimer))
        }
      }
      return true;
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_groupFinishedDetected
    //
    //  Purpose:
    //    Books the finish of the traffic case
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_groupFinishedDetected(
      in integer pl_tcIdx,
      in EPTF_LGenBase_ConditionTrue pl_current
    )
    runs on EPTF_LGenBase_Private_CT{
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": The traffic case "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName&" finish detected"&
          "\nFinish conditions received: "&log2str(pl_current)&
          "\nStopped state: "&log2str(v_LGenBase_trafficCases[pl_tcIdx].stopped));
      }
      if(v_LGenBase_trafficCases[pl_tcIdx].stopped){return}
      var EPTF_LGenBase_ConditionTrue vl_conditionTemp
      f_EPTF_LGenBase_checkGroupFinishConditionFired(
        v_LGenBase_trafficCases[pl_tcIdx].groupFinishConditionDetected,
        pl_current,
        vl_conditionTemp)
      if(c_EPTF_LGenBase_emptyConditionTrue != vl_conditionTemp){
        f_EPTF_LGenBase_setGroupFinishConditionFired(
          vl_conditionTemp,
          v_LGenBase_trafficCases[pl_tcIdx].groupFinishConditionDetected);
        f_EPTF_LGenBase_processGroupFinished(pl_tcIdx, vl_conditionTemp, false);
      }
    }
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_doWeightedScenarioTimerAction
    //
    //  Purpose:
    //    The handler function that will be called to handle the
    //   traffic launch for weighted scnearios
    //
    //  Parameters:
    //    pl_action - *in* - <EPTF_ScheduledAction> -
    //    pl_eventIndex - *in* - *integer* -
    //
    //  Return Value:
    //    boolean - True
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_doWeightedScenarioTimerAction(
      in EPTF_ScheduledAction pl_action,
      in integer pl_eventIndex)
    runs on EPTF_LGenBase_Private_CT
    return boolean{
      var integer vl_maxSend;
      var float vl_nextCallTime;
      var float vl_currentTime := f_EPTF_SchedulerComp_snapshotTime();
      var integer vl_eGrpIdx := pl_action.actionId[0],
      vl_scInGrpIdx := pl_action.actionId[1];
      //v_LGenBase_trafficCases[vl_tcIdx].schedulingTimer := -1;
      v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].schedulerData.schedulingTimer := -1
      
      
      //precalculation of burst
      v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].schedulerData.burstFuncRef.burstPreCalc.apply(
        v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].schedulerData,
        pl_action.when,
        vl_maxSend,
        vl_nextCallTime)
      
      //launch traffics
      var boolean vl_scenarioEnabled := v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].enabled;
      var integer vl_sent := 0;
      var integer vl_tcPos := -1;
      if(vl_maxSend > 0) {
        vl_tcPos := f_EPTF_LGenBase_selectWeightedTrafficCase(
          v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].weightedScData.deterministicMix,
          v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].trafficMixData
        );
      }
      
      var boolean vl_congestion := false;
      var integer vl_eIdxInTC;
      var integer vl_tcIdx:=	-1;
      while (vl_sent < vl_maxSend
        and vl_tcPos >=0
        and vl_scenarioEnabled
        and not vl_congestion
        and c_EPTF_LGenBase_tcStateRunning == v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].state)
      {
        var EPTF_LGenBase_ConditionTrue vl_finishedRec := c_EPTF_LGenBase_emptyConditionTrue;
        vl_tcIdx :=	v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].tcIdxList[vl_tcPos];
        vl_eIdxInTC := f_EPTF_LGenBase_getNextFreeEntity(vl_tcIdx)
        if (vl_eIdxInTC >=0) {
          vl_finishedRec.anythingFinished := f_EPTF_LGenBase_startEntityInternal(
            v_LGenBase_trafficCases[vl_tcIdx],
            vl_tcIdx,
            vl_eIdxInTC,
            true,
            vl_finishedRec);
          vl_sent := vl_sent +1;
          Inc(v_LGenBase_trafficCases[vl_tcIdx].currentSent)
          v_LGenBase_trafficCases[vl_tcIdx].hasSent := true
        } else { //cannot start the traffix
          f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": There are no free entities in tc "&v_LGenBase_trafficCases[vl_tcIdx].uniqueName)
          vl_congestion := true
        }
        
        //if TC has finished, the we need to recalc mix
        if (vl_finishedRec.anythingFinished) {
          f_EPTF_LGenBase_groupFinishedDetected(vl_tcIdx, vl_finishedRec);
        }
        
        if (vl_sent<vl_maxSend) {
          vl_tcPos:=f_EPTF_LGenBase_selectWeightedTrafficCase(
            v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].weightedScData.deterministicMix,
            v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].trafficMixData
          )
        }
      }
      //update TC stats
      var integer vl_tcCount := sizeof(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].tcIdxList);
      for (var integer vl_i := 0; vl_i<vl_tcCount ; vl_i:=vl_i+1) {
        //if this traffic has been selected in this burst
        var integer vl_tcAbsIdx := v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].tcIdxList[vl_i];
        if (v_LGenBase_trafficCases[vl_tcAbsIdx].hasSent and
          (vl_currentTime - v_LGenBase_trafficCases[vl_tcAbsIdx].lastCallTime >= 0.001)) {
          f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": LastSentOfTC "&v_LGenBase_trafficCases[vl_tcAbsIdx].uniqueName&" == "&int2str(v_LGenBase_trafficCases[vl_tcAbsIdx].lastSent))
          f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": "&log2str(vl_currentTime - v_LGenBase_trafficCases[vl_tcAbsIdx].lastCallTime))
          v_LGenBase_trafficCases[vl_tcAbsIdx].lastCPS :=
          int2float(v_LGenBase_trafficCases[vl_tcAbsIdx].lastSent) / (vl_currentTime - v_LGenBase_trafficCases[vl_tcAbsIdx].lastCallTime);
          v_LGenBase_trafficCases[vl_tcAbsIdx].lastCallTime := vl_currentTime;
          v_LGenBase_trafficCases[vl_tcAbsIdx].lastSent := v_LGenBase_trafficCases[vl_tcAbsIdx].currentSent;
          v_LGenBase_trafficCases[vl_tcAbsIdx].hasSent := false;
          v_LGenBase_trafficCases[vl_tcAbsIdx].currentSent := 0;
        }
      }
      //FIXME This should be decided config time
      var EPTF_LGenBase_burstPostCalc_FT vl_postCalcFunc := v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].schedulerData.burstFuncRef.burstPostCalc
      if(null == vl_postCalcFunc)
      {
        if("" != v_LGenBase_burstCalcMode) {
          var EPTF_LGenBase_burstPreCalc_FT vl_preCalcFunc;
          v_LGenBase_dummyInt := f_EPTF_LGenBase_getBurstCalcFunction(v_LGenBase_burstCalcMode, vl_preCalcFunc, vl_postCalcFunc)
        }
      }
      if(null != vl_postCalcFunc)
      {
        //postcalculation of burst
        vl_postCalcFunc.apply( v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].schedulerData, vl_maxSend,vl_sent);
      }
      for (var integer x:= 0; x<sizeof(v_LGenBase_burstGenerated); x:= x+1)
      {
        v_LGenBase_burstGenerated[x].apply( v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].schedulerData, vl_maxSend, vl_sent ); //  burst generated callback
      }
      
      if (vl_congestion) {
        vl_nextCallTime := vl_currentTime + v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].schedulerData.roundedCpsUpdateInterval;
      }
      
      // MTTSM00016712 - re-scheduling if paused causes the event queue to grow when it gets unpaused/restarted, resulting in problems after cleanup:
      vl_scenarioEnabled := vl_scenarioEnabled and
      (v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].state == c_EPTF_LGenBase_tcStateRunning);
      
      if(vl_scenarioEnabled){ //May be, the traffic case has been disabled
        //Start timer
        if(not f_EPTF_SchedulerComp_scheduleAction(
            vl_nextCallTime,
            refers(f_EPTF_LGenBase_doWeightedScenarioTimerAction),
            {vl_eGrpIdx,vl_scInGrpIdx},
            v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].schedulerData.schedulingTimer)){
          f_EPTF_LGenBase_loggingError(%definitionId&" Can not schedule traffic case timer event.");
          f_EPTF_Base_stop();
        }
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Created timer of sc "&
          v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].uniqueName&" == "&
          int2str(v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scInGrpIdx].schedulerData.schedulingTimer))
      }
      
      
      return true;
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_selectWeightedTrafficCase
    //
    //  Purpose:
    //    Selects the next traffic case to execute using trafficMixer
    //
    //  Parameters:
    //    pl_deterministicMix - *boolean* - if deterministic mix
    //    pl_mixData - <EPTF_TrafficMixer_scenarioTraffixMixData> - the mixer data of the scenario
    //
    //  Return Value:
    //    *integer* - the traffic case index to start
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //    -
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_selectWeightedTrafficCase(
      in boolean pl_deterministicMix,
      inout EPTF_TrafficMixer_scenarioTraffixMixData pl_mixData
    ) runs on EPTF_LGenBase_Private_CT return integer
    {
      
      if (not pl_deterministicMix) {
        f_EPTF_TrafficMixer_generateTrafficMix_Rand(pl_mixData);
        pl_mixData.burstListIdx := 0;
      }
      
      for (var integer i:=0;i<sizeof(pl_mixData.burstList);i:=i+1) {
        if (pl_mixData.burstListIdx == sizeof(pl_mixData.burstList))
        //and pl_deterministicMix) In case of deterministic it can not happen because of the previous block
        {
          f_EPTF_TrafficMixer_generateTrafficMix(pl_mixData);
          pl_mixData.burstListIdx := 0;
        }
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
          f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": pl_mixData == "&log2str(pl_mixData))
        }
        if (pl_mixData.burstList[pl_mixData.burstListIdx] != 0) {
          pl_mixData.burstListIdx := pl_mixData.burstListIdx + 1;
          return pl_mixData.burstListIdx - 1;
        }
        pl_mixData.burstListIdx:= pl_mixData.burstListIdx + 1;
      }
      
      // EPTF_LOG_VA_CORE(tsp_debug_EPTF_CLL_CS_Admin_Functions, {CORE_DEBUG}, "f_EPTF_CS_Admin_selectTrafficCase(): unsuccessfull traffic case selection");
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Unsuccessful traffic case selection")
      return -1
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_getNextFreeEntity
    //
    //  Purpose:
    //    Retrieves the relative index of the first available entity in the tc.
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_getNextFreeEntity(in integer pl_tcAbsIdx)
    runs on EPTF_LGenBase_Private_CT
    return integer{
      f_EPTF_Base_assert(%definitionId&": Invalid traffic case index: "&int2str(pl_tcAbsIdx),-1 < pl_tcAbsIdx and pl_tcAbsIdx < sizeof(v_LGenBase_trafficCases));
      if(v_LGenBase_trafficCases[pl_tcAbsIdx].nrOfAvailableEntities > 0) {
        if(v_LGenBase_trafficCases[pl_tcAbsIdx].entityInfo.entitySelection == round_robin) {
          return f_EPTF_FBQ_getFreeSlot(v_LGenBase_trafficCases[pl_tcAbsIdx].entityInfo.fbq);
        } else {
          return f_EPTF_RNA_getRndFreeSlot(v_LGenBase_trafficCases[pl_tcAbsIdx].entityInfo.rna);
        }
      } else {
        return -1;
      }
    }
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_entityIsBusy
    //
    //  Purpose:
    //    Checkes whether the entity is in busy state.
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_entityIsBusy(
      in integer pl_eRelIdx,
      in integer pl_tcIdx)
    runs on EPTF_LGenBase_Private_CT
    return boolean{
      if(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.entitySelection == round_robin) {
        return f_EPTF_FBQ_itemIsBusy(pl_eRelIdx,v_LGenBase_trafficCases[pl_tcIdx].entityInfo.fbq);
      } else {
        return f_EPTF_RNA_itemIsBusy(pl_eRelIdx,v_LGenBase_trafficCases[pl_tcIdx].entityInfo.rna);
      }
    }
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_finishedTcListener
    //
    //  Purpose:
    //    Administrates the succesful and failed calls.
    //    Checkes the finish conditions and executes finish
    //    actions when necessary calling <f_EPTF_LGenBase_execGroupActions>
    ///////////////////////////////////////////////////////////
    friend function f_EPTF_LGenBase_finishedTcListener(
      EPTF_LGenBase_ReportedEventDescriptor pl_event,
      EPTF_IntegerList pl_listenerArgs
    )
    runs on EPTF_LGenBase_Private_CT{
      //Statistics
      //Entity
      var integer vl_entityIdx := pl_event.reportedArgs[1];
      //Find TC
      var integer vl_tcIdx := pl_event.reportedArgs[0];
      if (c_EPTF_Common_debugSwitch){
        f_EPTF_Base_assert(
          %definitionId&
          " Invalid traffic case index reported: "&log2str(vl_tcIdx),
          vl_tcIdx > -1 and vl_tcIdx < sizeof(v_LGenBase_trafficCases));
      }
      var integer vl_entityInTcFBQIdx := vl_entityIdx - v_LGenBase_entityGroups[v_LGenBase_trafficCases[vl_tcIdx].eGroupBackref].eOffset;
      if (c_EPTF_Common_debugSwitch){
        f_EPTF_Base_assert(
          %definitionId&
          " Entity #"&int2str(vl_entityInTcFBQIdx)&" of traffic case "&
          v_LGenBase_trafficCases[vl_tcIdx].uniqueName&" is not busy.",
          f_EPTF_LGenBase_entityIsBusy(vl_entityInTcFBQIdx, vl_tcIdx));
      }
      var integer vl_fsmCtxIdx := -1
      if(ispresent(pl_event.event.source) and ispresent(pl_event.event.source.fsmCtxIdx)){
        vl_fsmCtxIdx := pl_event.event.source.fsmCtxIdx
      }else{
        vl_fsmCtxIdx := f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc(vl_entityInTcFBQIdx, vl_tcIdx, 0);
      }
      if (c_EPTF_Common_debugSwitch){
        f_EPTF_Base_assert(
          %definitionId&
          ": Invalid FSM context idx.",
          -1 < vl_fsmCtxIdx and vl_fsmCtxIdx < sizeof(v_LGenBase_entities[vl_entityIdx].fsmCtxList))
      }
      if(v_LGenBase_entities[vl_entityIdx].fsmCtxList[vl_fsmCtxIdx].singleShotDebugLog){
        v_LGenBase_entities[vl_entityIdx].fsmCtxList[vl_fsmCtxIdx].singleShotDebugLog := false
        f_EPTF_Var_removeVar(v_LGenBase_entities[vl_entityIdx].fsmCtxList[vl_fsmCtxIdx].singleShotLogBufferVariable)
        v_LGenBase_entities[vl_entityIdx].fsmCtxList[vl_fsmCtxIdx].singleShotLogBufferVariable := -1
      }
      var float vl_transactionTime := T_EPTF_componentClock.read -
      v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].startTime
      for ( var integer vl_cb := 0; vl_cb < sizeof(v_LGenBase_setTransactionTimeStatValueFnList) ; vl_cb := vl_cb+1 ){
        v_LGenBase_setTransactionTimeStatValueFnList[vl_cb].apply( vl_tcIdx, vl_entityInTcFBQIdx, vl_transactionTime )
      }
      
      v_LGenBase_tempFinishedRec := c_EPTF_LGenBase_emptyConditionTrue;
      var boolean vl_success := false;
      Dec(v_LGenBase_trafficCases[vl_tcIdx].nrOfRunningEntities);
      v_LGenBase_trafficCases[vl_tcIdx].receivedAnswers := v_LGenBase_trafficCases[vl_tcIdx].receivedAnswers + 1;
      v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].isRunning := false
      
      select( pl_event.event.iIdx )
      {
        case ( c_EPTF_LGenBase_inputIdx_testMgmt_finishedTcSuccess )
        {
          v_LGenBase_trafficCases[vl_tcIdx].nrOfSuccesses := v_LGenBase_trafficCases[vl_tcIdx].nrOfSuccesses + 1;
          v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfSuccesses :=
          v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfSuccesses + 1;
          vl_success := true;
          f_EPTF_LGenBaseStats_trafficSucces( vl_tcIdx )
          for ( var integer vl_cb := 0; vl_cb < sizeof(v_LGenBase_refreshSuccFnList) ; vl_cb := vl_cb+1 ){
            v_LGenBase_refreshSuccFnList[vl_cb].apply( vl_tcIdx )
          }
          if(not v_LGenBase_trafficCases[vl_tcIdx].stopped and
            not v_LGenBase_trafficCases[vl_tcIdx].groupFinishConditionDetected.nrOfSuccesses and
            v_LGenBase_groupFinishConditionMask.nrOfSuccesses and
            ispresent(v_LGenBase_trafficCases[vl_tcIdx].trafficStartFinishConditionsAndActions.nrOfSuccesses) and
            v_LGenBase_trafficCases[vl_tcIdx].trafficStartFinishConditionsAndActions.nrOfSuccesses.count <= v_LGenBase_trafficCases[vl_tcIdx].nrOfSuccesses){
            v_LGenBase_tempFinishedRec.anythingFinished := true
            v_LGenBase_tempFinishedRec.nrOfSuccesses := true
          }
          
          //ILog: log short chainat the end of a successfull TC
          f_EPTF_LGenBase_ILog_logSuccess(vl_entityIdx, vl_fsmCtxIdx);
        }
        case ( c_EPTF_LGenBase_inputIdx_testMgmt_finishedTcFail )
        {
          v_LGenBase_trafficCases[vl_tcIdx].nrOfFails := v_LGenBase_trafficCases[vl_tcIdx].nrOfFails + 1;
          v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfFails :=
          v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfFails + 1;
          f_EPTF_LGenBaseStats_trafficFail( vl_tcIdx )
          for ( var integer vl_cb := 0; vl_cb < sizeof(v_LGenBase_refreshFailFnList) ; vl_cb := vl_cb+1 ){
            v_LGenBase_refreshFailFnList[vl_cb].apply( vl_tcIdx )
          }
          if(not v_LGenBase_trafficCases[vl_tcIdx].stopped and
            not v_LGenBase_trafficCases[vl_tcIdx].groupFinishConditionDetected.nrOfFails and
            v_LGenBase_groupFinishConditionMask.nrOfFails and
            ispresent(v_LGenBase_trafficCases[vl_tcIdx].trafficStartFinishConditionsAndActions.nrOfFails) and
            v_LGenBase_trafficCases[vl_tcIdx].trafficStartFinishConditionsAndActions.nrOfFails.count <= v_LGenBase_trafficCases[vl_tcIdx].nrOfFails){
            v_LGenBase_tempFinishedRec.anythingFinished := true
            v_LGenBase_tempFinishedRec.nrOfFails := true
          }
          
          //ILog: log all chains in case of failed TC
          var integer vl_iLogElementId := f_EPTF_LGenBase_ILog_addToChainsBase(vl_entityIdx, vl_fsmCtxIdx, v_LGenBase_ILog_DB_Idx);
          if (vl_iLogElementId!=-1) {
            v_LGenBase_ILog_DB[vl_iLogElementId] := f_EPTF_Time() & ": EPTF_CLL_LGenBase: ILog: TC finished with fail";
          }
          f_EPTF_LGenBase_ILog_logFailed(vl_entityIdx, vl_fsmCtxIdx);
          
        }
        case ( c_EPTF_LGenBase_inputIdx_testMgmt_finishedTcError )
        {
          v_LGenBase_trafficCases[vl_tcIdx].nrOfErrors := v_LGenBase_trafficCases[vl_tcIdx].nrOfErrors + 1;
          v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfErrors :=
          v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfErrors + 1;
          f_EPTF_LGenBaseStats_trafficError( vl_tcIdx )
          for ( var integer vl_cb := 0; vl_cb < sizeof(v_LGenBase_refreshErrorFnList) ; vl_cb := vl_cb+1 ){
            v_LGenBase_refreshErrorFnList[vl_cb].apply( vl_tcIdx )
          }
          if(not v_LGenBase_trafficCases[vl_tcIdx].stopped and
            not v_LGenBase_trafficCases[vl_tcIdx].groupFinishConditionDetected.nrOfErrors and
            v_LGenBase_groupFinishConditionMask.nrOfErrors and
            ispresent(v_LGenBase_trafficCases[vl_tcIdx].trafficStartFinishConditionsAndActions.nrOfErrors) and
            v_LGenBase_trafficCases[vl_tcIdx].trafficStartFinishConditionsAndActions.nrOfErrors.count <= v_LGenBase_trafficCases[vl_tcIdx].nrOfErrors){
            v_LGenBase_tempFinishedRec.anythingFinished := true
            v_LGenBase_tempFinishedRec.nrOfErrors := true
          }
          
          
          //ILog: log all chains in case of TC finished with error
          var integer vl_iLogElementId := f_EPTF_LGenBase_ILog_addToChainsBase(vl_entityIdx, vl_fsmCtxIdx, v_LGenBase_ILog_DB_Idx);
          if (vl_iLogElementId!=-1) {
            v_LGenBase_ILog_DB[vl_iLogElementId] := f_EPTF_Time() & ": EPTF_CLL_LGenBase: ILog: TC finished with error";
          }
          f_EPTF_LGenBase_ILog_logFailed(vl_entityIdx, vl_fsmCtxIdx);
        }
        case ( c_EPTF_LGenBase_inputIdx_testMgmt_finishedTcTimeout )
        {
          v_LGenBase_trafficCases[vl_tcIdx].nrOfTimeouts := v_LGenBase_trafficCases[vl_tcIdx].nrOfTimeouts + 1;
          v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfTimeouts :=
          v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfTimeouts + 1;
          f_EPTF_LGenBaseStats_trafficTimeout( vl_tcIdx )
          for ( var integer vl_cb := 0; vl_cb < sizeof(v_LGenBase_refreshTimeoutFnList) ; vl_cb := vl_cb+1 ){
            v_LGenBase_refreshTimeoutFnList[vl_cb].apply( vl_tcIdx )
          }
          if(not v_LGenBase_trafficCases[vl_tcIdx].stopped and
            not v_LGenBase_trafficCases[vl_tcIdx].groupFinishConditionDetected.nrOfTimeouts and
            v_LGenBase_groupFinishConditionMask.nrOfTimeouts and
            ispresent(v_LGenBase_trafficCases[vl_tcIdx].trafficStartFinishConditionsAndActions.nrOfTimeouts) and
            v_LGenBase_trafficCases[vl_tcIdx].trafficStartFinishConditionsAndActions.nrOfTimeouts.count <= v_LGenBase_trafficCases[vl_tcIdx].nrOfTimeouts){
            v_LGenBase_tempFinishedRec.anythingFinished := true
            v_LGenBase_tempFinishedRec.nrOfTimeouts := true
          }
          
          
          //ILog: log all chains in case of timed out TC
          var integer vl_iLogElementId := f_EPTF_LGenBase_ILog_addToChainsBase(vl_entityIdx, vl_fsmCtxIdx, v_LGenBase_ILog_DB_Idx);
          if (vl_iLogElementId!=-1) {
            v_LGenBase_ILog_DB[vl_iLogElementId] := f_EPTF_Time() & ": EPTF_CLL_LGenBase: ILog: TC finished with timeout";
          }
          f_EPTF_LGenBase_ILog_logFailed(vl_entityIdx, vl_fsmCtxIdx);
        }
        case else
        {
          f_EPTF_LGenBase_loggingError(%definitionId&"Invalid input index in finished event: "&log2str(pl_event.event))
        }
      }
      var integer vl_pending := v_LGenBase_trafficCases[vl_tcIdx].sentMsgs - v_LGenBase_trafficCases[vl_tcIdx].receivedAnswers;
      var EPTF_LGenBase_EntityState vl_state := none;
      var EPTF_LGenBase_evaluateSuccess4EntityAtEntityGroup2_FT vl_succFn := v_LGenBase_trafficCases[vl_tcIdx].customEntitySucc2;
      
      if(null != vl_succFn){
        vl_state := vl_succFn.apply( vl_tcIdx, vl_entityInTcFBQIdx, vl_success );
      }else{
        var EPTF_LGenBase_evaluateSuccess4EntityAtEntityGroup_FT vl_succPrevFn := v_LGenBase_trafficCases[vl_tcIdx].customEntitySuccPrev;
        if(null != vl_succPrevFn){
          if(vl_succPrevFn.apply( vl_tcIdx, vl_entityInTcFBQIdx)){
            vl_state := pass
          }else{
            vl_state := fail;
          }
        }else{
          vl_state := f_EPTF_LGenBase_successSucNoFail( vl_tcIdx, vl_entityInTcFBQIdx, vl_success );
        }
      }
      f_EPTF_LGenBase_setEntityState(vl_entityInTcFBQIdx, vl_tcIdx, vl_state);
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&
          "Entity#"&int2str(vl_entityIdx)&" has finished in TC:"&v_LGenBase_trafficCases[vl_tcIdx].uniqueName&
          "\npending msgs: "&log2str(vl_pending)&
          "\nsuccessful: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].nrOfSuccesses)&
          "\nfailed: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].nrOfFails)&
          "\nerroneous: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].nrOfErrors)&
          "\ntimed out: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].nrOfTimeouts)&
          "\nentity success: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfSuccesses)&
          "\nentity failes: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfFails)&
          "\nentity errors: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfErrors)&
          "\nentity timeouts: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfTimeouts)
        )
      }
      //Entity finish conditions
      if(((ispresent(v_LGenBase_trafficCases[vl_tcIdx].entityFinishConditions.nrOfExecStart) and
            v_LGenBase_trafficCases[vl_tcIdx].entityFinishConditions.nrOfExecStart <=
            v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfStarts) or
          (ispresent(v_LGenBase_trafficCases[vl_tcIdx].entityFinishConditions.customFinishCondition) and
            null != v_LGenBase_trafficCases[vl_tcIdx].entityFinishConditions.customFinishCondition and
            v_LGenBase_trafficCases[vl_tcIdx].entityFinishConditions.customFinishCondition.apply( vl_tcIdx, vl_entityInTcFBQIdx )) or
          (ispresent(v_LGenBase_trafficCases[vl_tcIdx].entityFinishConditions.nrOfSuccesses) and
            v_LGenBase_trafficCases[vl_tcIdx].entityFinishConditions.nrOfSuccesses <=
            v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfSuccesses) or
          (ispresent(v_LGenBase_trafficCases[vl_tcIdx].entityFinishConditions.nrOfErrors) and
            v_LGenBase_trafficCases[vl_tcIdx].entityFinishConditions.nrOfErrors <=
            v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfErrors) or
          (ispresent(v_LGenBase_trafficCases[vl_tcIdx].entityFinishConditions.nrOfTimeouts) and
            v_LGenBase_trafficCases[vl_tcIdx].entityFinishConditions.nrOfTimeouts <=
            v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfTimeouts) or
          (ispresent(v_LGenBase_trafficCases[vl_tcIdx].entityFinishConditions.nrOfFails) and
            v_LGenBase_trafficCases[vl_tcIdx].entityFinishConditions.nrOfFails <=
            v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].nrOfFails))
      ){
        //Yes, it's finished
        Dec(v_LGenBase_trafficCases[vl_tcIdx].nrOfNotFinishedEntities);
        //Check whether the group finish condition is true too
        if(not v_LGenBase_trafficCases[vl_tcIdx].groupFinishConditionDetected.entitiesFinished and
          v_LGenBase_groupFinishConditionMask.entitiesFinished and
          ispresent(v_LGenBase_trafficCases[vl_tcIdx].trafficStartFinishConditionsAndActions.entitiesFinished) and
          0 == v_LGenBase_trafficCases[vl_tcIdx].nrOfNotFinishedEntities ){
          v_LGenBase_tempFinishedRec.anythingFinished := true
          v_LGenBase_tempFinishedRec.entitiesFinished := true
        }
        if(not v_LGenBase_trafficCases[vl_tcIdx].groupFinishConditionDetected.availableEntitiesFinished and
          v_LGenBase_groupFinishConditionMask.availableEntitiesFinished and
          ispresent(v_LGenBase_trafficCases[vl_tcIdx].trafficStartFinishConditionsAndActions.availableEntitiesFinished) and
          0 == v_LGenBase_trafficCases[vl_tcIdx].nrOfRunningEntities and
          0 == v_LGenBase_trafficCases[vl_tcIdx].nrOfAvailableEntities ){
          v_LGenBase_tempFinishedRec.anythingFinished := true
          v_LGenBase_tempFinishedRec.availableEntitiesFinished := true
        }
        
        //Execute entity finish actions
        if(v_LGenBase_trafficCases[vl_tcIdx].state == c_EPTF_LGenBase_tcStateRunning or v_LGenBase_trafficCases[vl_tcIdx].state == c_EPTF_LGenBase_tcStatePaused){
          v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].finished := true;
          var integer vl_efaCount := sizeof(v_LGenBase_trafficCases[vl_tcIdx].entityFinishActions);
          for ( var integer vl_i := 0; vl_i < vl_efaCount ; vl_i := vl_i+1 )
          {
            select( v_LGenBase_trafficCases[vl_tcIdx].entityFinishActions[vl_i] )
            {
              case ( {disableEntity4Tc := ?} )
              {
                f_EPTF_LGenBase_disableEntityInTrafficCase(
                  v_LGenBase_trafficCases[vl_tcIdx].entityFinishActions[vl_i].disableEntity4Tc.tcIdx,
                  vl_entityInTcFBQIdx);
              }
              case ( {enableEntity4Tc := ?} )
              {
                select( v_LGenBase_trafficCases[vl_tcIdx].entityFinishActions[vl_i].enableEntity4Tc.aMode )
                {
                  case ( enableIfPreviousSuccess )
                  {
                    if(pass == f_EPTF_LGenBase_getEntityState(vl_entityInTcFBQIdx, vl_tcIdx)){
                      f_EPTF_LGenBase_enableEntityInTrafficCase(
                        v_LGenBase_trafficCases[vl_tcIdx].entityFinishActions[vl_i].enableEntity4Tc.tcIdx,
                        vl_entityInTcFBQIdx);
                    }else{
                      f_EPTF_LGenBase_disableEntityInTrafficCase(
                        v_LGenBase_trafficCases[vl_tcIdx].entityFinishActions[vl_i].enableEntity4Tc.tcIdx,
                        vl_entityInTcFBQIdx);
                    }
                  }
                  case (available){
                    f_EPTF_LGenBase_enableEntityInTrafficCase(
                      v_LGenBase_trafficCases[vl_tcIdx].entityFinishActions[vl_i].enableEntity4Tc.tcIdx,
                      vl_entityInTcFBQIdx);
                  }
                  case (non_available){
                    f_EPTF_LGenBase_disableEntityInTrafficCase(
                      v_LGenBase_trafficCases[vl_tcIdx].entityFinishActions[vl_i].enableEntity4Tc.tcIdx,
                      vl_entityInTcFBQIdx);
                  }
                }
              }
              case ( {generateFsmEvent := ?} )
              {
                f_EPTF_Base_assert(%definitionId&"Invalid event ID.",
                  v_LGenBase_trafficCases[vl_tcIdx].entityFinishActions[vl_i].generateFsmEvent.iIdx > -1 and
                  v_LGenBase_trafficCases[vl_tcIdx].entityFinishActions[vl_i].generateFsmEvent.iIdx <= c_EPTF_LGenBase_lastInputIdx);
                f_EPTF_LGenBase_dispatchEvent({
                    event := {
                      bIdx := c_EPTF_LGenBase_bIdx,
                      iIdx := v_LGenBase_trafficCases[vl_tcIdx].entityFinishActions[vl_i].generateFsmEvent.iIdx,
                      target := {
                        eIdx := vl_entityIdx,
                        fsmCtxIdx := f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc(vl_entityInTcFBQIdx, vl_tcIdx, 0)
                      },
                      source := {
                        eIdx := vl_entityIdx,
                        fsmCtxIdx := vl_fsmCtxIdx
                      }
                    },
                    reportedArgs := {}
                  });
              }
              case ( {customFinishFunction := ?} )
              {
                if ( null != v_LGenBase_trafficCases[vl_tcIdx].entityFinishActions[vl_i].customFinishFunction )
                {
                  v_LGenBase_trafficCases[vl_tcIdx].entityFinishActions[vl_i].customFinishFunction.apply( vl_entityIdx );
                }
              }
              case else
              {
                //A bit paranoia, EPTF_LGenBase_TcMgmt_EntityActions type changed
                f_EPTF_Base_assert(%definitionId&"Invalid action type.",false);
              }
            }
          }
        }
        
      }else{
        //HN15601
        if(not v_LGenBase_trafficCases[vl_tcIdx].entityInfo.itemList[vl_entityInTcFBQIdx].disabled){
          //Put back to free chain
          if (c_EPTF_Common_debugSwitch){
            f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Put back Entity#"&int2str(vl_entityIdx)&" in "&v_LGenBase_trafficCases[vl_tcIdx].uniqueName&" rel. idx: "&int2str(vl_entityInTcFBQIdx))
          }
          if(v_LGenBase_trafficCases[vl_tcIdx].entityInfo.entitySelection == round_robin) {
            f_EPTF_FBQ_moveFromBusyToFreeTail(vl_entityInTcFBQIdx, v_LGenBase_trafficCases[vl_tcIdx].entityInfo.fbq);
          } else {
            if(not f_EPTF_RNA_moveFromBusyToFreeSlot(vl_entityInTcFBQIdx, v_LGenBase_trafficCases[vl_tcIdx].entityInfo.rna)){
              f_EPTF_Base_assert(%definitionId&": Error in f_EPTF_RNA_moveFromBusyToFreeSlot",false)
            }
          }
          Inc(v_LGenBase_trafficCases[vl_tcIdx].nrOfAvailableEntities);
        }
      }
      if (c_EPTF_Common_debugSwitch){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&":---- Not finished: "&int2str(v_LGenBase_trafficCases[vl_tcIdx].nrOfNotFinishedEntities))
      }
      //Group finish conditions
      if (not v_LGenBase_trafficCases[vl_tcIdx].stopped){
        if(not v_LGenBase_trafficCases[vl_tcIdx].groupFinishConditionDetected.customFinishCondition and
          v_LGenBase_groupFinishConditionMask.customFinishCondition and
          ispresent(v_LGenBase_trafficCases[vl_tcIdx].trafficStartFinishConditionsAndActions.customFinishConditionFuncRef) and
          v_LGenBase_trafficCases[vl_tcIdx].trafficStartFinishConditionsAndActions.customFinishConditionFuncRef.functionRef.apply(vl_tcIdx, vl_entityInTcFBQIdx)){
          v_LGenBase_tempFinishedRec.anythingFinished := true
          v_LGenBase_tempFinishedRec.customFinishCondition := true
        }
        if(v_LGenBase_tempFinishedRec.anythingFinished)
        {
          f_EPTF_LGenBase_groupFinishedDetected(vl_tcIdx, v_LGenBase_tempFinishedRec);
        }
      }
      if(v_LGenBase_trafficCases[vl_tcIdx].groupFinishConditionProcessed.anythingFinished and
        not v_LGenBase_trafficCases[vl_tcIdx].stopped)
      {
        f_EPTF_LGenBase_checkLaunchFinished(vl_tcIdx);
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_checkLaunchFinished
    //
    //  Purpose:
    //    This internal function checks whether the launch on the
    //    specified traffic case had finished.
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_checkLaunchFinished(in integer pl_tcIdx)
    runs on EPTF_LGenBase_Private_CT{
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTrafficVerbose)){
        f_EPTF_LGenBase_loggingDebugTrafficVerbose(%definitionId&": ---- checkLaunchFinished");
        f_EPTF_LGenBase_loggingDebugTrafficVerbose(%definitionId&": NotFinishedEntities"&log2str(v_LGenBase_trafficCases[pl_tcIdx].nrOfNotFinishedEntities))
        f_EPTF_LGenBase_loggingDebugTrafficVerbose(%definitionId&": groupFinishConditionDetected"&log2str(v_LGenBase_trafficCases[pl_tcIdx].groupFinishConditionDetected))
        f_EPTF_LGenBase_loggingDebugTrafficVerbose(%definitionId&": groupFinishConditionProcessed"&log2str(v_LGenBase_trafficCases[pl_tcIdx].groupFinishConditionProcessed))
        f_EPTF_LGenBase_loggingDebugTrafficVerbose(%definitionId&": nrOfStarts"&log2str(v_LGenBase_trafficCases[pl_tcIdx].nrOfStarts))
        f_EPTF_LGenBase_loggingDebugTrafficVerbose(%definitionId&": nrOfFails"&log2str(v_LGenBase_trafficCases[pl_tcIdx].nrOfFails))
        f_EPTF_LGenBase_loggingDebugTrafficVerbose(%definitionId&": nrOfErrors"&log2str(v_LGenBase_trafficCases[pl_tcIdx].nrOfErrors))
        f_EPTF_LGenBase_loggingDebugTrafficVerbose(%definitionId&": nrOfTimeouts"&log2str(v_LGenBase_trafficCases[pl_tcIdx].nrOfTimeouts))
        f_EPTF_LGenBase_loggingDebugTrafficVerbose(%definitionId&": nrOfSuccesses"&log2str(v_LGenBase_trafficCases[pl_tcIdx].nrOfSuccesses))
      }
      if(v_LGenBase_trafficCases[pl_tcIdx].groupFinishConditionProcessed.anythingFinished and
        0 == v_LGenBase_trafficCases[pl_tcIdx].nrOfRunningEntities
        /*v_LGenBase_trafficCases[pl_tcIdx].nrOfStarts ==
        v_LGenBase_trafficCases[pl_tcIdx].nrOfFails +
        v_LGenBase_trafficCases[pl_tcIdx].nrOfErrors +
        v_LGenBase_trafficCases[pl_tcIdx].nrOfTimeouts +
        v_LGenBase_trafficCases[pl_tcIdx].nrOfSuccesses*/
      ){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Traffic finished for tc "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
        f_EPTF_LGenBase_dispatchEvent({
            event := {
              bIdx := c_EPTF_LGenBase_bIdx,
              iIdx := c_EPTF_LGenBase_inputIdx_testMgmt_launchedTrafficFinished,
              target := omit,
              source := omit
            },
            reportedArgs := {pl_tcIdx}
          });
        
        if(null != v_LGenBase_groupFinishedFn){
          if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
            f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Calling elder callback: "&
              log2str(v_LGenBase_groupFinishedFn))
          }
          v_LGenBase_groupFinishedFn.apply(pl_tcIdx, onLaunchFinish);
        }else{
          if(null != v_LGenBase_groupFinishedPerConditionFn){
            if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
              f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Calling callback: "&
                log2str(v_LGenBase_groupFinishedPerConditionFn))
            }
            v_LGenBase_groupFinishedPerConditionFn.apply(pl_tcIdx, {trafficFinished := {}});
          }else{
            if(0 != sizeof(v_LGenBase_trafficCases[pl_tcIdx].trafficFinishedActions)){
              f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Calling f_EPTF_LGenBase_execTrafficFinishedActions")
              f_EPTF_LGenBase_execTrafficFinishedActions(pl_tcIdx)
            }
          }
        }
        
        var integer vl_scIdx := v_LGenBase_trafficCases[pl_tcIdx].eScenarioBackRef;
        var integer vl_eGrpIdx := v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref;
        var integer vl_runningTcs := v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].startedTcs - 1;
        v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].startedTcs := vl_runningTcs;
        v_LGenBase_trafficCases[pl_tcIdx].state := c_EPTF_LGenBase_tcStateTerminated;
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": State of tc "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName&": "&c_EPTF_LGenBase_stateNames[v_LGenBase_trafficCases[pl_tcIdx].state]);
        f_EPTF_LGenBase_tcStateChanged(pl_tcIdx);
        
        if(null != v_LGenBase_detectPhaseFinishFn){v_LGenBase_detectPhaseFinishFn.apply( pl_tcIdx )}
        //f_EPTF_LGenBase_callPhaseFinishConditions(pl_tcIdx); // calling phase finish condition checking
        
        if(0 == vl_runningTcs){
          f_EPTF_LGenBase_dispatchEvent({
              event := {
                bIdx := c_EPTF_LGenBase_bIdx,
                iIdx := c_EPTF_LGenBase_inputIdx_testMgmt_scenarioFinished,
                target := omit,
                source := omit
              },
              reportedArgs := {pl_tcIdx}
            });
        }
      }
    }
    
    friend function f_EPTF_LGenBase_execTrafficFinishedActions(in integer pl_tcIdx)
    runs on EPTF_LGenBase_Private_CT{
      f_EPTF_LGenBase_execGroupActions(v_LGenBase_trafficCases[pl_tcIdx], v_LGenBase_trafficCases[pl_tcIdx].trafficFinishedActions, pl_tcIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_execGroupFinishActions
    //
    //  Purpose:
    //    Executes the actions associated to the conditions described
    //    in the pl_cause parameter.
    //
    //  Detailed Comments:
    //    Since the function was developed primarily for CLL internal use,
    //    be very careful if you decided to use it.
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_execGroupFinishActions(
      in integer pl_tcIdx,
      in EPTF_LGenBase_finishCallbackCause pl_cause)
    runs on EPTF_LGenBase_Private_CT{
      select( true ){
        case ( ischosen(pl_cause.conditions) ){
          f_EPTF_LGenBase_execFinishActions(pl_tcIdx, pl_cause.conditions)
          f_EPTF_LGenBase_checkLaunchFinished(pl_tcIdx)
        }
        case ( ischosen(pl_cause.trafficFinished) ){
          f_EPTF_LGenBase_execTrafficFinishedActions(pl_tcIdx)
        }
        case else{
          f_EPTF_Base_assert(%definitionId&": Programming error: the EPTF_LGenBase_finishCallbackCause had been changed, "&
            " but it isn't handled in the f_EPTF_LGenBase_execGroupFinishActions function!",true)
        }
      }
      
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_finishedAbortTcListener
    //
    //  Purpose:
    //    Event listener to handle the generic event about the handling of the
    //    abort TC event replied by the entities.
    ///////////////////////////////////////////////////////////
    friend function f_EPTF_LGenBase_finishedAbortTcListener(
      EPTF_LGenBase_ReportedEventDescriptor pl_event,
      EPTF_IntegerList pl_listenerArgs
    )
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_tcIdx := pl_event.reportedArgs[0];
      var integer vl_eRelIdx := f_EPTF_LGenBase_getERelIdx(pl_event.reportedArgs[1]);
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": \nState: "&c_EPTF_LGenBase_stateNames[v_LGenBase_trafficCases[vl_tcIdx].state])
      }
      if(c_EPTF_LGenBase_tcStateAborting == v_LGenBase_trafficCases[vl_tcIdx].state){
        f_EPTF_FBQ_moveFromFreeToBusyTail(vl_eRelIdx, v_LGenBase_trafficCases[vl_tcIdx].stoppingEntityInfo);
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
          f_EPTF_LGenBase_loggingDebugTraffic(
            "Nof remaining entities: "&log2str( f_EPTF_FBQ_getLengthOfFreeChain(v_LGenBase_trafficCases[vl_tcIdx].stoppingEntityInfo))&
            " \nTimer: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].stopTimeoutTimer))
        }
        if(0 == f_EPTF_FBQ_getLengthOfFreeChain(v_LGenBase_trafficCases[vl_tcIdx].stoppingEntityInfo)){
          if(-1 < v_LGenBase_trafficCases[vl_tcIdx].stopTimeoutTimer){
            if(not f_EPTF_SchedulerComp_CancelEvent(v_LGenBase_trafficCases[vl_tcIdx].stopTimeoutTimer)) {
              f_EPTF_LGenBase_loggingWarning(%definitionId&": Cancelling stop timeout timer failed.");
            }
            v_LGenBase_trafficCases[vl_tcIdx].stopTimeoutTimer := -1;
          }
          v_LGenBase_trafficCases[vl_tcIdx].state := c_EPTF_LGenBase_tcStateAborted;
          f_EPTF_LGenBase_tcStateChanged(vl_tcIdx);
        }
      }else{
        f_EPTF_LGenBase_loggingWarning(%definitionId&": Entity abort response of entity#"&int2str(vl_eRelIdx)&
          " of traffic case "&v_LGenBase_trafficCases[vl_tcIdx].uniqueName&" has arrived, but the TC is in "&
          c_EPTF_LGenBase_stateNames[v_LGenBase_trafficCases[vl_tcIdx].state]&" state.");
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_finishedStopTcListener
    //
    //  Purpose:
    //    Event listener to handle the generic event about the handling of the
    //    stop TC event replied by the entities.
    ///////////////////////////////////////////////////////////
    friend function f_EPTF_LGenBase_finishedStopTcListener(
      EPTF_LGenBase_ReportedEventDescriptor pl_event,
      EPTF_IntegerList pl_listenerArgs
    )
    runs on EPTF_LGenBase_Private_CT{
      var integer vl_tcIdx := pl_event.reportedArgs[0];
      var integer vl_eRelIdx := f_EPTF_LGenBase_getERelIdx(pl_event.reportedArgs[1]);
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": \nState: "&c_EPTF_LGenBase_stateNames[v_LGenBase_trafficCases[vl_tcIdx].state])
      }
      if(c_EPTF_LGenBase_tcStateStopping == v_LGenBase_trafficCases[vl_tcIdx].state){
        f_EPTF_FBQ_moveFromFreeToBusyTail(vl_eRelIdx, v_LGenBase_trafficCases[vl_tcIdx].stoppingEntityInfo);
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
          f_EPTF_LGenBase_loggingDebugTraffic(
            "Nof remaining entities: "&log2str( f_EPTF_FBQ_getLengthOfFreeChain(v_LGenBase_trafficCases[vl_tcIdx].stoppingEntityInfo))&
            " \nTimer: "&log2str(v_LGenBase_trafficCases[vl_tcIdx].stopTimeoutTimer))
        }
        if(0 == f_EPTF_FBQ_getLengthOfFreeChain(v_LGenBase_trafficCases[vl_tcIdx].stoppingEntityInfo)){
          if(-1 < v_LGenBase_trafficCases[vl_tcIdx].stopTimeoutTimer){
            if(not f_EPTF_SchedulerComp_CancelEvent(v_LGenBase_trafficCases[vl_tcIdx].stopTimeoutTimer)) {
              f_EPTF_LGenBase_loggingWarning(%definitionId&": Cancelling stop timeout timer failed.");
            }
            v_LGenBase_trafficCases[vl_tcIdx].stopTimeoutTimer := -1;
          }
          v_LGenBase_trafficCases[vl_tcIdx].state := c_EPTF_LGenBase_tcStateStopped;
          if(null != v_LGenBase_detectPhaseFinishFn){v_LGenBase_detectPhaseFinishFn.apply( vl_tcIdx )}
          //f_EPTF_LGenBase_callPhaseFinishConditions(vl_tcIdx);
          f_EPTF_LGenBase_tcStateChanged(vl_tcIdx);
        }
      }else{
        f_EPTF_LGenBase_loggingWarning(%definitionId&": Entity stop response of entity#"&int2str(vl_eRelIdx)&" of traffic case "&
          v_LGenBase_trafficCases[vl_tcIdx].uniqueName&" has arrived, but the TC is in "&
          c_EPTF_LGenBase_stateNames[v_LGenBase_trafficCases[vl_tcIdx].state]&" state.");
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_restartActionTimer
    //
    //  Purpose:
    //    Internal function to stop and start periodic tc or scenario event if it exists
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_restartActionTimer(
      inout integer pl_timer,
      in EPTF_Scheduler_ActionHandler pl_actionHandler,
      in EPTF_ActionId pl_action,
      in float pl_delay := tsp_EPTF_ELEMENTARY_TIMESTEP_PARAM
    )
    runs on EPTF_LGenBase_Private_CT{
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": "&log2str(pl_action))
      }
      if ( -1 != pl_timer )
      {
        if(f_EPTF_SchedulerComp_CancelEvent(pl_timer)) {
          pl_timer := -1
        } else {
          f_EPTF_LGenBase_loggingWarning(%definitionId&": Cancelling timer failed.");
        }
      }
      if(not f_EPTF_SchedulerComp_scheduleAction(
          T_EPTF_componentClock.read + pl_delay,
          pl_actionHandler,
          pl_action,
          pl_timer)) {
        f_EPTF_LGenBase_loggingError(%definitionId&": Can not schedule timer event.");
        //TODO Retry? 
        f_EPTF_Base_stop();
      }
      
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_tcStateChanged
    //
    //  Purpose:
    //    Checks the state of the traffic case and the scenario,
    //    and calls the callback if it's changed
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_tcStateChanged(in integer pl_tcIdx)
    runs on EPTF_LGenBase_Private_CT{
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
        f_EPTF_LGenBase_loggingDebugTraffic(log2str(%definitionId&"--------checkScState. TcIdx == ",pl_tcIdx," scenario == ",v_LGenBase_trafficCases[pl_tcIdx].eScenarioBackRef))
      }
      var integer vl_eGrpIdx := v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref;
      var integer vl_scIdx := v_LGenBase_trafficCases[pl_tcIdx].eScenarioBackRef;
      f_EPTF_LGenBaseStats_tcStateChangedCallback(pl_tcIdx)
      for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_tcStateChangedCallbacks) ; vl_i := vl_i+1 )
      {
        v_LGenBase_tcStateChangedCallbacks[vl_i].apply(pl_tcIdx);
      }
      f_EPTF_LGenBase_setScNewState(
        vl_eGrpIdx,
        vl_scIdx,
        f_EPTF_LGenBase_stateOfScenario(vl_eGrpIdx, vl_scIdx))
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_setScNewState
    //
    //  Purpose:
    //    Sets the state of the specified scenario to the new state if it
    //    wasn't equal with the previous one, and calls the registered
    //    callback functions.
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_setScNewState(
      in integer pl_eGrpIdx,
      in integer pl_scIdx,
      in EPTF_LGenBase_tcState pl_newState)
    runs on EPTF_LGenBase_Private_CT{
      if(pl_newState != v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].state){
        v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].state := pl_newState;
        f_EPTF_LGenBaseStats_scenarioStateChangedCallback( pl_eGrpIdx, pl_scIdx )
        for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_scenarioStateChangedCallbacks) ; vl_i := vl_i+1 )
        {
          v_LGenBase_scenarioStateChangedCallbacks[vl_i].apply( pl_eGrpIdx, pl_scIdx );
        }
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_processGroupFinished
    //
    //  Purpose:
    //    Books the finish of the traffic case and executes the
    //    associated actions.
    //  Detailed Comments:
    //    Since the function was developed primarily for CLL internal use,
    //    be very careful if you decided to use it.
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBase_processGroupFinished(
      in integer pl_tcIdx,
      in EPTF_LGenBase_ConditionTrue pl_current := c_EPTF_LGenBase_anythingConditionTrue,
      in boolean pl_externalCall := true
    )
    runs on EPTF_LGenBase_Private_CT{
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": The traffic case "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName&" finished");
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Finish conditions received: "&log2str(pl_current));
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": External call: "&log2str(pl_externalCall));
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": v_LGenBase_groupFinishedFn: "&log2str(v_LGenBase_groupFinishedFn));
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": v_LGenBase_groupFinishedPerConditionFn: "&log2str(v_LGenBase_groupFinishedPerConditionFn));
      }
      var EPTF_LGenBase_ConditionTrue vl_conditionTemp
      f_EPTF_LGenBase_checkGroupFinishConditionFired(
        v_LGenBase_trafficCases[pl_tcIdx].groupFinishConditionProcessed,
        pl_current,
        vl_conditionTemp)
      if(c_EPTF_LGenBase_emptyConditionTrue != vl_conditionTemp){
        if(pl_externalCall){
          f_EPTF_LGenBase_execFinishActions(pl_tcIdx, vl_conditionTemp)
        }else{
          if(null != v_LGenBase_groupFinishedFn){
            if(vl_conditionTemp.anythingFinished){
              if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
                f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Calling elder callback: "&
                  log2str(v_LGenBase_groupFinishedFn))
              }
              v_LGenBase_groupFinishedFn.apply(pl_tcIdx, onGroupFinishCondition);
            }else{
              f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": There is an elder callback, but the group finished had been reported earlier.")
            }
          }else{
            if(null != v_LGenBase_groupFinishedPerConditionFn){
              if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
                f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Calling newer callback: "&
                  log2str(v_LGenBase_groupFinishedPerConditionFn)&" with conditions "&log2str(vl_conditionTemp))
              }
              v_LGenBase_groupFinishedPerConditionFn.apply(pl_tcIdx, {conditions := vl_conditionTemp})
            }else{
              f_EPTF_LGenBase_execFinishActions(pl_tcIdx, vl_conditionTemp)
            }
          }
        }
        v_LGenBase_trafficCases[pl_tcIdx].state := c_EPTF_LGenBase_tcStateFinished;
        f_EPTF_LGenBase_tcStateChanged(pl_tcIdx);
        f_EPTF_LGenBase_disableTrafficCaseInternal(pl_tcIdx);
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_copyEntityAvailabilityModes
    //
    //  Purpose:
    //    This internal function sets the enabled/disabled state of the entities
    //    according to the pl_mode parameter and the state of the entity in the
    //    source list.
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_copyEntityAvailabilityModes(
      in EPTF_LGenBase_TcMgmt_EntityAvailabilityGroupTransferMode pl_mode,
      inout EPTF_LGenBase_EntityInfo pl_srcEntityInfo,
      inout EPTF_LGenBase_EntityInfo pl_destEntityInfo)
    runs on EPTF_LGenBase_Private_CT{
      if(noChange == pl_mode){return}
      f_EPTF_Base_assert(%definitionId&": Different FBQ sizes.",sizeof(pl_destEntityInfo.itemList)==sizeof(pl_srcEntityInfo.itemList));
      var integer vl_eCount := sizeof(pl_srcEntityInfo.itemList);
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": copyEntityAvailabilityModes");
      for ( var integer vl_i := 0; vl_i < vl_eCount ; vl_i := vl_i+1 )
      {
        var boolean vl_srcSuccess := pl_mode == available or
        (pl_mode == enableIfPreviousSuccess and pass == f_EPTF_LGenBase_integer2eState(pl_srcEntityInfo.itemList[vl_i].entityState));
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Success of entity#"&int2str(vl_i)&" == "&log2str(vl_srcSuccess))
        if(pl_destEntityInfo.entitySelection == round_robin) { // round robin
          if(vl_srcSuccess){
            if (not f_EPTF_FBQ_itemIsFree(vl_i,pl_destEntityInfo.fbq)){
              if ( f_EPTF_FBQ_itemIsBusy(vl_i,pl_destEntityInfo.fbq)){
                f_EPTF_FBQ_moveFromBusyToFreeTail(vl_i,pl_destEntityInfo.fbq);
              }else{
                if ( f_EPTF_FBQ_itemIsInvalid(vl_i,pl_destEntityInfo.fbq) )
                {
                  f_EPTF_FBQ_moveFromInvalidToFreeTail(vl_i,pl_destEntityInfo.fbq);
                }
              }
            }
          } else {
            if ( not f_EPTF_FBQ_itemIsBusy(vl_i,pl_destEntityInfo.fbq)){
              if ( f_EPTF_FBQ_itemIsInvalid(vl_i,pl_destEntityInfo.fbq) )
              {
                f_EPTF_FBQ_moveFromInvalidToBusyTail(vl_i,pl_destEntityInfo.fbq);
              }
              if ( f_EPTF_FBQ_itemIsFree(vl_i,pl_destEntityInfo.fbq)){
                f_EPTF_FBQ_moveFromFreeToBusyTail(vl_i,pl_destEntityInfo.fbq);
              }
            }
          }
        } else { // random
          if(vl_srcSuccess){
            if ( f_EPTF_RNA_itemIsBusy(vl_i,pl_destEntityInfo.rna)){
              if(not f_EPTF_RNA_moveFromBusyToFreeSlot(vl_i,pl_destEntityInfo.rna)){
                f_EPTF_Base_assert(%definitionId&": Error in f_EPTF_RNA_moveFromBusyToFreeSlot",false)
              }
            }
          } else {
            if ( f_EPTF_RNA_itemIsFree(vl_i,pl_destEntityInfo.rna)){
              if(not f_EPTF_RNA_moveFromFreeToBusySlot(vl_i,pl_destEntityInfo.rna)){
                f_EPTF_Base_assert(%definitionId&": Error in f_EPTF_RNA_moveFromFreeToBusySlot",false)
              }
            }
          }
        }
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_execGroupActions
    //
    //  Purpose:
    //    Executes finish actions
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_execGroupActions(
      inout EPTF_LGenBase_TcDescriptor pl_tcDescriptor,
      inout EPTF_LGenBase_TcMgmt_GroupActionsDescList pl_actions,
      in integer pl_tcIdx
    )
    runs on EPTF_LGenBase_Private_CT{
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&"action of "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName&" is "&log2str(pl_actions));
      }
      
      var integer vl_gfaCount := sizeof(pl_actions);
      for ( var integer vl_i := 0; vl_i < vl_gfaCount ; vl_i := vl_i+1 )
      {
        select( true )
        {
          case (ischosen(pl_actions[vl_i].enableAllTc) ){
            var integer vl_tcCount :=
            sizeof(v_LGenBase_entityGroups[pl_tcDescriptor.eGroupBackref].scenarios[pl_tcDescriptor.eScenarioBackRef].tcIdxList);
            for ( var integer vl_iTc := 0; vl_iTc < vl_tcCount ; vl_iTc := vl_iTc+1 )
            {
              f_EPTF_LGenBase_copyEntityAvailabilityModes(
                pl_actions[vl_i].enableAllTc.aMode,
                v_LGenBase_trafficCases[pl_tcIdx].entityInfo,
                v_LGenBase_trafficCases[v_LGenBase_entityGroups[pl_tcDescriptor.eGroupBackref].scenarios[pl_tcDescriptor.eScenarioBackRef].tcIdxList[vl_iTc]].entityInfo)
              f_EPTF_LGenBase_enableTrafficCaseInternal(
                v_LGenBase_entityGroups[pl_tcDescriptor.eGroupBackref].scenarios[pl_tcDescriptor.eScenarioBackRef].tcIdxList[vl_iTc]);
            }
          }
          case (ischosen(pl_actions[vl_i].disableAllTc)) {
            var integer vl_tcCount :=
            sizeof(v_LGenBase_entityGroups[pl_tcDescriptor.eGroupBackref].scenarios[pl_tcDescriptor.eScenarioBackRef].tcIdxList);
            for ( var integer vl_iTc := 0; vl_iTc < vl_tcCount ; vl_iTc := vl_iTc+1 )
            {
              if(vl_iTc != pl_tcIdx) {
                f_EPTF_LGenBase_copyEntityAvailabilityModes(
                  pl_actions[vl_i].disableAllTc.aMode,
                  v_LGenBase_trafficCases[pl_tcIdx].entityInfo,
                  v_LGenBase_trafficCases[v_LGenBase_entityGroups[pl_tcDescriptor.eGroupBackref].scenarios[pl_tcDescriptor.eScenarioBackRef].tcIdxList[vl_iTc]].entityInfo);
                f_EPTF_LGenBase_disableTrafficCaseInternal(v_LGenBase_entityGroups[pl_tcDescriptor.eGroupBackref].scenarios[pl_tcDescriptor.eScenarioBackRef].tcIdxList[vl_iTc]);
              }
            }
          }
          case ( ischosen(pl_actions[vl_i].enableTc) ){
            f_EPTF_LGenBase_copyEntityAvailabilityModes(
              pl_actions[vl_i].enableTc.aMode,
              v_LGenBase_trafficCases[pl_tcIdx].entityInfo,
              v_LGenBase_trafficCases[pl_actions[vl_i].enableTc.tcIdx].entityInfo)
            f_EPTF_LGenBase_enableTrafficCaseInternal(pl_actions[vl_i].enableTc.tcIdx);
          }
          case ( ischosen(pl_actions[vl_i].disableTc) ){
            if(pl_tcIdx != pl_actions[vl_i].disableTc.tcIdx) {
              f_EPTF_LGenBase_disableTrafficCaseInternal(pl_actions[vl_i].disableTc.tcIdx);
            }
          }
          case (ischosen(pl_actions[vl_i].generateGenericEvent) ){
            f_EPTF_Base_assert(%definitionId&"Invalid event ID.",
              pl_actions[vl_i].generateGenericEvent.iIdx > -1 and
              pl_actions[vl_i].generateGenericEvent.iIdx <= c_EPTF_LGenBase_lastInputIdx);
            f_EPTF_LGenBase_dispatchEvent({
                event := {
                  bIdx := c_EPTF_LGenBase_bIdx,
                  iIdx := pl_actions[vl_i].generateGenericEvent.iIdx,
                  target := omit,
                  source := omit
                },
                reportedArgs := {pl_tcIdx}
              });
          }
          case (ischosen(pl_actions[vl_i].customFinishFunction) ){
            if(null != pl_actions[vl_i].customFinishFunction){
              pl_actions[vl_i].customFinishFunction.apply( pl_tcIdx );
            }
          }
          case (ischosen(pl_actions[vl_i].testFinished) ){
            f_EPTF_LGenBase_dispatchEvent({
                event := {
                  bIdx := c_EPTF_LGenBase_bIdx,
                  iIdx := c_EPTF_LGenBase_inputIdx_testMgmt_testFinished,
                  target := omit,
                  source := omit
                },
                reportedArgs := {pl_tcIdx}
              });
          }
          case else
          {
            //A bit paranoia. Something changed asychronously
            f_EPTF_Base_assert(%definitionId&": Invalid FBQ state.",false);
          }
        }
        
      }
    }
    
    function Inc(inout integer pl_i){
      pl_i := pl_i + 1;
    }
    function Dec(inout integer pl_i){
      pl_i := pl_i - 1;
    }
    function IncBy(inout integer pl_i, in integer pl_diff){
      pl_i := pl_i + pl_diff;
    }
    function DecBy(inout integer pl_i, in integer pl_diff){
      pl_i := pl_i - pl_diff;
    }
    
    function SetIfLt(inout integer pl_prev, in integer pl_to){
      if(pl_to < pl_prev){
        pl_prev := pl_to;
      }
    }
    function SetIfGt(inout integer pl_prev, in integer pl_to){
      if(pl_to > pl_prev){
        pl_prev := pl_to;
      }
    }
  }//PrivateTrafficManagement
  
  ///////////////////////////////////////////////////////////
  //  Group: PrivateStartStopInit
  //
  //  Purpose:
  //    Private functions during the start, stop, etc. traffic cases
  ///////////////////////////////////////////////////////////
  group PrivateStartStopInit{

    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_resetTcStats
    //
    //  Purpose:
    //    Resets the statistics of a traffic case
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_resetTcStats(
      in integer pl_tcIdx,
      inout EPTF_LGenBase_TcDescriptor pl_tc)
    runs on EPTF_LGenBase_Private_CT
    {
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTrafficVerbose)){
        f_EPTF_LGenBase_loggingDebugTrafficVerbose(%definitionId&": "&log2str(pl_tc))
      }
      pl_tc.nrOfStarts := 0; 			//cumulative stat for all entities of the entity group
      pl_tc.nrOfSuccesses := 0; 		//cumulative stat for all entities of the entity group
      pl_tc.nrOfFails := 0; 			//cumulative stat for all entities of the entity group
      pl_tc.nrOfErrors := 0; 			//cumulative stat for all entities of the entity group
      pl_tc.nrOfTimeouts := 0; 			//cumulative stat for all entities of the entity group
      pl_tc.grpLoop := 0;

      pl_tc.schedulerData.lastBurstSize := 0; //EBENMOL
      if (pl_tc.schedulerData.burstFuncRef.burstCalcMode == c_EPTF_LGenBase_BurstCalc_poisson) {
        pl_tc.schedulerData.burstSizeCumulativeError := 0.0;
        pl_tc.schedulerData.idealBurstSize := 0.0;
        pl_tc.schedulerData.currentBurstSize := 0;
        pl_tc.schedulerData.roundedCpsUpdateInterval := 0.0;
      }
      // distribute the bursterror differently according to the traffic corrigation => smooth out cumulative bursts
      pl_tc.schedulerData.burstSizeCumulativeError := v_LGenBase_entityGroups[pl_tc.eGroupBackref].trafficCorrigation;

      pl_tc.lastCPS := 0.0;
      pl_tc.lastSent := 0;
      pl_tc.currentSent := 0;
      pl_tc.hasSent := false;

      pl_tc.lastCallTime := 0.0;
      pl_tc.groupFinishConditionDetected := c_EPTF_LGenBase_emptyConditionTrue;
      pl_tc.groupFinishConditionProcessed := c_EPTF_LGenBase_emptyConditionTrue;
      pl_tc.sentMsgs := 0;
      pl_tc.receivedAnswers := 0;
      pl_tc.rangeIndex := 0;
      for ( var integer vl_i := 0; vl_i < pl_tc.v_sizeofRanges ; vl_i := vl_i+1 )
      {
        pl_tc.rangePosInRange[vl_i] := -1;
      }
      pl_tc.rangeLoops := 0;
      //if invalid(<0) then the TC NOT running for the group
      pl_tc.nrOfNotFinishedEntities := sizeof(pl_tc.entityInfo.itemList);
      pl_tc.nrOfAllEntities := pl_tc.nrOfNotFinishedEntities;
      if(pl_tc.entityInfo.entitySelection == round_robin) {
        pl_tc.nrOfAvailableEntities := f_EPTF_FBQ_getLengthOfFreeChain(pl_tc.entityInfo.fbq);
      } else {
        pl_tc.nrOfAvailableEntities := f_EPTF_RNA_getLengthOfFreeList(pl_tc.entityInfo.rna);
      }
      pl_tc.minAvailable := pl_tc.nrOfAvailableEntities;
      pl_tc.maxBusy := 0;
      pl_tc.maxRunning := 0;
      pl_tc.nrOfRunningEntities := 0;
      pl_tc.stopped := false
      //reset variables
      var integer vl_eFirst := v_LGenBase_entityGroups[pl_tc.eGroupBackref].eOffset
      for(var integer vl_i := 0; vl_i < sizeof(pl_tc.entityInfo.itemList); vl_i := vl_i + 1){
        for ( var integer vl_siblingIdx := 0; vl_siblingIdx < sizeof(pl_tc.entityInfo.itemList[vl_i].siblingFsmCtxList) ; vl_siblingIdx := vl_siblingIdx+1 )
        {
          var integer vl_fsmIdx := f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc(vl_i,pl_tcIdx,vl_siblingIdx);
          if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
            f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Entity#"&log2str(vl_i))
            f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": fsmIdx: "&log2str(vl_fsmIdx))
            f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": varList: "&log2str(v_LGenBase_entities[vl_eFirst+vl_i].fsmCtxList[vl_fsmIdx].varList))
            f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": declared: "&log2str(v_LGenBase_fsmTables[pl_tc.fsmIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeFSM]))
          }
          for ( var integer vl_j := 0; vl_j < sizeof(v_LGenBase_entities[vl_eFirst+vl_i].fsmCtxList[vl_fsmIdx].varList) ; vl_j := vl_j+1 ){
            var EPTF_TopProviderType vl_providerType
            f_EPTF_Var_getTopProviderType(v_LGenBase_entities[vl_eFirst+vl_i].fsmCtxList[vl_fsmIdx].varList[vl_j],vl_providerType)
            if(empty == vl_providerType){
              f_EPTF_Var_adjustContent(
                v_LGenBase_entities[vl_eFirst+vl_i].fsmCtxList[vl_fsmIdx].varList[vl_j],
                v_LGenBase_fsmTables[pl_tc.fsmList[vl_siblingIdx].fsmTypeIdx].varListArray[c_EPTF_LGenBase_fsmObjectScopeFSM][vl_j].initValue)
            }
          }
        }
      }
      for(var integer i:=0; i<sizeof(pl_tc.varList); i:=i+1) {
        var EPTF_TopProviderType vl_providerType
        f_EPTF_Var_getTopProviderType(pl_tc.varList[i].varId,vl_providerType)
        if(empty == vl_providerType){
          var integer vl_varIdxInFsm := pl_tc.varList[i].idxInFsm
          var integer vl_fsmTable := pl_tc.fsmList[pl_tc.varList[i].siblingFsmIdx].fsmTypeIdx
          f_EPTF_Var_adjustContent(
            pl_tc.varList[i].varId,
            v_LGenBase_fsmTables[vl_fsmTable].varListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_varIdxInFsm].initValue)
        }
      }
      //Disable stats
      for(var integer vl_i := 0; vl_i < sizeof(pl_tc.entityInfo.itemList); vl_i := vl_i + 1){
        for ( var integer vl_siblingIdx := 0; vl_siblingIdx < sizeof(pl_tc.entityInfo.itemList[vl_i].siblingFsmCtxList) ; vl_siblingIdx := vl_siblingIdx+1 )
        {
          var integer vl_fsmIdx := f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc(vl_i,pl_tcIdx,vl_siblingIdx);
          for ( var integer vl_j := 0; vl_j < sizeof(v_LGenBase_entities[vl_eFirst+vl_i].fsmCtxList[vl_fsmIdx].statMeasStatList) ; vl_j := vl_j+1 ){
            f_EPTF_StatMeasure_disableStat(v_LGenBase_entities[vl_eFirst+vl_i].fsmCtxList[vl_fsmIdx].statMeasStatList[vl_j])
          }
        }
      }
      for(var integer i:=0; i<sizeof(pl_tc.statMeasStatList); i:=i+1) {
        f_EPTF_StatMeasure_disableStat(pl_tc.statMeasStatList[i].statId);
      }
      //Reset stats
      for(var integer vl_i := 0; vl_i < sizeof(pl_tc.entityInfo.itemList); vl_i := vl_i + 1){
        for ( var integer vl_siblingIdx := 0; vl_siblingIdx < sizeof(pl_tc.entityInfo.itemList[vl_i].siblingFsmCtxList) ; vl_siblingIdx := vl_siblingIdx+1 )
        {
          var integer vl_fsmIdx := f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc(vl_i,pl_tcIdx,vl_siblingIdx);
          for ( var integer vl_j := 0; vl_j < sizeof(v_LGenBase_entities[vl_eFirst+vl_i].fsmCtxList[vl_fsmIdx].statMeasStatList) ; vl_j := vl_j+1 ){
            f_EPTF_StatMeasure_initStatValue(v_LGenBase_entities[vl_eFirst+vl_i].fsmCtxList[vl_fsmIdx].statMeasStatList[vl_j])
          }
        }
      }
      for(var integer i:=0; i<sizeof(pl_tc.statMeasStatList); i:=i+1) {
        f_EPTF_StatMeasure_initStatValue(pl_tc.statMeasStatList[i].statId);
      }
      //Enable stats
      for(var integer vl_i := 0; vl_i < sizeof(pl_tc.entityInfo.itemList); vl_i := vl_i + 1){
        for ( var integer vl_siblingIdx := 0; vl_siblingIdx < sizeof(pl_tc.entityInfo.itemList[vl_i].siblingFsmCtxList) ; vl_siblingIdx := vl_siblingIdx+1 )
        {
          var integer vl_fsmIdx := f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc(vl_i,pl_tcIdx,vl_siblingIdx);
          for ( var integer vl_j := 0; vl_j < sizeof(v_LGenBase_entities[vl_eFirst+vl_i].fsmCtxList[vl_fsmIdx].statMeasStatList) ; vl_j := vl_j+1 ){
            f_EPTF_StatMeasure_enableStat(v_LGenBase_entities[vl_eFirst+vl_i].fsmCtxList[vl_fsmIdx].statMeasStatList[vl_j])
          }
        }
      }
      for(var integer i:=0; i<sizeof(pl_tc.statMeasStatList); i:=i+1) {
        f_EPTF_StatMeasure_enableStat(pl_tc.statMeasStatList[i].statId);
      }
      pl_tc.cpsOverrunCounter := 0
    }

    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_initTCInternal
    //
    //  Purpose:
    //    Internal function to initialize the entities and the statistics of a traffic case
    //
    //  Detailed Comments:
    //    To initialize a tc before restart, call <f_EPTF_LGenBase_restoreTC>.
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_initTCInternal(
      inout EPTF_LGenBase_TcDescriptor pl_tc,
      in integer pl_tcIdx,
      in boolean pl_enableEntities,
      in boolean pl_create)
    runs on EPTF_LGenBase_Private_CT
    {
      var integer vl_maxEntities := v_LGenBase_entityGroups[pl_tc.eGroupBackref].eCount;
      pl_tc.entityInfo.fbq := c_EPTF_emptyFreeBusyQueue;
      pl_tc.entityInfo.rna := c_EPTF_RNA_emptyRandomNArray;
      f_EPTF_FBQ_initFreeBusyQueue(pl_tc.entityInfo.fbq);
      f_EPTF_FBQ_createFreeSlots(vl_maxEntities, pl_tc.entityInfo.fbq);
      f_EPTF_RNA_initRFBA(vl_maxEntities, pl_tc.entityInfo.rna);
      //Fill entities from group
      for(var integer vl_i := 0; vl_i < vl_maxEntities; vl_i := vl_i + 1){
        var integer vl_absEIdx := v_LGenBase_entityGroups[pl_tc.eGroupBackref].eOffset+ vl_i;
        var EPTF_IntegerList vl_fsmCtxIdxList;
        if(not pl_create){
          //vl_fsmCtxIdx := f_EPTF_LGenBase_activateFsm(vl_absEIdx, pl_tc.fsmIdx, c_EPTF_LGenBase_idleStateIndex, pl_tcIdx);
          //}else{

            vl_fsmCtxIdxList := pl_tc.entityInfo.itemList[vl_i].siblingFsmCtxList;

        }
        pl_tc.entityInfo.itemList[vl_i] := c_EPTF_LGenBase_emptyEntityItem;
        pl_tc.entityInfo.itemList[vl_i].entityIdx := vl_absEIdx;

        if(not pl_create){
          pl_tc.entityInfo.itemList[vl_i].siblingFsmCtxList := vl_fsmCtxIdxList;
        }
        if(not pl_enableEntities){
          f_EPTF_FBQ_moveFromFreeToBusyTail(vl_i, pl_tc.entityInfo.fbq);
          if(not f_EPTF_RNA_moveFromFreeToBusySlot(vl_i, pl_tc.entityInfo.rna)){
            f_EPTF_Base_assert(%definitionId&": Error in f_EPTF_RNA_moveFromFreeToBusySlot",false)
          }
        }
      }
      if(pl_create){
        //FSM list
        //Create TC variable, stats hashmaps
        f_EPTF_LGenBase_createTCHashmaps(pl_tc);
        //Activate the FSMs
        for ( var integer vl_fsm := 0; vl_fsm < sizeof(pl_tc.fsmList) ; vl_fsm := vl_fsm+1 ){
          v_LGenBase_dummyInt := f_EPTF_LGenBase_activateFsmGroup(
            pl_tc.fsmList[vl_fsm].fsmTypeIdx, 
            c_EPTF_LGenBase_idleStateIndex, 
            {tcData := {
                tcIdx := pl_tcIdx,
                siblingIdx := vl_fsm
              }
            })
        }
        //Register SiblingFSM stathandler providers
        for ( var integer vl_i := 0; vl_i < sizeof(pl_tc.siblingStatHandlerStatList) ; vl_i := vl_i+1 ){
          for ( var integer vl_eRelIdx := 0; vl_eRelIdx < sizeof(pl_tc.entityInfo.itemList) ; vl_eRelIdx := vl_eRelIdx+1 ){
            var charstring vl_statName := f_EPTF_LGenBase_varNameOfSiblingFSMsVar(pl_tcIdx, vl_eRelIdx, pl_tc.siblingStatHandlerStatList[vl_i].statName);
            if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
              f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Registering SiblingFSM statHandler providers for statHandler "&vl_statName&
                " of traffic case "&pl_tc.uniqueName)
            }
            var integer vl_tableType := pl_tc.fsmList[pl_tc.siblingStatHandlerStatList[vl_i].siblingFsmIdx].fsmTypeIdx
            f_EPTF_LGenBase_registerStatHandlerProviders(
              v_LGenBase_fsmTables[vl_tableType].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeSiblingFSM][vl_i].providers,
              v_LGenBase_fsmTables[vl_tableType],
              vl_tableType,
              pl_tcIdx,
              vl_statName,
              c_EPTF_LGenBase_fsmObjectScopeSiblingFSM,
              pl_tc.siblingStatHandlerStatList[vl_i].siblingFsmIdx,
              vl_eRelIdx)
          }
        }
        
        //Register TC stathandler providers
        for ( var integer vl_i := 0; vl_i < sizeof(pl_tc.statHandlerStatList) ; vl_i := vl_i+1 )
        {
          var charstring vl_statName := f_EPTF_LGenBase_varNameOfTCVar(pl_tcIdx, pl_tc.statHandlerStatList[vl_i].statName);
          if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugFsmVars)){
            f_EPTF_LGenBase_loggingDebugFsmVars(%definitionId&": Registering TC statHandler providers for statHandler "&vl_statName&
              " of traffic case "&pl_tc.uniqueName)
          }
          var integer vl_tableType := pl_tc.fsmList[pl_tc.statHandlerStatList[vl_i].siblingFsmIdx].fsmTypeIdx
          f_EPTF_LGenBase_registerStatHandlerProviders(
            v_LGenBase_fsmTables[vl_tableType].statisticListArray[c_EPTF_LGenBase_fsmObjectScopeTC][vl_i].providers,
            v_LGenBase_fsmTables[vl_tableType],
            vl_tableType,
            pl_tcIdx,
            vl_statName,
            c_EPTF_LGenBase_fsmObjectScopeTC,
            pl_tc.statHandlerStatList[vl_i].siblingFsmIdx)
        }
        
        //Set referred sibling indexes
        for ( var integer vl_sibling := 0; vl_sibling < sizeof(pl_tc.fsmList) ; vl_sibling := vl_sibling+1 ){
          for ( var integer vl_fsmRef := 0; vl_fsmRef < sizeof(v_LGenBase_fsmTables[pl_tc.fsmList[vl_sibling].fsmTypeIdx].referredFsmList) ; vl_fsmRef := vl_fsmRef+1 ){
            var charstring vl_flReferredSiblingName := v_LGenBase_fsmTables[pl_tc.fsmList[vl_sibling].fsmTypeIdx].referredFsmList[vl_fsmRef]
            var integer vl_referredSiblingIdx := -1
            for ( var integer vl_i := 0; vl_i < sizeof(pl_tc.fsmList) and vl_referredSiblingIdx == -1; vl_i := vl_i+1 ){
              if(vl_flReferredSiblingName == pl_tc.fsmList[vl_i].siblingName){
                vl_referredSiblingIdx := vl_i
              }
            }
            if(0 > vl_referredSiblingIdx){
              f_EPTF_LGenBase_loggingError(%definitionId&": There is no sibling FSM "&
                v_LGenBase_fsmTables[pl_tc.fsmList[vl_sibling].fsmTypeIdx].referredFsmList[vl_fsmRef]&
                " in the traffic case "&pl_tc.uniqueName&
                " in the FSM "&v_LGenBase_fsmTables[pl_tc.fsmList[vl_sibling].fsmTypeIdx].name);
            }
            pl_tc.referredFsmIdxsInSiblings[vl_sibling][vl_fsmRef] := vl_referredSiblingIdx
          }
          
          for ( var integer vl_siblingTC := 0; vl_siblingTC < sizeof(v_LGenBase_fsmTables[pl_tc.fsmList[vl_sibling].fsmTypeIdx].referredTCList) ; vl_siblingTC := vl_siblingTC+1 ){
            var charstring vl_flReferredTCName := v_LGenBase_fsmTables[pl_tc.fsmList[vl_sibling].fsmTypeIdx].referredTCList[vl_siblingTC];
            var integer vl_referredTCIdx := -1;
            
            //for ( var integer vl_idx := 0; vl_idx < sizeof(v_LGenBase_entityGroups[pl_tc.eGroupBackref].scenarios[pl_tc.eScenarioBackRef].tcIdxList) and vl_referredTCIdx == -1; vl_idx := vl_idx+1 ){
            for ( var integer vl_idx := 0; vl_idx < sizeof(v_LGenBase_scenarioTypes[pl_tc.eScenarioBackRef].tcList) and vl_referredTCIdx == -1; vl_idx := vl_idx+1 ){
              if (v_LGenBase_scenarioTypes[pl_tc.eScenarioBackRef].tcList[vl_idx].tcPrivateName == vl_flReferredTCName){
                vl_referredTCIdx := vl_idx;
              }
            }
            
            if(0 > vl_referredTCIdx){
              f_EPTF_LGenBase_loggingError(%definitionId&": There is no traffic case "&
                vl_flReferredTCName&
                " in the scenario "&v_LGenBase_entityGroups[pl_tc.eGroupBackref].scenarios[pl_tc.eScenarioBackRef].name&
                " in the FSM "&v_LGenBase_fsmTables[pl_tc.fsmList[vl_sibling].fsmTypeIdx].name);
            }
            pl_tc.referredTCIdxsInSiblings[vl_sibling][vl_siblingTC] := vl_referredTCIdx;
          }
        }
        
        pl_tc.fsmIdx := pl_tc.fsmList[0].fsmTypeIdx
        f_EPTF_LGenBase_deleteTCHashmaps(pl_tcIdx);
      }
      pl_tc.state := c_EPTF_LGenBase_tcStateIdle;
      f_EPTF_LGenBase_resetTcStats(pl_tcIdx, pl_tc);
    }
    
    friend function f_EPTF_LGenBase_createTCHashmaps(
      inout EPTF_LGenBase_TcDescriptor pl_tc )
    runs on EPTF_LGenBase_Private_CT
    {
      pl_tc.TCVarNamesHash := f_EPTF_str2int_HashMap_New(c_EPTF_LGenBase_tcVarsHashmapPrefix&pl_tc.uniqueName)
      pl_tc.SiblingFSMVarNamesHash := f_EPTF_str2int_HashMap_New(c_EPTF_LGenBase_siblingFsmVarsHashmapPrefix&pl_tc.uniqueName)
      pl_tc.FSMVarNamesHash := f_EPTF_str2int_HashMap_New(c_EPTF_LGenBase_fsmVarsHashmapPrefix&pl_tc.uniqueName)
      pl_tc.TCStatMeasNamesHash := f_EPTF_str2int_HashMap_New(c_EPTF_LGenBase_tcStatmeasHashmapPrefix&pl_tc.uniqueName)
      pl_tc.SiblingFSMStatMeasNamesHash := f_EPTF_str2int_HashMap_New(c_EPTF_LGenBase_siblingFsmStatmeasHashmapPrefix&pl_tc.uniqueName)
      pl_tc.FSMStatMeasNamesHash := f_EPTF_str2int_HashMap_New(c_EPTF_LGenBase_fsmStatmeasHashmapPrefix&pl_tc.uniqueName);
      pl_tc.TCStatHandlerNamesHash := f_EPTF_str2int_HashMap_New(c_EPTF_LGenBase_tcStatHandlerHashmapPrefix&pl_tc.uniqueName)
      pl_tc.SiblingFSMStatHandlerNamesHash := f_EPTF_str2int_HashMap_New(c_EPTF_LGenBase_siblingFsmStatHandlerHashmapPrefix&pl_tc.uniqueName)
      pl_tc.FSMStatHandlerNamesHash := f_EPTF_str2int_HashMap_New(c_EPTF_LGenBase_fsmStatHandlerHashmapPrefix&pl_tc.uniqueName);
    }
    
    friend function f_EPTF_LGenBase_deleteTCHashmaps(
      in integer pl_tcIdx )
    runs on EPTF_LGenBase_Private_CT
    {
      if(-1 < v_LGenBase_trafficCases[pl_tcIdx].TCVarNamesHash){
        f_EPTF_str2int_HashMap_Delete(c_EPTF_LGenBase_tcVarsHashmapPrefix&v_LGenBase_trafficCases[pl_tcIdx].uniqueName)
        v_LGenBase_trafficCases[pl_tcIdx].TCVarNamesHash := -1;
      }
      if(-1 < v_LGenBase_trafficCases[pl_tcIdx].SiblingFSMVarNamesHash){
        f_EPTF_str2int_HashMap_Delete(c_EPTF_LGenBase_siblingFsmVarsHashmapPrefix&v_LGenBase_trafficCases[pl_tcIdx].uniqueName)
        v_LGenBase_trafficCases[pl_tcIdx].SiblingFSMVarNamesHash := -1;
      }
      if(-1 < v_LGenBase_trafficCases[pl_tcIdx].FSMVarNamesHash){
        f_EPTF_str2int_HashMap_Delete(c_EPTF_LGenBase_fsmVarsHashmapPrefix&v_LGenBase_trafficCases[pl_tcIdx].uniqueName)
        v_LGenBase_trafficCases[pl_tcIdx].FSMVarNamesHash := -1;
      }
      if(-1 < v_LGenBase_trafficCases[pl_tcIdx].TCStatMeasNamesHash){
        f_EPTF_str2int_HashMap_Delete(c_EPTF_LGenBase_tcStatmeasHashmapPrefix&v_LGenBase_trafficCases[pl_tcIdx].uniqueName)
        v_LGenBase_trafficCases[pl_tcIdx].TCStatMeasNamesHash := -1;
      }
      if(-1 < v_LGenBase_trafficCases[pl_tcIdx].SiblingFSMStatMeasNamesHash){
        f_EPTF_str2int_HashMap_Delete(c_EPTF_LGenBase_siblingFsmStatmeasHashmapPrefix&v_LGenBase_trafficCases[pl_tcIdx].uniqueName)
        v_LGenBase_trafficCases[pl_tcIdx].SiblingFSMStatMeasNamesHash := -1;
      }
      if(-1 < v_LGenBase_trafficCases[pl_tcIdx].FSMStatMeasNamesHash){
        f_EPTF_str2int_HashMap_Delete(c_EPTF_LGenBase_fsmStatmeasHashmapPrefix&v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
        v_LGenBase_trafficCases[pl_tcIdx].FSMStatMeasNamesHash := -1;
      }
      if(-1 < v_LGenBase_trafficCases[pl_tcIdx].TCStatHandlerNamesHash){
        f_EPTF_str2int_HashMap_Delete(c_EPTF_LGenBase_tcStatHandlerHashmapPrefix&v_LGenBase_trafficCases[pl_tcIdx].uniqueName)
        v_LGenBase_trafficCases[pl_tcIdx].TCStatHandlerNamesHash := -1;
      }
      if(-1 < v_LGenBase_trafficCases[pl_tcIdx].SiblingFSMStatHandlerNamesHash){
        f_EPTF_str2int_HashMap_Delete(c_EPTF_LGenBase_siblingFsmStatHandlerHashmapPrefix&v_LGenBase_trafficCases[pl_tcIdx].uniqueName)
        v_LGenBase_trafficCases[pl_tcIdx].SiblingFSMStatHandlerNamesHash := -1;
      }
      if(-1 < v_LGenBase_trafficCases[pl_tcIdx].FSMStatHandlerNamesHash){
        f_EPTF_str2int_HashMap_Delete(c_EPTF_LGenBase_fsmStatHandlerHashmapPrefix&v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
        v_LGenBase_trafficCases[pl_tcIdx].FSMStatHandlerNamesHash := -1;
      }
    }
    
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_enableTrafficCaseInternal
    //
    //  Purpose:
    //    Enables a traffic case
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_enableTrafficCaseInternal(
      in integer pl_tcIdx,
      in boolean pl_start := true)
    runs on EPTF_LGenBase_Private_CT{
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Enable traffic case "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
      v_LGenBase_trafficCases[pl_tcIdx].enabled := true;
      if(pl_start ){
        f_EPTF_LGenBase_startLaunchTC(pl_tcIdx);
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_stopTcTimerInternal
    //
    //  Purpose:
    //    Cancels the periodic timer event of a traffic case if it's scheduled
    //
    //  Return Value:
    //    True if the traffic case had run before calling the function
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_stopTcTimerInternal(
      inout EPTF_LGenBase_TcDescriptor pl_tc
    )
    runs on EPTF_LGenBase_Private_CT
    return boolean{
      //Remove next timer event, if exists
      if(-1 != pl_tc.schedulingTimer){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": timer of tc "&pl_tc.uniqueName&" == "&int2str(pl_tc.schedulingTimer))
        if(not f_EPTF_SchedulerComp_CancelEvent(pl_tc.schedulingTimer)) {
          f_EPTF_LGenBase_loggingWarning(%definitionId&": cancelling timer failed.");
          return false;
        }
        pl_tc.schedulingTimer := -1;
        return true;
      }
      return true;
    }
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_stopScTimerInternal
    //
    //  Purpose:
    //    Cancels the periodic timer event of a scenario if it's scheduled
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_stopScTimerInternal(
      in integer pl_eGrpIdx,
      in integer pl_scInGrpIdx
    )
    runs on EPTF_LGenBase_Private_CT{
      //Remove next timer event, if exists
      if(-1 != v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData.schedulingTimer){
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": timer of  "&v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].uniqueName&
          " == "&log2str(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData.schedulingTimer))
        if(not f_EPTF_SchedulerComp_CancelEvent(
            v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData.schedulingTimer)) {
          f_EPTF_LGenBase_loggingWarning(%definitionId&" Cancelling timer failed.");
        }
        v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scInGrpIdx].schedulerData.schedulingTimer := -1;
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_disableTrafficCaseInternal
    //
    //  Purpose:
    //    Disables a traffic case
    //
    //  Detailed Comments:
    //    Also removes events in the event queu related to the traffic case,
    //    dispatches a <c_EPTF_LGenBase_inputIdx_testMgmt_trafficCaseStopped>
    //    generic event and checks launch finish conditions.
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_disableTrafficCaseInternal(
      in integer pl_tcIdx
    )
    runs on EPTF_LGenBase_Private_CT{
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Disable traffic case "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
      //Remove next timer event, if exists
      if(not f_EPTF_LGenBase_stopTcTimerInternal(v_LGenBase_trafficCases[pl_tcIdx])) {
        f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": Could not stop traffic case timer for traffic case "&
          v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
      }
      var boolean vn_enabled := v_LGenBase_trafficCases[pl_tcIdx].enabled;
      v_LGenBase_trafficCases[pl_tcIdx].enabled := false;
      if(c_EPTF_LGenBase_tcStateRunning == v_LGenBase_trafficCases[pl_tcIdx].state or
        c_EPTF_LGenBase_tcStatePaused == v_LGenBase_trafficCases[pl_tcIdx].state){
        //Stop if it was running //--enabled--
        //if(v_LGenBase_trafficCases[pl_tcIdx].enabled){
        f_EPTF_LGenBase_dispatchEvent({
            event := {
              bIdx := c_EPTF_LGenBase_bIdx,
              iIdx := c_EPTF_LGenBase_inputIdx_testMgmt_trafficCaseStopped,
              target := omit,
              source := omit
            },
            reportedArgs := {pl_tcIdx}
          });
        f_EPTF_LGenBase_tcStateChanged(pl_tcIdx);
        for ( var integer vl_i := 0; vl_i < sizeof(v_LGenBase_tcStartedOrStoppedCallbacks) ; vl_i := vl_i+1 )
        {
          v_LGenBase_tcStartedOrStoppedCallbacks[vl_i].apply( pl_tcIdx, false );
        }
      }else{
        var integer vl_eGrpIdx := v_LGenBase_trafficCases[pl_tcIdx].eGroupBackref;
        var integer vl_scIdx := v_LGenBase_trafficCases[pl_tcIdx].eScenarioBackRef;
        if(vn_enabled and f_EPTF_LGenBase_isWeightedScenario(vl_eGrpIdx, vl_scIdx))
        {
          var boolean vl_mixerAcceptsMix := f_EPTF_TrafficMixer_acceptNewTrafficMix(
            v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].trafficMixData,
            f_EPTF_LGenBase_getEnabledWeightListFromScenario(vl_eGrpIdx,vl_scIdx),
            v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].weightedScData.deterministicMix
          )
          f_EPTF_Base_assert(%definitionId&": initializing traffic mix for TC in weighted SC "&v_LGenBase_entityGroups[vl_eGrpIdx].scenarios[vl_scIdx].name& ": mixer has not accepted traffic mix",
            vl_mixerAcceptsMix);
        }
      }
      f_EPTF_LGenBase_checkLaunchFinished(pl_tcIdx);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_startEntityInternal
    //
    //  Purpose:
    //    Processes the start of an entity.
    //
    //  Parameters:
    //    pl_tcDesc - *in* <EPTF_LGenBase_TcDescriptor> - The appropriate tc descriptor in <v_LGenBase_trafficCases>.
    //    pl_tcIdx - *in* *integer* - The index of traffic case
    //    pl_eIdxInTC - *in* *integer* - The relative index of the entity
    //    pl_dispatchStartEvent - *in* *boolean* - Whether the c_EPTF_LGenBase_inputIdx_testMgmt_startTC
    //       event should be dispatched or not.
    //
    //  Return Value:
    //    Returns true if a group finish condition mutches.
    //
    //  Detailed Comments:
    //    Administers the start of an entity. If the pl_dispatchStartEvent == true,
    //    dispatches the c_EPTF_LGenBase_inputIdx_testMgmt_startTC
    //    FSM event and changes the statistics of the traffic case.
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_startEntityInternal(
      inout EPTF_LGenBase_TcDescriptor pl_tcDesc,
      in integer pl_tcIdx,
      in integer pl_eIdxInTC,
      in boolean pl_dispatchStartEvent,
      out EPTF_LGenBase_ConditionTrue pl_finished,
      in boolean pl_singleShotDebug := false,
      in integer pl_logBufferVar := -1
    )
    runs on EPTF_LGenBase_Private_CT
    return boolean
    {
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": pl_dispatchStartEvent == "&log2str(pl_dispatchStartEvent))
      pl_finished := c_EPTF_LGenBase_emptyConditionTrue
      var integer vl_eIdx := pl_tcDesc.entityInfo.itemList[pl_eIdxInTC].entityIdx;
      if(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.entitySelection == round_robin) {
        f_EPTF_FBQ_moveFromFreeToBusyTail(pl_eIdxInTC, pl_tcDesc.entityInfo.fbq);
      } else {
        if(not f_EPTF_RNA_moveFromFreeToBusySlot(pl_eIdxInTC, pl_tcDesc.entityInfo.rna)){
          f_EPTF_Base_assert(%definitionId&": Error in f_EPTF_RNA_moveFromFreeToBusySlot",false)
        }
      }
      //Statistics
      //We must set it before dispatching the start event, because during its process it could be counted
      pl_tcDesc.entityInfo.itemList[pl_eIdxInTC].nrOfStarts :=
      pl_tcDesc.entityInfo.itemList[pl_eIdxInTC].nrOfStarts + 1;
      pl_tcDesc.nrOfStarts := pl_tcDesc.nrOfStarts + 1;
      var integer vl_fsmIdx := f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc(pl_eIdxInTC,pl_tcIdx,0);
      Inc(pl_tcDesc.sentMsgs);
      Dec(pl_tcDesc.nrOfAvailableEntities);
      SetIfLt(pl_tcDesc.minAvailable, pl_tcDesc.nrOfAvailableEntities);
      if(v_LGenBase_trafficCases[pl_tcIdx].entityInfo.entitySelection == round_robin) {
        SetIfGt(pl_tcDesc.maxBusy,f_EPTF_FBQ_getLengthOfBusyChain(pl_tcDesc.entityInfo.fbq));
      } else {
        SetIfGt(pl_tcDesc.maxBusy,f_EPTF_RNA_getLengthOfBusyList(pl_tcDesc.entityInfo.rna));
      }
      Inc(pl_tcDesc.nrOfRunningEntities);
      SetIfGt(pl_tcDesc.maxRunning,pl_tcDesc.nrOfRunningEntities);
      var EPTF_IntegerList vl_trafficParam;
      f_EPTF_LGenBase_getNextRangeParam(pl_tcDesc, pl_tcIdx, vl_trafficParam);
      pl_tcDesc.entityInfo.itemList[pl_eIdxInTC].startTime := T_EPTF_componentClock.read
      pl_tcDesc.entityInfo.itemList[pl_eIdxInTC].isRunning := true
      if(pl_singleShotDebug){
        v_LGenBase_entities[vl_eIdx].fsmCtxList[vl_fsmIdx].singleShotDebugLog := true
        v_LGenBase_entities[vl_eIdx].fsmCtxList[vl_fsmIdx].singleShotLogBufferVariable := pl_logBufferVar
      }
      f_EPTF_LGenBaseStats_trafficStartedCallback( pl_tcIdx, vl_eIdx )
      for ( var integer vl_cb := 0; vl_cb < sizeof(v_LGenBase_trafficStarted_FTList) ; vl_cb := vl_cb+1 )
      {
        v_LGenBase_trafficStarted_FTList[vl_cb].apply( pl_tcIdx, vl_eIdx );
      }
            
      var integer vl_fsmCtxIdx := f_EPTF_LGenBase_getFSMCtxIdx(vl_eIdx, pl_tcIdx);
      f_EPTF_LGenBase_ILog_newChains( vl_eIdx, vl_fsmCtxIdx, 
        refers(f_EPTF_LGenBase_ILog_logHeaderDetailed),  {vl_eIdx, vl_fsmCtxIdx},
        refers(f_EPTF_LGenBase_ILog_logHeaderShort),  {vl_eIdx, vl_fsmCtxIdx});
      if(pl_dispatchStartEvent){
        //Dispatch start event to FSM
        var integer vl_targetFsmCtx := f_EPTF_LGenBase_fsmCtxIdxOfSiblingInTc(pl_eIdxInTC, pl_tcIdx,0);
        if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
          f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&
            log2str(": "
              ,"\nEntity#", vl_eIdx
              ,"\nsmIdx: ", pl_tcDesc.fsmIdx
              ,"\nTC: ",v_LGenBase_trafficCases[pl_tcIdx].uniqueName
              ,"\nFSM Ctx idx: ",vl_targetFsmCtx
              ,"\nParameter: ",vl_trafficParam))
        }
        var EPTF_LGenBase_ReportedEventDescriptor vl_startTcOfFsmEvent := c_EPTF_LGenBase_emptyReportedEventDescriptor;
        vl_startTcOfFsmEvent.event.bIdx := c_EPTF_LGenBase_bIdx;
        vl_startTcOfFsmEvent.event.iIdx := c_EPTF_LGenBase_inputIdx_testMgmt_startTC;
        vl_startTcOfFsmEvent.event.target := {
          eIdx := vl_eIdx,
          fsmCtxIdx := vl_targetFsmCtx
        };
        vl_startTcOfFsmEvent.reportedArgs := vl_trafficParam;
        f_EPTF_LGenBase_dispatchEvent(vl_startTcOfFsmEvent);
      }
      if(ispresent(pl_tcDesc.trafficStartFinishConditionsAndActions.nrOfExecStart) and
        v_LGenBase_groupFinishConditionMask.nrOfExecStart and
        pl_tcDesc.trafficStartFinishConditionsAndActions.nrOfExecStart.count <= pl_tcDesc.nrOfStarts){
        pl_finished.nrOfExecStart := true;
        pl_finished.anythingFinished := true;
      }
      if( ispresent(pl_tcDesc.trafficStartFinishConditionsAndActions.nrOfRangeLoop) and
        v_LGenBase_groupFinishConditionMask.nrOfRangeLoop and
        pl_tcDesc.trafficStartFinishConditionsAndActions.nrOfRangeLoop.count <= pl_tcDesc.rangeLoops){
        pl_finished.nrOfRangeLoop := true;
        pl_finished.anythingFinished := true;
      }
            
      return pl_finished.anythingFinished;
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_processStartStep
    //
    //  Purpose:
    //    Internal function to execute the <f_EPTF_LGenBase_startEntityInternal> function from the
    //    <f_EPTF_LGenBase_step_recordEntityStart> or
    //    <f_EPTF_LGenBase_step_startEntity> functions.
    //
    //  Parameters:
    //    pl_ptr - *in* - *EPTF_LGenBase_TestStepArgs* - step arguments
    //    pl_dispatchStartEvent - *in* *boolean* - Whether the c_EPTF_LGenBase_inputIdx_testMgmt_startTC
    //       event should be dispatched or not.
    //
    //  Return Value:
    //    Returns false if the entity is busy
    ///////////////////////////////////////////////////////////
    friend function f_EPTF_LGenBase_processStartStep(
      in EPTF_LGenBase_TestStepArgs pl_ptr,
      in boolean pl_dispatchStartEvent
    )
    runs on EPTF_LGenBase_Private_CT
    return boolean
    {
      var integer vl_entityIdx := pl_ptr.eIdx;
      var integer vl_tcIdx := f_EPTF_LGenBase_tcIdxOfStep(pl_ptr);
      var integer vl_entityInTcFBQIdx := vl_entityIdx - v_LGenBase_entityGroups[v_LGenBase_trafficCases[vl_tcIdx].eGroupBackref].eOffset
      return f_EPTF_LGenBase_doStartStep(vl_entityInTcFBQIdx, vl_tcIdx, pl_dispatchStartEvent);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_doStartStep
    //
    //  Purpose:
    //    Starts a traffic on the entity of a traffic case
    //
    //  Return Value:
    //    Returns false if the entity is busy
    //
    //  Detailed Comments:
    //    Calls the <f_EPTF_LGenBase_startEntityInternal> function
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBase_doStartStep(
      in integer pl_eRelIdx,
      in integer pl_tcIdx,
      in boolean pl_dispatchStartEvent,
      in boolean pl_singleShotDebug := false,
      in integer pl_logBufferVar := -1
    )
    runs on EPTF_LGenBase_Private_CT
    return boolean
    {
      if (c_EPTF_Common_debugSwitch and f_EPTF_LGenBase_isEnabled(c_EPTF_LGenBase_loggingClassIdx_DebugTraffic)){
        f_EPTF_LGenBase_loggingDebugTraffic(log2str("eRelIdx == ",pl_eRelIdx))
        f_EPTF_LGenBase_loggingDebugTraffic("tc == "&v_LGenBase_trafficCases[pl_tcIdx].uniqueName);
      }
      if(not f_EPTF_LGenBase_entityIsBusy(pl_eRelIdx, pl_tcIdx)){
        if(f_EPTF_LGenBase_startEntityInternal(
            v_LGenBase_trafficCases[pl_tcIdx],
            pl_tcIdx,
            pl_eRelIdx,
            pl_dispatchStartEvent,
            v_LGenBase_tempFinishedRec,
            pl_singleShotDebug,
            pl_logBufferVar)){
          f_EPTF_LGenBase_groupFinishedDetected(pl_tcIdx, v_LGenBase_tempFinishedRec);
        }
      }else{
        f_EPTF_LGenBase_loggingWarning(%definitionId&": StartStep called but entiy#"&int2str(pl_eRelIdx)&" in traffic case "&
          v_LGenBase_trafficCases[pl_tcIdx].uniqueName&" ("&int2str(pl_tcIdx)&") is busy!")
        return false;
      }
      return true;
    }
    
  }//PrivateStartStopInit
  
  ///////////////////////////////////////////////////////////
  //  function: f_EPTF_LGenBase_setGroupFinishedPerConditionFn
  // 
  //  Purpose:
  //    Convenient function for the <ExecCtrl>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setGroupFinishedPerConditionFn(
    in EPTF_LGenBase_groupFinishedPerCondition_FT pl_fn
  )
  runs on EPTF_LGenBase_Private_CT
  return EPTF_LGenBase_groupFinishedPerCondition_FT{
    var EPTF_LGenBase_groupFinishedPerCondition_FT vl_retVal := v_LGenBase_groupFinishedPerConditionFn
    v_LGenBase_groupFinishedPerConditionFn := pl_fn
    return vl_retVal
  }
  
  ///////////////////////////////////////////////////////////
  //  function: f_EPTF_LGenBase_setGroupFinishedPerConditionFn
  // 
  //  Purpose:
  //    Convenient function for the <ExecCtrl>
  ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_setGroupFinishedFn(
    in EPTF_LGenBase_groupFinished_FT pl_fn
  )
  runs on EPTF_LGenBase_Private_CT
  return EPTF_LGenBase_groupFinished_FT{
    var EPTF_LGenBase_groupFinished_FT vl_retVal := v_LGenBase_groupFinishedFn
    v_LGenBase_groupFinishedFn := pl_fn
    return vl_retVal
  }
}//PrivateFunctions
///////////////////////////////////////////////////////////
//  Group: PrivateFunctions
// 
//  Purpose:
//    The private functions of the EPTF_LGenBaseStats feature
//    Don't use them from outside of EPTF_LGenBaseStats
//
///////////////////////////////////////////////////////////
group PrivateStatsFunctions{
  
  ///////////////////////////////////////////////////////////
  //  Group: LGenBase_specific
  // 
  //  Purpose:
  //    Functions to retrive/convert/calculate values from the component
  //    variables of the LGenBase
  ///////////////////////////////////////////////////////////
  group LGenBase_specific{
    
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBaseStats_createStatVarsOfTC
    // 
    //  Purpose:
    //    Creates the statistical variables of a TC
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBaseStats_createStatVarsOfTC(
      inout EPTF_LGenBase_TcDescriptor pl_tc,
      in charstring pl_eGrpName,
      in charstring pl_scName,
      in integer pl_tcIdx
    )
    runs on EPTF_LGenBase_Private_CT {
      f_EPTF_Base_assert(%definitionId&": "&"Invalid traffic case index: "&int2str(pl_tcIdx),pl_tcIdx == sizeof(v_LGenBaseStats_trafficCases));
      v_LGenBaseStats_trafficCases[sizeof(v_LGenBaseStats_trafficCases)] := c_EPTF_LGenBaseStats_emptyTcDescriptor
      var charstring vl_tcName := pl_tc.privateName;
      f_EPTF_Base_assert(%definitionId&": "&"Traffic case name "&vl_tcName&
        " contains the separator "&tsp_LGenBase_nameSeparator,
        f_EPTF_LGenBase_checkName(vl_tcName));
      var charstring vl_varNameBase := f_EPTF_LGenBase_getNamePrefix(pl_eGrpName,pl_scName,pl_tc.privateName);
      var integer vl_temp := 0;
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcNrOfStarts, pl_tc.nrOfStarts, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcNrOfStarts := vl_temp;
      
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcNrOfSuccesses, pl_tc.nrOfSuccesses, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcNrOfSuccesses := vl_temp
      
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcNrOfFails, pl_tc.nrOfFails, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcNrOfFails := vl_temp
      
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcNrOfErrors, pl_tc.nrOfErrors, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcNrOfErrors := vl_temp
      
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcNrOfTimeouts, pl_tc.nrOfTimeouts, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcNrOfTimeouts := vl_temp
      
      f_EPTF_Var_newInt(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcNrOfAllEntities, pl_tc.nrOfAllEntities, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcNrOfAllEntities := vl_temp
      
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcNrOfRunningEntities, pl_tc.nrOfRunningEntities, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcNrOfRunningEntities := vl_temp
      
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcNrOfAvailableEntities, pl_tc.nrOfAvailableEntities, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcNrOfAvailableEntities := vl_temp
      
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcMinAvailable, pl_tc.minAvailable, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcMinAvailable := vl_temp
      
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcMaxRunning,pl_tc.maxRunning, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcMaxRunning := vl_temp
      
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcMaxBusy,pl_tc.maxBusy, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcMaxBusy := vl_temp
      
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcNrOfNotFinishedEntities, pl_tc.nrOfNotFinishedEntities, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcNrOfNotFinishedEntities := vl_temp
      
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcState, pl_tc.state, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcState := vl_temp
      
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcSentMessages, pl_tc.sentMsgs, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcSentMessages := vl_temp
      
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcReceivedAnswers, pl_tc.receivedAnswers, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcReceivedAnswers := vl_temp
      
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcRangeLoops, pl_tc.rangeLoops, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcRangeLoops := vl_temp
      
      if(f_EPTF_LGenBase_isWeightedScenario(pl_tc.eGroupBackref, pl_tc.eScenarioBackRef)){
        f_EPTF_Var_newFloatRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcWeight, pl_tc.schedulerData.target.trafficWeight, vl_temp);
        f_EPTF_Var_addPostProcFn(vl_temp, {refers(f_EPTF_LGenBaseStats_tcWeightChanged),{pl_tcIdx}});
        f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_floatPositiveOrZeroGuard),{}});
        v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcWeight := vl_temp
        
        f_EPTF_Var_newFloat(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcCpsToReach, 0.0, vl_temp);
        f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
        v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcCpsToReach := vl_temp
      }else{
        f_EPTF_Var_newFloatRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcCpsToReach, pl_tc.schedulerData.target.cpsToReach, vl_temp);
        f_EPTF_Var_addPostProcFn(vl_temp, {refers(f_EPTF_LGenBaseStats_tcCpsChanged),{pl_tcIdx}});
        f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_floatPositiveOrZeroGuard),{}});
        v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcCpsToReach := vl_temp
        
        f_EPTF_Var_newFloat(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcWeight, 0.0, vl_temp);
        f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
        v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcWeight := vl_temp
      }
      f_EPTF_Var_newFloat(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcLastCps, 0.0, vl_temp);
      //f_EPTF_Var_subscribeLocal(vl_temp, {{refers(f_EPTF_LGenBaseStats_calcCPSSubs),{},{pl_tcIdx}}});
      v_LGenBaseStats_lastCpsVarList[pl_tcIdx] := vl_temp;
      //v_LGenBaseStats_lastCPSCalcTimeList[pl_tcIdx] := 0.0;
      //f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      //f_EPTF_Var_newInt(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcLastCalls, 0.0, vl_temp);
      v_LGenBaseStats_lastCallsList[pl_tcIdx] := 0;
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcLastCps := vl_temp
      
      //f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      f_EPTF_Var_newCharstringRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcUserData, pl_tc.userData, vl_temp);
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcUserData := vl_temp
      
      f_EPTF_Var_newCharstring(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcName, pl_tc.privateName, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcName := vl_temp
      
      f_EPTF_Var_newCharstring(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcUniqueName, pl_tc.uniqueName, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcUniqueName := vl_temp
      
      f_EPTF_Var_newBoolRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcEnabled, pl_tc.enabled, vl_temp);
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcEnabled := vl_temp
      
      //f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      f_EPTF_Var_newCharstring(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcStateName, "", vl_temp);
      f_EPTF_Var_subscribeLocal(vl_temp, {{refers(f_EPTF_LGenBaseStats_tcStateName),{},{pl_tcIdx}}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcStateName := vl_temp
      
      f_EPTF_Var_newCharstring(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcTrafficType, 
        c_EPTF_LGenBase_trafficTypeNames[enum2int(v_LGenBase_trafficCases[pl_tcIdx].trafficType)],
        vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      v_LGenBaseStats_trafficCases[pl_tcIdx].varIdxOfTcTrafficType := vl_temp
      
      f_EPTF_Var_newBool(vl_varNameBase& c_LGenBase_dataElementTcEnabledAtStartup, pl_tc.enabledAtStartup, vl_temp);
      f_EPTF_Var_addSyncCallBackFn(refers(f_EPTF_LGenBaseStats_EnabledUpdate), {pl_tcIdx, vl_temp});
      f_EPTF_Var_addPostProcFn(vl_temp,{refers(f_EPTF_LGenBaseStats_EnabledCallback), {pl_tcIdx, vl_temp} });
    }  
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBaseStats_createScenarioVars
    // 
    //  Purpose:
    //    Creates the statistical variables of a scenario. 
    //    Calls the <f_EPTF_LGenBaseStats_createStatVarsOfTC>
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBaseStats_createScenarioVars(
      in integer pl_eGrpIdx,
      in integer pl_scIdx
    )
    runs on EPTF_LGenBase_Private_CT {
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": "&v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].uniqueName);
      var integer vl_tcCount := sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList);
      var charstring vl_eGrpName := v_LGenBase_entityGroups[pl_eGrpIdx].name;
      f_EPTF_Base_assert(%definitionId&": "&"Entity group name "&vl_eGrpName&" contains the separator "&
        tsp_LGenBase_nameSeparator,
        f_EPTF_LGenBase_checkName(vl_eGrpName)); 
      var charstring vl_scName := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].name;
      f_EPTF_Base_assert(%definitionId&": Scenario name "&vl_scName&
        " contains the separator "&tsp_LGenBase_nameSeparator,
        f_EPTF_LGenBase_checkName(vl_scName));
      var charstring vl_varNameBase := f_EPTF_LGenBase_getScNamePrefix(vl_eGrpName,vl_scName);
      var integer vl_temp;
      f_EPTF_Var_newCharstring(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfScName, v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].uniqueName, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      
      f_EPTF_Var_newIntRef(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfScState, v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].state, vl_temp);
      f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      
      f_EPTF_Var_newBoolRef(
        vl_varNameBase&c_EPTF_LGenBaseStats_nameOfScEnabled, 
        v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].enabled, 
        vl_temp);
      f_EPTF_Var_newCharstring(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfScStateName, "", vl_temp);
      f_EPTF_Var_subscribeLocal(vl_temp, {{refers(f_EPTF_LGenBaseStats_scStateName),{},{pl_eGrpIdx, pl_scIdx}}});
      
      f_EPTF_Var_newCharstring(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcTrafficType, "", vl_temp);
      f_EPTF_Var_subscribeLocal(vl_temp, {{refers(f_EPTF_LGenBaseStats_scTrafficType),{},{pl_eGrpIdx, pl_scIdx}}});
      
      if(f_EPTF_LGenBase_isWeightedScenario(pl_eGrpIdx, pl_scIdx)){
        f_EPTF_Var_newFloatRef(
          vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcCpsToReach, 
          v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].schedulerData.target.cpsToReach, 
          vl_temp);
        f_EPTF_Var_addPostProcFn(vl_temp, {refers(f_EPTF_LGenBaseStats_scCpsChanged),{pl_eGrpIdx, pl_scIdx}});
        f_EPTF_Var_addGuardFn(vl_temp, {refers(f_EPTF_LGenBaseStats_floatPositiveOrZeroGuard),{}});
        f_EPTF_Var_newBoolRef(
          vl_varNameBase&c_EPTF_LGenBaseStats_nameOfScLockCPS, 
          v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].lockCPS, 
          vl_temp);
      }else{
        f_EPTF_Var_newFloat(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcCpsToReach, 0.0, vl_temp);
        f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
        f_EPTF_Var_newBool( vl_varNameBase&c_EPTF_LGenBaseStats_nameOfScLockCPS, false, vl_temp); 
        f_EPTF_Var_addGuardFn( vl_temp, {refers(f_EPTF_LGenBaseStats_readOnlyGuard),{}});
      }
      for ( var integer vl_i := 0; vl_i < vl_tcCount ; vl_i := vl_i+1 )
      {
        var integer vl_tcIdx := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].tcIdxList[vl_i];
        f_EPTF_LGenBaseStats_createStatVarsOfTC(
          v_LGenBase_trafficCases[vl_tcIdx], 
          vl_eGrpName, 
          vl_scName,
          vl_tcIdx);
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBaseStats_createScenarioVarsOfEG
    // 
    //  Purpose:
    //    Creates the statistical variables of the scenarios of an entity group. 
    //    Calls the <f_EPTF_LGenBaseStats_createScenarioVars>
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBaseStats_createScenarioVarsOfEG(
      in integer pl_eGrpIdx
    )
    runs on EPTF_LGenBase_Private_CT {
      for ( var integer vl_scIdx := 0; vl_scIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios) ; vl_scIdx := vl_scIdx+1 )
      {
        f_EPTF_LGenBaseStats_createScenarioVars(pl_eGrpIdx, vl_scIdx)
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBaseStats_tcWeightChanged
    // 
    //  Purpose:
    //    Postproc function when a weight of a TC changed
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBaseStats_tcWeightChanged(
      in integer pl_idx, 
      in EPTF_IntegerList pl_argList) 
    runs on EPTF_LGenBase_Private_CT {
      var EPTF_Var_DirectContent vl_currentContent;
      f_EPTF_Var_getContent(pl_idx,vl_currentContent);
      v_LGenBase_dummyFloat := f_EPTF_LGenBase_setTcWeight(pl_argList[0],vl_currentContent.floatVal);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBaseStats_scWeightChanged
    // 
    //  Purpose:
    //    Postproc function when a weight of a scenario changed
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBaseStats_scWeightChanged(
      in integer pl_idx, 
      in EPTF_IntegerList pl_argList) 
    runs on EPTF_LGenBase_Private_CT {
      var EPTF_Var_DirectContent vl_currentContent;
      f_EPTF_Var_getContent(pl_idx,vl_currentContent);
      v_LGenBase_dummyFloat := f_EPTF_LGenBase_setScenarioCPSByIdx(pl_argList[0],pl_argList[1],vl_currentContent.floatVal);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBaseStats_tcCpsChanged
    // 
    //  Purpose:
    //    Postproc function when a CPS of a TC changed
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBaseStats_tcCpsChanged(
      in integer pl_idx, 
      in EPTF_IntegerList pl_argList) 
    runs on EPTF_LGenBase_Private_CT {
      f_EPTF_LGenBase_loggingDebugTraffic(%definitionId&": "&v_LGenBase_trafficCases[pl_argList[0]].uniqueName&" schedulingTimer == "&log2str(v_LGenBase_trafficCases[pl_argList[0]].schedulingTimer));
      var EPTF_Var_DirectContent vl_Content
      f_EPTF_Var_getContent(pl_idx, vl_Content)
      v_LGenBase_dummyFloat := f_EPTF_LGenBase_setCPS(pl_argList[0], vl_Content.floatVal)
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBaseStats_scCpsChanged
    // 
    //  Purpose:
    //    Postproc function when a CPS of a scenario changed
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBaseStats_scCpsChanged(
      in integer pl_idx, 
      in EPTF_IntegerList pl_argList) 
    runs on EPTF_LGenBase_Private_CT {
      if( not v_LGenBase_initialized ) {
        return;
      }
      var EPTF_Var_DirectContent vl_currentContent;
      f_EPTF_Var_getContent(pl_idx,vl_currentContent);
      v_LGenBase_dummyFloat := f_EPTF_LGenBase_setScenarioCPSByIdx(pl_argList[0], pl_argList[1], vl_currentContent.floatVal, true);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBaseStats_tcStateName
    // 
    //  Purpose:
    //    Returns the text format of the state of the specified TC
    // 
    //  Detailed Comments:
    //    Calc function
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBaseStats_tcStateName(
      in integer pl_idx, 
      in EPTF_IntegerList pl_argList, 
      in EPTF_IntegerList pl_nonVarArgList, 
      inout EPTF_Var_DirectContent pl_retVal) 
    runs on EPTF_LGenBase_Private_CT {
      if( not v_LGenBase_initialized ) {
        pl_retVal.charstringVal:="";
        return;
      }
      pl_retVal.charstringVal := c_EPTF_LGenBase_stateNames[v_LGenBase_trafficCases[pl_nonVarArgList[0]].state];
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBaseStats_scStateName
    // 
    //  Purpose:
    //    Returns the text format of the state of the specified scenario
    // 
    //  Detailed Comments:
    //    Calc function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBaseStats_scStateName(
      in integer pl_idx, 
      in EPTF_IntegerList pl_argList, 
      in EPTF_IntegerList pl_nonVarArgList, 
      inout EPTF_Var_DirectContent pl_retVal) 
    runs on EPTF_LGenBase_Private_CT {
      if( not v_LGenBase_initialized ) {
        pl_retVal.charstringVal:="";
        return;
      }
      pl_retVal.charstringVal := c_EPTF_LGenBase_stateNames[v_LGenBase_entityGroups[pl_nonVarArgList[0]].scenarios[pl_nonVarArgList[1]].state];
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBaseStats_tcTrafficType
    // 
    //  Purpose:
    //    Returns the text format of the traffic type of the specified TC
    // 
    //  Detailed Comments:
    //    Calc function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBaseStats_tcTrafficType(
      in integer pl_idx, 
      in EPTF_IntegerList pl_argList, 
      in EPTF_IntegerList pl_nonVarArgList, 
      inout EPTF_Var_DirectContent pl_retVal) 
    runs on EPTF_LGenBase_Private_CT {
      if( not v_LGenBase_initialized ) {
        pl_retVal.charstringVal:="";
        return;
      }
      pl_retVal.charstringVal := c_EPTF_LGenBase_trafficTypeNames[enum2int(v_LGenBase_trafficCases[pl_nonVarArgList[0]].trafficType)];
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBaseStats_scTrafficType
    // 
    //  Purpose:
    //    Returns the text format of the traffic type of the specified SC
    // 
    //  Detailed Comments:
    //    Calc function
    ///////////////////////////////////////////////////////////
    public function f_EPTF_LGenBaseStats_scTrafficType(
      in integer pl_idx, 
      in EPTF_IntegerList pl_argList, 
      in EPTF_IntegerList pl_nonVarArgList, 
      inout EPTF_Var_DirectContent pl_retVal) 
    runs on EPTF_LGenBase_Private_CT {
      if( not v_LGenBase_initialized ) {
        pl_retVal.charstringVal:="";
        return;
      }
      pl_retVal.charstringVal := c_EPTF_LGenBase_trafficTypeNames[enum2int(v_LGenBase_entityGroups[pl_nonVarArgList[0]].scenarios[pl_nonVarArgList[1]].trafficType)];
    }
    
  }//LGenBase_specific
  
  ///////////////////////////////////////////////////////////
  //  Group: Callbacks
  // 
  //  Purpose:
  //    Callback functions registered in the LGenBase
  ///////////////////////////////////////////////////////////
  group Callbacks{
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBaseStats_scenarioStateChangedCallback
    // 
    //  Purpose:
    //    The function is called when the state of a scenario has changed
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBaseStats_scenarioStateChangedCallback(
      in integer pl_eGrpIdx, 
      in integer pl_scIdx)
    runs on EPTF_LGenBase_Private_CT {
      var charstring vl_eGrpName := v_LGenBase_entityGroups[pl_eGrpIdx].name;
      var charstring vl_scName := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[pl_scIdx].name;
      var charstring vl_varNameBase := f_EPTF_LGenBase_getScNamePrefix(vl_eGrpName,vl_scName);
      var integer vl_varId := f_EPTF_Var_getId(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfScState);
      f_EPTF_Base_assert(%definitionId&": Invalid variable name "&vl_varNameBase&c_EPTF_LGenBaseStats_nameOfScState, -1 < vl_varId);
      f_EPTF_Var_refreshContent(vl_varId);
      vl_varId := f_EPTF_Var_getId(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfScStateName);
      f_EPTF_Base_assert(%definitionId&": Invalid variable name "&vl_varNameBase&c_EPTF_LGenBaseStats_nameOfScStateName, -1 < vl_varId);
      f_EPTF_Var_refreshContent(vl_varId);
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBaseStats_tcStateChangedCallback
    // 
    //  Purpose:
    //    The function is called when a TC has been started
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBaseStats_tcStateChangedCallback(
      in integer pl_tcIdx)
    runs on EPTF_LGenBase_Private_CT {
      var charstring vl_eGrpName;
      var charstring vl_scName;
      var charstring vl_tcName;
      f_EPTF_LGenBase_trafficCaseIdNames(pl_tcIdx, vl_eGrpName, vl_scName, vl_tcName);
      var charstring vl_varNameBase := f_EPTF_LGenBase_getNamePrefix(vl_eGrpName, vl_scName, vl_tcName);
      var integer vl_varId := f_EPTF_Var_getId(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcState);
      f_EPTF_Base_assert(%definitionId&": Invalid variable name "&vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcState, -1 < vl_varId);
      f_EPTF_Var_refreshContent(vl_varId);
      vl_varId := f_EPTF_Var_getId(vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcStateName);
      f_EPTF_Base_assert(%definitionId&": Invalid variable name "&vl_varNameBase&c_EPTF_LGenBaseStats_nameOfTcStateName, -1 < vl_varId);
      f_EPTF_Var_refreshContent(vl_varId);
    }
    
    group trafficStatistics{
      
      private function f_EPTF_LGenBaseStats_trafficSucces(
        in integer pl_tcAbsIdx)
      runs on EPTF_LGenBase_Private_CT {
        f_EPTF_Var_refreshContent(v_LGenBaseStats_trafficCases[pl_tcAbsIdx].varIdxOfTcNrOfSuccesses)
        f_EPTF_Var_refreshContent(v_LGenBaseStats_trafficCases[pl_tcAbsIdx].varIdxOfTcNrOfRunningEntities)
      }
      private function f_EPTF_LGenBaseStats_trafficFail(
        in integer pl_tcAbsIdx)
      runs on EPTF_LGenBase_Private_CT {
        f_EPTF_Var_refreshContent(v_LGenBaseStats_trafficCases[pl_tcAbsIdx].varIdxOfTcNrOfFails)
        f_EPTF_Var_refreshContent(v_LGenBaseStats_trafficCases[pl_tcAbsIdx].varIdxOfTcNrOfRunningEntities)
      }
      private function f_EPTF_LGenBaseStats_trafficError(
        in integer pl_tcAbsIdx)
      runs on EPTF_LGenBase_Private_CT {
        f_EPTF_Var_refreshContent(v_LGenBaseStats_trafficCases[pl_tcAbsIdx].varIdxOfTcNrOfErrors)
        f_EPTF_Var_refreshContent(v_LGenBaseStats_trafficCases[pl_tcAbsIdx].varIdxOfTcNrOfRunningEntities)
      }
      private function f_EPTF_LGenBaseStats_trafficTimeout(
        in integer pl_tcAbsIdx)
      runs on EPTF_LGenBase_Private_CT {
        f_EPTF_Var_refreshContent(v_LGenBaseStats_trafficCases[pl_tcAbsIdx].varIdxOfTcNrOfTimeouts)
        f_EPTF_Var_refreshContent(v_LGenBaseStats_trafficCases[pl_tcAbsIdx].varIdxOfTcNrOfRunningEntities)
      }
      ///////////////////////////////////////////////////////////
      //  Function: f_EPTF_LGenBaseStats_trafficStartedCallback
      // 
      //  Purpose:
      //    The function is called when a traffic has been started on an entity
      ///////////////////////////////////////////////////////////
      private function f_EPTF_LGenBaseStats_trafficStartedCallback(in integer pl_tcAbsIdx, in integer pl_eAbsIdx)
      runs on EPTF_LGenBase_Private_CT {
        v_LGenBaseStats_lastCallsList[pl_tcAbsIdx] := v_LGenBaseStats_lastCallsList[pl_tcAbsIdx] + 1;
        f_EPTF_Var_refreshContent(v_LGenBaseStats_trafficCases[pl_tcAbsIdx].varIdxOfTcNrOfStarts)
      }
    }  
  }//Callbacks
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBaseStats_calcCPSListAction
  // 
  //  Purpose:
  //    Calculates the CPS
  // 
  //  Detailed Comments:
  //    The function is registered as a scheduler action. Wrapper function for the f_EPTF_LGenBaseStats_calcCPS
  ///////////////////////////////////////////////////////////
  friend function f_EPTF_LGenBaseStats_calcCPSListAction(
    in EPTF_ScheduledAction pl_action, 
    in integer pl_eventIndex) 
  runs on EPTF_LGenBase_Private_CT
  return boolean{
    var integer vl_count := sizeof(v_LGenBaseStats_lastCallsList);
    var float vl_currentTime := f_EPTF_SchedulerComp_snapshotTime();
    var float vl_interval := vl_currentTime - v_LGenBaseStats_lastCPSCalcTime;
    for ( var integer vl_i := 0; vl_i < vl_count ; vl_i := vl_i+1 )
    {
      if(isbound(v_LGenBaseStats_lastCallsList[vl_i])){
        f_EPTF_LGenBaseStats_calcCPS(vl_i, vl_interval)
        v_LGenBaseStats_lastCallsList[vl_i]:=0;
      }
    }
    v_LGenBaseStats_lastCPSCalcTime := vl_currentTime;
    if(not f_EPTF_SchedulerComp_scheduleAction(
        pl_action.when + tsp_LGenBaseStats_CPSCalc,
        refers(f_EPTF_LGenBaseStats_calcCPSListAction),
        {},
        v_LGenBaseStats_CPSCalcTimer
      )) {
      f_EPTF_LGenBase_loggingError(%definitionId& ": Could not start CPS calculation timer.");
    }
    return true;
  }
  
  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_LGenBaseStats_calcCPS
  // 
  //  Purpose:
  //    Calculates the CPS
  ///////////////////////////////////////////////////////////
  private function f_EPTF_LGenBaseStats_calcCPS(
    in integer pl_tcAbsIdx,
    in float pl_interval) 
  runs on EPTF_LGenBase_Private_CT
  {
    var EPTF_Var_DirectContent vl_retVal;
    if(0.0 == pl_interval){
      vl_retVal.floatVal := 0.0;
    }else{
      vl_retVal.floatVal := int2float(v_LGenBaseStats_lastCallsList[pl_tcAbsIdx])/pl_interval;
    }
    f_EPTF_Var_adjustContent(v_LGenBaseStats_lastCpsVarList[pl_tcAbsIdx], vl_retVal);
  }
  
  ///////////////////////////////////////////////////////////
  //  Group: Guards
  // 
  //  Purpose:
  //    Guard functions
  ///////////////////////////////////////////////////////////
  group Guards{
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBaseStats_readOnlyGuard
    // 
    //  Purpose:
    //    Makes the EPTF Var readonly
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBaseStats_readOnlyGuard(
      in integer pl_idx, 
      in EPTF_IntegerList pl_argList, 
      in EPTF_Var_DirectContent pl_newContent) 
    runs on EPTF_LGenBase_Private_CT 
    return boolean{
      return false;
    }
    
    private function f_EPTF_LGenBaseStats_EnabledCallback(in integer pl_idx, in EPTF_IntegerList pl_argList) 
      runs on EPTF_LGenBase_Private_CT { //Set also the enabled flag it ensures to have effect also before and during test execution
      if( not v_LGenBase_initialized ) {
        return;
      }
      var integer vl_tcId := pl_argList[0];
      var integer vl_varId := pl_argList[1];
      var EPTF_Var_DirectContent vl_content;
      f_EPTF_Var_getContent(vl_varId, vl_content)
      v_LGenBase_trafficCases[pl_argList[0]].enabledAtStartup := vl_content.boolVal;
    }
    
    private function f_EPTF_LGenBaseStats_EnabledUpdate(in EPTF_IntegerList pl_argList) 
      runs on EPTF_LGenBase_Private_CT {
      if( not v_LGenBase_initialized ) {
        return;
      }
      var integer vl_tcId := pl_argList[0];
      var integer vl_varId := pl_argList[1];
      var EPTF_Var_DirectContent vl_content := {boolVal := v_LGenBase_trafficCases[vl_tcId].enabledAtStartup};
      if(f_EPTF_Var_getBoolValue(vl_varId) != vl_content.boolVal) {
        f_EPTF_Var_adjustContent(vl_varId, vl_content);
      }
    }
    
    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBaseStats_floatPositiveOrZeroGuard
    // 
    //  Purpose:
    //    Allows only positive numbers or 0
    ///////////////////////////////////////////////////////////
    private function f_EPTF_LGenBaseStats_floatPositiveOrZeroGuard(
      in integer pl_idx, 
      in EPTF_IntegerList pl_argList, 
      in EPTF_Var_DirectContent pl_newContent) 
    runs on EPTF_LGenBase_Private_CT 
    return boolean{
      if(not ischosen(pl_newContent.floatVal)) { return false; }
      if(pl_newContent.floatVal < 0.0) { return false; }
      return true;
    }
  }
  
}//PrivateStatsFunctions  

group LimitedExecution
{

    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_limitExecution
    //
    //  Purpose:
    //    Limits the number of entities in the EntityGroup in order to limit execution to help testing and troubleshooting
    //
    //  Parameters:
    //    pl_eGrpIdx - *in* - *integer* - entityGroup identifier
    //    pl_eLimit  - *in* - *integer* - entity limit size : from 0 to chosen entityGroup size -1 it limits the execution, if negative = unlimit the group
    //
    //  Return Value:
    //    -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //
    ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_limitExecution(
      in integer pl_eGrpIdx,
      in integer pl_eLimit) 
    runs on EPTF_LGenBase_Private_CT 
    {
      if(( v_LGenBase_entityGroups[pl_eGrpIdx].isLimited == false and v_LGenBase_entityGroups[pl_eGrpIdx].eCount < pl_eLimit ) or
        ( v_LGenBase_entityGroups[pl_eGrpIdx].isLimited == true and v_LGenBase_entityGroups[pl_eGrpIdx].origECount < pl_eLimit )) {
        f_EPTF_LGenBase_loggingError(%definitionId&" Error : Limit is greater than all the number of entities in the given entity group!");
        return;
      }

      if(pl_eLimit < 0){
        f_EPTF_LGenBase_unLimitExecution(pl_eGrpIdx);
      }

      if(v_LGenBase_entityGroups[pl_eGrpIdx].isLimited == false){
        v_LGenBase_entityGroups[pl_eGrpIdx].isLimited := true;
        v_LGenBase_entityGroups[pl_eGrpIdx].origECount := v_LGenBase_entityGroups[pl_eGrpIdx].eCount;  
      } 

      // if pl_eLimit < v_LGenBase_entityGroups[pl_eGrpIdx].eCount disable entities above pl_eLimit:
      //action("disable:" & log2str(pl_eLimit)& "-tol" & log2str(v_LGenBase_entityGroups[pl_eGrpIdx].eCount-1) & "-ig");
      for( var integer vl_eRelIDx := pl_eLimit; vl_eRelIDx < v_LGenBase_entityGroups[pl_eGrpIdx].eCount; vl_eRelIDx := vl_eRelIDx + 1){
          for( var integer vl_scenIdx := 0; vl_scenIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios); vl_scenIdx := vl_scenIdx + 1){
              for( var integer vl_tcIdx := 0; vl_tcIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[vl_scenIdx].tcIdxList); vl_tcIdx := vl_tcIdx + 1){
                f_EPTF_LGenBase_disableEntityInTrafficCase(pl_tcIdx := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[vl_scenIdx].tcIdxList[vl_tcIdx],
                                                           pl_eRelIdx := vl_eRelIDx);
              }
          }
      }

      var integer vl_prevECount := v_LGenBase_entityGroups[pl_eGrpIdx].eCount;
      // set the new size to pl_eLimit
      v_LGenBase_entityGroups[pl_eGrpIdx].eCount := pl_eLimit;
      var integer vl_state;
      //action("enable init: 0-tol" & log2str(v_LGenBase_entityGroups[pl_eGrpIdx].origECount) & "-ig");
      for( var integer vl_scenIdx := 0; vl_scenIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios); vl_scenIdx := vl_scenIdx + 1){
        for( var integer vl_tcRelIdx := 0; vl_tcRelIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[vl_scenIdx].tcIdxList); vl_tcRelIdx := vl_tcRelIdx + 1){
                    var integer vl_tcIdx :=  v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[vl_scenIdx].tcIdxList[vl_tcRelIdx];
                    v_LGenBase_entityGroups[v_LGenBase_trafficCases[vl_tcIdx].eGroupBackref].eCount := pl_eLimit;
                    vl_state := v_LGenBase_trafficCases[vl_tcIdx].state;
                    f_EPTF_LGenBase_initTCInternal(v_LGenBase_trafficCases[vl_tcIdx], vl_tcIdx, true, false);
                    v_LGenBase_trafficCases[vl_tcIdx].state := vl_state;
        }
      }


      for( var integer vl_eRelIDx := 0; vl_eRelIDx < v_LGenBase_entityGroups[pl_eGrpIdx].eCount; vl_eRelIDx := vl_eRelIDx + 1){
          for( var integer vl_scenIdx := 0; vl_scenIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios); vl_scenIdx := vl_scenIdx + 1){
              for( var integer vl_tcIdx := 0; vl_tcIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[vl_scenIdx].tcIdxList); vl_tcIdx := vl_tcIdx + 1){
                f_EPTF_LGenBase_disableEntityInTrafficCase(pl_tcIdx := v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[vl_scenIdx].tcIdxList[vl_tcIdx],
                                                           pl_eRelIdx := vl_eRelIDx);
              }
          }
      }
      // enable all entities
      for( var integer vl_eRelIDx := 0; vl_eRelIDx < pl_eLimit; vl_eRelIDx := vl_eRelIDx + 1){
          for( var integer vl_scenIdx := 0; vl_scenIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios); vl_scenIdx := vl_scenIdx + 1){
              for( var integer vl_tcRelIdx := 0; vl_tcRelIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[vl_scenIdx].tcIdxList); vl_tcRelIdx := vl_tcRelIdx + 1){
                var integer vl_tcIdx :=  v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[vl_scenIdx].tcIdxList[vl_tcRelIdx];
                f_EPTF_LGenBase_enableEntityInTrafficCase(pl_tcIdx := vl_tcIdx,
                                                          pl_eRelIdx := vl_eRelIDx);
              }
          }
      }

    }

    ///////////////////////////////////////////////////////////
    //  Function: f_EPTF_LGenBase_unLimitExecution
    //
    //  Purpose:
    //    Unlimits the limited EntityGroup. 
    //
    //  Parameters:
    //    pl_eGrpIdx - *in* - *integer* - entityGroup identifier
    //
    //  Return Value:
    //    -
    //
    //  Errors:
    //    -
    //
    //  Detailed Comments:
    //
    ///////////////////////////////////////////////////////////
  public function f_EPTF_LGenBase_unLimitExecution(
      in integer pl_eGrpIdx) 
    runs on EPTF_LGenBase_Private_CT 
    {
      if( v_LGenBase_entityGroups[pl_eGrpIdx].isLimited == false  ) {
        f_EPTF_LGenBase_loggingWarning(%definitionId&" Warning : You are trying to unlimit an EntityGroup that has been unlimited before!");
        return;
      }

      v_LGenBase_entityGroups[pl_eGrpIdx].isLimited := false;
      v_LGenBase_entityGroups[pl_eGrpIdx].eCount := v_LGenBase_entityGroups[pl_eGrpIdx].origECount;  
      v_LGenBase_entityGroups[pl_eGrpIdx].origECount := 0;
      var integer vl_state;
      //action("enable init: 0-tol" & log2str(v_LGenBase_entityGroups[pl_eGrpIdx].origECount) & "-ig");
      for( var integer vl_scenIdx := 0; vl_scenIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios); vl_scenIdx := vl_scenIdx + 1){
          for( var integer vl_tcRelIdx := 0; vl_tcRelIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[vl_scenIdx].tcIdxList); vl_tcRelIdx := vl_tcRelIdx + 1){
            var integer vl_tcIdx :=  v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[vl_scenIdx].tcIdxList[vl_tcRelIdx];
            v_LGenBase_entityGroups[v_LGenBase_trafficCases[vl_tcIdx].eGroupBackref].eCount := v_LGenBase_entityGroups[pl_eGrpIdx].eCount;
            vl_state := v_LGenBase_trafficCases[vl_tcIdx].state;
            f_EPTF_LGenBase_initTCInternal(v_LGenBase_trafficCases[vl_tcIdx], vl_tcIdx, true, false);
            v_LGenBase_trafficCases[vl_tcIdx].state := vl_state;
          }
      }      
      
      for( var integer vl_eRelIDx := 0; vl_eRelIDx < v_LGenBase_entityGroups[pl_eGrpIdx].origECount; vl_eRelIDx := vl_eRelIDx + 1){
          for( var integer vl_scenIdx := 0; vl_scenIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios); vl_scenIdx := vl_scenIdx + 1){
              for( var integer vl_tcRelIdx := 0; vl_tcRelIdx < sizeof(v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[vl_scenIdx].tcIdxList); vl_tcRelIdx := vl_tcRelIdx + 1){
                var integer vl_tcIdx :=  v_LGenBase_entityGroups[pl_eGrpIdx].scenarios[vl_scenIdx].tcIdxList[vl_tcRelIdx];
                f_EPTF_LGenBase_enableEntityInTrafficCase(pl_tcIdx := vl_tcIdx,
                                                          pl_eRelIdx := vl_eRelIDx);
              }
          }
      }

    }

}

}  // end of module
