/******************************************************************************
 * Copyright (c) 2000-2018 Ericsson Telecom AB
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 ******************************************************************************/
//  File:     EPTF_CLL_Common_Functions.ttcn
//  Rev:      <RnXnn>
//  Prodnr:   CNL 113 512
//  Updated:  2009-12-09
//  Contact:  http://ttcn.ericsson.se
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
//  Module: EPTF_CLL_Common_Functions
// 
//  Purpose:
//    This module provides common functions for common for TITANSim load generators
// 
//  Module Parameters:
//    -
// 
//  Module depends on:
//    <EPTF_CLL_Common_Definitions>
// 
//  Current Owner:
//    ENORPIN
// 
//  Last Review Date:
//    2007-xx-xx
// 
//  Detailed Comments:
// 
// 
///////////////////////////////////////////////////////////
module EPTF_CLL_Common_Functions {


//=========================================================================
// Import Part
//=========================================================================

import from EPTF_CLL_Common_Definitions all;


//=========================================================================
// Functions
//========================================================================

public external function f_EPTF_Common_error(in charstring pl_message);
public external function f_EPTF_Common_warning(in charstring pl_message);
public external function f_EPTF_Common_user(in charstring pl_message);

///////////////////////////////////////////////////////////
//  Function: f_EPTF_Common_initErrorMsgs
// 
//  Purpose:
//    Initializes the ErrorMsgs database.
// 
//  Parameters:
//    -
//
//  Return Value:
//    -
//
///////////////////////////////////////////////////////////
private external function f_EPTF_Common_initErrorMsgs();

///////////////////////////////////////////////////////////
//  Function: f_EPTF_Common_init
// 
//  Purpose:
//    Initializes the Common feature.
// 
//  Parameters:
//    -
//
//  Return Value:
//    -
//
///////////////////////////////////////////////////////////
public function f_EPTF_Common_init() {
  f_EPTF_Common_initErrorMsgs();
}


///////////////////////////////////////////////////////////
//  Function: f_EPTF_Common_nofErrorMsgs
// 
//  Purpose:
//    Returns the number of error messages generated by previous <f_EPTF_Common_error> function calls.
// 
//  Parameters:
//    -
//
//  Return Value:
//    integer - the number of error messages
//
///////////////////////////////////////////////////////////
public external function f_EPTF_Common_nofErrorMsgs() return integer;
///////////////////////////////////////////////////////////
//  Function: f_EPTF_Common_getErrorMsg
// 
//  Purpose:
//   Returns an error message from the previous error messages.
// 
//  Parameters:
//    pl_errorNum - *in integer* - the id of the error message (0 for the first message)
//
//  Return Value:
//    charstring - the error message, "" if not found
//
///////////////////////////////////////////////////////////
public external function f_EPTF_Common_getErrorMsg(in integer pl_errorNum := 0) return charstring;

///////////////////////////////////////////////////////////
//  Function: f_EPTF_Common_checkExpectedError
// 
//  Purpose:
//   Checks if the expectedError message pl_expectedError was the error message at pl_errorNum or not
// 
//  Parameters:
//    pl_expectedError - *in charstring* - the expected error pattern
//    pl_errorNum - *in integer* - the id of the error message (0 for the first message)
//
//  Return Value:
//    boolean - true if the expected error pattern matches with the given error
//
//  Detailed Comments:
//   -
///////////////////////////////////////////////////////////
public function f_EPTF_Common_checkExpectedError(in charstring pl_expectedError, in integer pl_errorNum := 0) return boolean {
  if (not match(f_EPTF_Common_getErrorMsg(pl_errorNum), pattern pl_expectedError)) {
    f_EPTF_Common_warning("Warning: "&%definitionId& ": Error message with id "&int2str(pl_errorNum)&" is different from the expected pattern: "&
      log2str(match(f_EPTF_Common_getErrorMsg(pl_errorNum), pattern pl_expectedError)));
    return false;
  } else {
    f_EPTF_Common_user(%definitionId& ": Error message with id "&int2str(pl_errorNum)&" matches with the expected pattern: "& pl_expectedError);
    return true;
  }
  return true;
}

///////////////////////////////////////////////////////////
//  Group: RangeHandling
// 
//  Purpose:
//    Convinience functions to handle <EPTF_ParamRangeDescriptorList>
//
///////////////////////////////////////////////////////////
group RangeHandling {

  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_Common_resetParamRanges
  // 
  //  Purpose:
  //    Initializes the range iterators to the first elements
  //
  //  Parameters:
  //    pl_rangeList - *inout* <EPTF_ParamRangeDescriptorList> - the reference of the rangeList
  //
  //  Return Value:
  //    - 
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //    
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_Common_resetParamRanges(inout EPTF_ParamRangeDescriptorList pl_rangeList) {
    for (var integer i:=0;i<sizeof(pl_rangeList);i:=i+1) {
      pl_rangeList[i].iterator := pl_rangeList[i].baseOffset;
    }
  }

  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_Common_incParamRanges
  // 
  //  Purpose:
  //    Increases the least significant range iterator and handles
  //    carry if necessary
  //
  //  Parameters:
  //    pl_rangeList - *inout* <EPTF_ParamRangeDescriptorList> - the reference of the rangeList
  //
  //  Return Value:
  //    *boolean* - true, if the range iteration finished
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //    
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_Common_incParamRanges(inout EPTF_ParamRangeDescriptorList pl_rangeList) return boolean {
    var integer i;
    for (i:=sizeof(pl_rangeList)-1;i>=0 and f_EPTF_Common_private_incParamRangeItem(pl_rangeList[i]);i:=i-1) {}
    if (i<0) {return true}
    return false;
  }

  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_Common_private_incParamRangeItem
  // 
  //  Purpose:
  //    Used by f_EPTF_Common_incParamRanges
  //
  //  Parameters:
  //    pl_range - *inout* <EPTF_ParamRangeDescriptor> - the reference of the range
  //
  //  Return Value:
  //    *boolean* - true, if the range iteration finished
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //    
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_Common_private_incParamRangeItem(inout EPTF_ParamRangeDescriptor pl_range) return boolean {
    pl_range.iterator := pl_range.iterator + 1;
    if (pl_range.baseOffset + pl_range.count>pl_range.iterator) {return false}
    pl_range.iterator := pl_range.baseOffset;
    return true;
  }

}//group RangeHandling

///////////////////////////////////////////////////////////
//  Group: WeightedLists
// 
//  Purpose:
//    Convinience functions to distribute given nr of items
//    according weights
//
///////////////////////////////////////////////////////////
group WeightedLists {

  ///////////////////////////////////////////////////////////
  //  Function: f_EPTF_Common_fillWeightedBuckets
  // 
  //  Purpose:
  //    Increases the least significant range iterator and handles
  //    carry if necessary
  //
  //  Parameters:
  //    pl_weightList - *in* <EPTF_FloatList> - the weights, the base of the distribution
  //    pl_nrOfElements - *ini* *integer* - the nr of items to distribute
  //    pl_result - *out* <EPTF_IntegerList> - the distribution result
  //
  //  Return Value:
  //    *boolean* - true, if the algorithm succeded
  //
  //  Errors:
  //    -
  //
  //  Detailed Comments:
  //    The minimum nr of element is the number of 'buckets',
  //    i.e. the size of the pl_weightList. The elements of weightlist
  //    must be normalized (the sum of the weights must be equal to 1.0).
  //
  ///////////////////////////////////////////////////////////
  public function f_EPTF_Common_fillWeightedBuckets(in EPTF_FloatList pl_weightList, in integer pl_nrOfElements, out EPTF_IntegerList pl_result) return boolean
  {

    if (sizeof(pl_weightList)<1) {
      f_EPTF_Common_user(log2str(%definitionId,": empty weightList, unable to split"));
      return false;
    }

    if (sizeof(pl_weightList)>pl_nrOfElements) {
      f_EPTF_Common_user(log2str(%definitionId,": not enough elements, unable to split"));
      return false;
    }

    // Preparing for sorting...
    var EPTF_IntegerList vl_sortedWeightsIdx := {};
    for (var integer i:=0;i<sizeof(pl_weightList);i:=i+1) {
      vl_sortedWeightsIdx[i] := i;
    }

    // Bouble-sorting the indexes to pl_weightList
    var integer vl_tmpint;
    for (var integer i:=sizeof(pl_weightList)-1;i>=0;i:=i-1) {
      for (var integer j:=0;j<i;j:=j+1) {
        if (pl_weightList[vl_sortedWeightsIdx[j]]>pl_weightList[vl_sortedWeightsIdx[j+1]]) {
          vl_tmpint := vl_sortedWeightsIdx[j];
          vl_sortedWeightsIdx[j] := vl_sortedWeightsIdx[j+1];
          vl_sortedWeightsIdx[j+1] := vl_tmpint;
        }
      }
    }

    var integer vl_nrOfUsedElements := 0;
    pl_result := {};

    // Fill the buckets
    for (var integer i:=0;i<sizeof(pl_weightList)-1;i:=i+1) {
      pl_result[vl_sortedWeightsIdx[i]] := float2int(pl_weightList[vl_sortedWeightsIdx[i]] * int2float(pl_nrOfElements));
      if (pl_result[vl_sortedWeightsIdx[i]]<1) {pl_result[vl_sortedWeightsIdx[i]] := 1}
      vl_nrOfUsedElements := vl_nrOfUsedElements + pl_result[vl_sortedWeightsIdx[i]];
    }
    // Assign the remainder to the last item
    pl_result[vl_sortedWeightsIdx[sizeof(pl_weightList)-1]] := pl_nrOfElements - vl_nrOfUsedElements;

    return true;
  }
} // group WeightedLists

}  // end of module
